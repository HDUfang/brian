.. currentmodule:: brian

directcontrol
*************

Spike containers
~~~~~~~~~~~~~~~~

A spike container is either an iterable object or a callable object which
returns an iterable object. For example, a list is a spike container, as
is a generator, as is a function which returns a list, or a generator
function.

:class:`MultipleSpikeGeneratorGroup`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Called as::

    MultipleSpikeGeneratorGroup(spiketimes[,clock])
    
spiketimes is a list of spike containers, one for each neuron in the group.
The elements of the spike containers are spike times. Callable spike
containers are called when the group is reinitialised. If you provide
a generator rather than a callable object, reinitialising the group will
not reinitialise the generator.

So for example, the following will correspond to a group of 2 neurons, where
the first fires at times 0ms, 2ms and 5ms, and the second fires at times
1ms and 3ms::

    spiketimes = [[0*msecond, 2*msecond, 5*msecond],
                  [1*msecond, 3*msecond]]
    G = MultipleSpikeGeneratorGroup(spiketimes)

You could do the same thing with generator functions (rather perversely in
this case)::

    def st1():
        yield 0*msecond
        yield 2*msecond
        yield 5*msecond
    def st2():
        yield 1*msecond
        yield 3*msecond
    G = MultipleSpikeGeneratorGroup([st1(), st2()])

Note that if two or more spike times fall within the same dt, spikes will stack up
and come out one per dt until the stack is exhausted. A warning will be generated
if this happens.

If a clock is provided, updates of the group will be synchronised with
that clock, otherwise the standard clock guessing procedure will be used
(see :func:`~brian.clock.guess_clock` in the :mod:`~brian.clock` module).

:class:`SpikeGeneratorGroup`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Called as::

    SpikeGeneratorGroup(N,spiketimes[,clock])

where N is the number of neurons in the group, and spiketimes is a spike
container, whose elements are tuples (i,t) meaning neuron i fires at
time t. Pairs (i,t) need to be sorted in time unless spiketimes is a tuple
or list. For example::

    from math import random
    def spikefirer(N,lower,upper):
        nexttime = random.uniform(lower,upper)
        while True:
            yield (random.randint(0,N-1),nexttime)
            nexttime = nexttime + random.uniform(lower,upper)
    G = SpikeGeneratorGroup(10,uniform_isi(10,0*msecond,10*msecond))

would give a neuron group P with 10 neurons, where a random one of the neurons fires 
with an interval between spikes which is uniform in (0ms, 10ms). If spiketimes is
callable, it will be called when the group is reinitialised. If you provide
a generator rather than a callable object, reinitialising the group will
not reinitialise the generator.

Note that if a neuron fires more than one spike in a given interval dt, additional
spikes will be discarded.

If a clock is provided, updates of the group will be synchronised with
that clock, otherwise the standard clock guessing procedure will be used
(see :func:`~brian.clock.guess_clock` in the :mod:`~brian.clock` module).

:class:`PulsePacket`
~~~~~~~~~~~~~~~~~~~~

Fires a Gaussian distributed packet of n spikes with given spread, called as::

    PulsePacket(t,n,sigma[,clock])
    
You can change the parameters by calling the method ``generate(t,n,sigma)``.

If a clock is provided, updates of the group will be synchronised with
that clock, otherwise the standard clock guessing procedure will be used
(see :func:`~brian.clock.guess_clock` in the :mod:`~brian.clock` module).

