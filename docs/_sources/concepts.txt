.. _concepts:

Concepts
========

TODO: Concepts page needs to be substantially rewritten to reflect
the latest changes in Brian and also just to make it basically
useful which it isn't particularly at the moment.

.. currentmodule:: brian

Brian works by creating a series of objects representing groups of neurons, neuron
models, connectivity structure, equations, and so on, which are collected together in
a single object, the :class:`Network` object, which can then be used to run the simulation
itself.

.. _concepts-overview:

Overview
--------

Objects
*******

The most fundamental object types are:

:class:`Equations`
	A set of equations defining a neuron model.
:class:`NeuronGroup`
	This object represents a group of N neurons with a specific neuron model.
:class:`Connection`
	This object represents a connection from one group of neurons to another. At its
	simplest, it's basically just a connection matrix.
:class:`StateUpdater`
	This basically represents the equations governing each neuron, although
	it doesn't have to be directly specified by the equations.
:class:`Network`
	Contains the :class:`NeuronGroup` and :class:`Connection` objects, and runs the simulation.

Other important object types are:

:class:`Clock`
	Defines the current time and the timestep :attr:`~Clock.dt`
:class:`Monitor`
	There are a wide variety of monitors which are used to record information from
	the network, such as the times of spikes, summary statistics, or the values of
	the state variables like membrane potential.
:class:`NetworkOperation`
	A function that is called each time step in the simulation. These can be used
	to implement custom monitors, or to exert direct control over the behaviour of
	the network while it is running.

At the moment, we have not written a description of how these objects all
interact with one another and what they are intended to do. Please work through the
tutorials, look at the example files, and read the reference documentation for the
fundamental object types listed above.

Running the simulation
**********************	

When you call the run function, the following happens for each time step:

#. **Update each :class:`NeuronGroup`**, do the following:
   
   #. **Call the StateUpdater**, this does the integration step for the differential
      equation. For linear models, this is just a matrix multiplication.
   #. **Call the Threshold**, this tells you which neurons in the group
      fired a spike. Typically, this is just a test if ``V>Vt``.
   #. **Store the spikes** returned by the ``Threshold``
   
#. **Propagate spikes**, typically this is done by adding the synaptic weight
   to one of the state variables in the target neuron for each spike. This
   is done by the :class:`Connection` object.
#. **Run reset** function, for each neuron that has fired a spike, run its
   reset mechanism, which is typically just to set ``V=Vr``. This is done by
   the ``Reset`` object.

In fact, in between each of these steps you can define operations to be run.
These user defined operations can be used to exert control
over the network while it is running. See :class:`NetworkOperation` for more details.

The following diagram summarises this information:

.. image:: images/network-run-diagram.jpg

Physical quantities
*******************

Brian has a system for physical quantities with units built in, and most of the
library functions require that variables have the right units. This restriction
is useful in catching hard to find errors based on using incorrect units, and
ensures that simulated models are physically meaningful. For example, running
the following code causes an error::

	>>> from brian import *
	>>> c = Clock(t=0)
	
	Traceback (most recent call last):
	  File "<pyshell#1>", line 1, in <module>
	    c = Clock(t=0)
	  File "C:\Documents and Settings\goodman\Mes documents\Programming\Python simulator\Brian\units.py", line 1126, in new_f
	    raise DimensionMismatchError("Function " + f.__name__ + " variable " + k + " should have dimensions of " + str(au[k]), getDimensions(newkeyset[k]))
	DimensionMismatchError: Function __init__ variable t should have dimensions of s, dimensions were (1) 

You can see that Brian raises a ``DimensionMismatchError`` exception, because the
:class:`Clock` object expects ``t`` to have units of time. The correct thing to write is::

	>>> from brian import *
	>>> c = Clock(t=0*second)

Similarly, attempting to do numerical operations with inconsistent units will
raise an error::

	>>> from brian import *
	>>> 3*second+2*metre
	
	Traceback (most recent call last):
	  File "<pyshell#38>", line 1, in <module>
	    3*second+2*metre
	  File "C:\Documents and Settings\goodman\Mes documents\Programming\Python simulator\Brian\units.py", line 600, in __add__
	    if dim==self.dim:
	DimensionMismatchError: Addition, dimensions were (s) (m) 

The following fundamental SI unit names are defined:

	``metre``, ``meter`` (US spelling), ``kilogram``, ``second``, ``amp``, ``kelvin``, ``mole``, ``candle``
	
These derived SI unit names are also defined:

	``radian``, ``steradian``, ``hertz``, ``newton``, ``pascal``, ``joule``, ``watt``,
	``coulomb``, ``volt``, ``farad``, ``ohm``, ``siemens``, ``weber``, ``tesla``,
	``henry``, ``celsius``, ``lumen``, ``lux``, ``becquerel``, ``gray``, ``sievert``, ``katal``

In addition, you can form scaled versions of these units with any of the standard SI prefixes:

========== ======= ================ ========== ======= ================
Factor      Name    Symbol          Factor      Name    Symbol         
========== ======= ================ ========== ======= ================
 10^24      yotta   Y                10^-24     yocto   y
 10^21      zetta   Z                10^-21     zepto   z
 10^18      exa     E                10^-21     zepto   z
 10^15      peta    P                10^-15     femto   f
 10^12      tera    T                10^-12     pico    p
 10^9       giga    G                10^-9      nano    n
 10^6       mega    M                10^-6      micro   u (mu in SI)
 10^3       kilo    k                10^-3      milli   m
 10^2       hecto   h                10^-2      centi   c
 10^1       deka    da               10^-1      deci    d
========== ======= ================ ========== ======= ================

So for example, you could write ``fnewton`` for femto-newtons, ``Mwatt`` for megawatt, etc.

There are also units for 2nd and 3rd powers of each of the above units, for example
``metre3 = metre**3``, ``watt2 = watt*watt``, etc.

You can optionally use short names for some units derived from volts, amps,
farads, siemens, seconds, hertz and metres:
``mV, mA, uA, nA, pA, mF, uF, nF, mS, uS, ms, Hz, kHz, MHz, cm, cm2, cm3,``
``mm, mm2, mm3, um, um2, um3``.
Since these names are so short, there is a danger that they might clash with your
own variables names, so watch out for that.

TODO: unitsafefunctions and qarray stuff here
