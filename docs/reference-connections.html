<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Connections &mdash; Brian v1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '',
          VERSION:     '1.0.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: ''
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/interface.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html" />
    <link rel="index" title="Global index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Brian v1.0.0 documentation" href="index.html" />
    <link rel="up" title="Reference" href="reference.html" />
    <link rel="next" title="Network" href="reference-network.html" />
    <link rel="prev" title="Standard Groups" href="reference-standard-groups.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="reference-network.html" title="Network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian v1.0.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">Reference</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="connections">
<h1 id="connections">Connections<a class="headerlink" href="#connections" title="Permalink to this headline">¶</a></h1>
<p>The best way to understand the concept of a <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> in
Brian is to work through Tutorial 2: Connections.</p>
<dl class="class">
<dt id="brian.Connection">
<!--[brian.Connection]-->class <tt class="descclassname">brian.</tt><tt class="descname">Connection</tt><big>(</big><em>source</em>, <em>target</em>, <em>state=0</em>, <em>delay=0.0 s</em>, <em>modulation=None</em>, <em>structure='sparse'</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Mechanism for propagating spikes from one group to another</p>
<p>A Connection object declares that when spikes in a source
group are generated, certain neurons in the target group
should have a value added to specific states. See
Tutorial 2: Connections to understand this better.</p>
<p><strong>Initialised as:</strong></p>
<pre>Connection(source, target[, state=0[, delay=0*ms[, modulation=None]]])</pre>
<p>With arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">source</span></tt></dt>
<dd>The group from which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">target</span></tt></dt>
<dd>The group to which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">state</span></tt></dt>
<dd>The state variable name or number that spikes will be
propagated to in the target group.</dd>
<dt><tt class="docutils literal"><span class="pre">delay</span></tt></dt>
<dd>The delay between a spike being generated at the source
and received at the target. At the moment, the mechanism
for delays only works for relatively short delays (an
error will be generated for delays that are too long).</dd>
<dt><tt class="docutils literal"><span class="pre">modulation</span></tt></dt>
<dd>The state variable name from the source group that scales
the synaptic weights (for short-term synaptic plasticity).</dd>
<dt><tt class="docutils literal"><span class="pre">structure</span></tt></dt>
<dd>Data structure: sparse (default), dense or computed (no storing).</dd>
</dl>
<p><strong>Methods</strong></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">connect_random(P,Q,p[,weight=1[,fixed=False[,seed=None]]])</span></tt></dt>
<dd>Connects each neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to each neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with independent
probability <tt class="docutils literal"><span class="pre">p</span></tt> and weight <tt class="docutils literal"><span class="pre">weight</span></tt> (this is the amount that
gets added to the target state variable). If <tt class="docutils literal"><span class="pre">fixed</span></tt> is True, then
the number of presynaptic neurons per neuron is constant. If <tt class="docutils literal"><span class="pre">seed</span></tt>
is given, it is used as the seed to the random number generators, for
exactly repeatable results.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_full(P,Q[,weight=1])</span></tt></dt>
<dd>Connect every neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to every neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with the given
weight.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_one_to_one(P,Q)</span></tt></dt>
<dd>If <tt class="docutils literal"><span class="pre">P</span></tt> and <tt class="docutils literal"><span class="pre">Q</span></tt> have the same number of neurons then neuron <tt class="docutils literal"><span class="pre">i</span></tt>
in <tt class="docutils literal"><span class="pre">P</span></tt> will be connected to neuron <tt class="docutils literal"><span class="pre">i</span></tt> in <tt class="docutils literal"><span class="pre">Q</span></tt> with weight 1.</dd>
<dt><tt class="docutils literal"><span class="pre">connect(P,Q,W)</span></tt></dt>
<dd>You can specify a matrix of weights directly (can be in any format
recognised by NumPy). Note that due to internal implementation details,
passing a full matrix rather than a sparse one may slow down your code
(because zeros will be propagated as well as nonzero values).
<strong>WARNING:</strong> No unit checking is done at the moment.</dd>
</dl>
<p>Additionally, you can directly access the matrix of weights by writing:</p>
<div class="highlight"><pre><span class="n">C</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="k">print</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
<p>Where here <tt class="docutils literal"><span class="pre">i</span></tt> is the source neuron and <tt class="docutils literal"><span class="pre">j</span></tt> is the target neuron.
Note: if <tt class="docutils literal"><span class="pre">C[i,j]</span></tt> should be zero, it is more efficient not to write
<tt class="docutils literal"><span class="pre">C[i,j]=0</span></tt>, if you write this then when neuron <tt class="docutils literal"><span class="pre">i</span></tt> fires all the
targets will have the value 0 added to them rather than just the
nonzero ones.
<strong>WARNING:</strong> No unit checking is currently done if you use this method.
Take care to set the right units.</p>
<p><strong>Advanced information</strong></p>
<p>The following methods are also defined and used internally, if you are
writing your own derived connection class you need to understand what
these do.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">propagate(spikes)</span></tt></dt>
<dd>Action to take when source neurons with indices in <tt class="docutils literal"><span class="pre">spikes</span></tt>
fired.</dd>
<dt><tt class="docutils literal"><span class="pre">do_propagate()</span></tt></dt>
<dd>The method called by the <a title="brian.Network" class="reference external" href="reference-network.html#brian.Network"><tt class="xref docutils literal"><span class="pre">Network</span></tt></a> <tt class="docutils literal"><span class="pre">update()</span></tt> step,
typically just propagates the spikes obtained by calling
the <tt class="docutils literal"><span class="pre">get_spikes</span></tt> method of the <tt class="docutils literal"><span class="pre">source</span></tt> <a title="brian.NeuronGroup" class="reference external" href="reference-models-and-groups.html#brian.NeuronGroup"><tt class="xref docutils literal"><span class="pre">NeuronGroup</span></tt></a>.</dd>
</dl>
</dd></dl>

<div class="section" id="connection-matrix-types">
<span id="index-67"></span><h2 id="connection-matrix-types"><span id="index-67"></span>Connection matrix types<a class="headerlink" href="#connection-matrix-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="computed-connections">
<span id="index-68"></span><h3 id="computed-connections"><span id="index-68"></span>Computed connections<a class="headerlink" href="#computed-connections" title="Permalink to this headline">¶</a></h3>
<p>The following two connection matrix types can be given for a
<a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> object.</p>
<dl class="class">
<dt id="brian.UserComputedConnectionMatrix">
<!--[brian.UserComputedConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">UserComputedConnectionMatrix</tt><big>(</big><em>dims</em>, <em>row_func</em><big>)</big><a class="headerlink" href="#brian.UserComputedConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A computed connection matrix defined by a user-specified function</p>
<p>Normally this matrix will be initialised by passing the class
object to the <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> object. In the initialisation
of the <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> specify <tt class="docutils literal"><span class="pre">structure=UserComputedConnectionMatrix</span></tt>
and add the keyword <tt class="docutils literal"><span class="pre">row_func=...</span></tt>, e.g.:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">max_weight</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">UserComputedConnectionMatrix</span><span class="p">,</span> <span class="n">row_func</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
<p>Initialisation arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dims</span></tt></dt>
<dd>The pair <tt class="docutils literal"><span class="pre">(N,M)</span></tt> specifying the dimensions of the matrix.</dd>
<dt><tt class="docutils literal"><span class="pre">row_func</span></tt></dt>
<dd>The function <tt class="docutils literal"><span class="pre">f(i)</span></tt> which returns an array of length <tt class="docutils literal"><span class="pre">M</span></tt>,
the weight matrix for row <tt class="docutils literal"><span class="pre">i</span></tt>. Note that you are responsible
for making sure the function returns consistent results (so
random functions should be initialised with a seed based on
the row <tt class="docutils literal"><span class="pre">i</span></tt>).</dd>
</dl>
<p><strong>Limitations</strong></p>
<p>This type of connection matrix cannot be changed during a run, and
cannot be used with methods like <tt class="xref docutils literal"><span class="pre">Connection.connect_random</span></tt>.</p>
<p><strong>Efficiency considerations</strong></p>
<p>This connection matrix is for dense connectivity, if the connectivity
is sparse you might get better performance with <a title="brian.UserComputedSparseConnectionMatrix" class="reference internal" href="#brian.UserComputedSparseConnectionMatrix"><tt class="xref docutils literal"><span class="pre">UserComputedSparseConnectionMatrix</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.UserComputedSparseConnectionMatrix">
<!--[brian.UserComputedSparseConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">UserComputedSparseConnectionMatrix</tt><big>(</big><em>dims</em>, <em>row_func</em><big>)</big><a class="headerlink" href="#brian.UserComputedSparseConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A computed sparse connection matrix defined by a user-specified function</p>
<p>Normally this matrix will be initialised by passing the class
object to the <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> object. In the initialisation
of the <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> specify <tt class="docutils literal"><span class="pre">structure=UserComputedSparseConnectionMatrix</span></tt>
and add the keyword <tt class="docutils literal"><span class="pre">row_func=...</span></tt>, e.g.:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="mf">0</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">-</span><span class="mf">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">([</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">i</span><span class="o">&gt;</span><span class="mf">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">([</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="mf">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="mf">1</span><span class="p">))</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">UserComputedSparseConnectionMatrix</span><span class="p">,</span> <span class="n">row_func</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
<p>Initialisation arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dims</span></tt></dt>
<dd>The pair <tt class="docutils literal"><span class="pre">(N,M)</span></tt> specifying the dimensions of the matrix.</dd>
<dt><tt class="docutils literal"><span class="pre">row_func</span></tt></dt>
<dd>The function <tt class="docutils literal"><span class="pre">f(i)</span></tt> which for a row <tt class="docutils literal"><span class="pre">i</span></tt> returns a pair <tt class="docutils literal"><span class="pre">(indices,</span> <span class="pre">values))</span></tt>
consisting of a list or array <tt class="docutils literal"><span class="pre">indices</span></tt> with the indices of the
nonzero elements of the row, and an array of the same length <tt class="docutils literal"><span class="pre">values</span></tt>
giving the weight matrix for those indices. Note that you are responsible
for making sure the function returns consistent results (so
random functions should be initialised with a seed based on
the row <tt class="docutils literal"><span class="pre">i</span></tt>).</dd>
</dl>
<p><strong>Limitations</strong></p>
<p>This type of connection matrix cannot be changed during a run, and
cannot be used with methods like <tt class="xref docutils literal"><span class="pre">Connection.connect_random</span></tt>.</p>
<p><strong>Efficiency considerations</strong></p>
<p>This connection matrix is for sparse connectivity, if the connectivity
is dense you might get better performance with <a title="brian.UserComputedConnectionMatrix" class="reference internal" href="#brian.UserComputedConnectionMatrix"><tt class="xref docutils literal"><span class="pre">UserComputedConnectionMatrix</span></tt></a>.</p>
</dd></dl>

<p>These standard functions can be used to define their behaviour
as an alternative to specifying your own.</p>
<dl class="function">
<dt id="brian.random_row_func">
<!--[brian.random_row_func]--><tt class="descclassname">brian.</tt><tt class="descname">random_row_func</tt><big>(</big><em>N</em>, <em>p</em>, <em>weight=1.0</em>, <em>initseed=None</em><big>)</big><a class="headerlink" href="#brian.random_row_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random connectivity <tt class="docutils literal"><span class="pre">row_func</span></tt> for use with <a title="brian.UserComputedConnectionMatrix" class="reference internal" href="#brian.UserComputedConnectionMatrix"><tt class="xref docutils literal"><span class="pre">UserComputedConnectionMatrix</span></tt></a></p>
<p>Gives equivalent output to the <tt class="xref docutils literal"><span class="pre">Connection.connect_random()</span></tt> method.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>The number of target neurons.</dd>
<dt><tt class="docutils literal"><span class="pre">p</span></tt></dt>
<dd>The probability of a synapse.</dd>
<dt><tt class="docutils literal"><span class="pre">weight</span></tt></dt>
<dd>The connection weight (must be a single value).</dd>
<dt><tt class="docutils literal"><span class="pre">initseed</span></tt></dt>
<dd>The initial seed value (for reproducible results).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="brian.random_sparse_row_func">
<!--[brian.random_sparse_row_func]--><tt class="descclassname">brian.</tt><tt class="descname">random_sparse_row_func</tt><big>(</big><em>N</em>, <em>p</em>, <em>weight=1.0</em>, <em>initseed=None</em><big>)</big><a class="headerlink" href="#brian.random_sparse_row_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random connectivity <tt class="docutils literal"><span class="pre">row_func</span></tt> for use with <a title="brian.UserComputedSparseConnectionMatrix" class="reference internal" href="#brian.UserComputedSparseConnectionMatrix"><tt class="xref docutils literal"><span class="pre">UserComputedSparseConnectionMatrix</span></tt></a></p>
<p>Gives equivalent output to the <tt class="xref docutils literal"><span class="pre">Connection.connect_random()</span></tt> method.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>The number of target neurons.</dd>
<dt><tt class="docutils literal"><span class="pre">p</span></tt></dt>
<dd>The probability of a synapse.</dd>
<dt><tt class="docutils literal"><span class="pre">weight</span></tt></dt>
<dd>The connection weight (must be a single value).</dd>
<dt><tt class="docutils literal"><span class="pre">initseed</span></tt></dt>
<dd>The initial seed value (for reproducible results).</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">Connections</a><ul>
<li><a class="reference external" href="#connection-matrix-types">Connection matrix types</a><ul>
<li><a class="reference external" href="#computed-connections">Computed connections</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="reference-standard-groups.html" title="previous chapter">Standard Groups</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="reference-network.html" title="next chapter">Network</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/reference-connections.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="reference-network.html" title="Network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian v1.0.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">Reference</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Romain Brette, Dan Goodman.
      Last updated on Sep 23, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>