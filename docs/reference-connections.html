<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Connections &mdash; Brian v1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Brian v1.0.0 documentation" href="index.html" />
    <link rel="up" title="Reference" href="reference.html" />
    <link rel="next" title="Network" href="reference-network.html" />
    <link rel="prev" title="Standard Groups" href="reference-standard-groups.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="reference-network.html" title="Network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian v1.0.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">Reference</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="connections">
<h1>Connections<a class="headerlink" href="#connections" title="Permalink to this headline">¶</a></h1>
<p>The best way to understand the concept of a <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> in
Brian is to work through Tutorial 2: Connections.</p>
<dl class="class">
<dt id="brian.Connection">
<!--[brian.Connection]-->class <tt class="descclassname">brian.</tt><tt class="descname">Connection</tt><big>(</big><em>source</em>, <em>target</em>, <em>state=0</em>, <em>delay=0.0 s</em>, <em>modulation=None</em>, <em>structure='sparse'</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Mechanism for propagating spikes from one group to another</p>
<p>A Connection object declares that when spikes in a source
group are generated, certain neurons in the target group
should have a value added to specific states. See
Tutorial 2: Connections to understand this better.</p>
<p><strong>Initialised as:</strong></p>
<div class="highlight-python"><pre>Connection(source, target[, state=0[, delay=0*ms[, modulation=None]]])</pre>
</div>
<p>With arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">source</span></tt></dt>
<dd>The group from which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">target</span></tt></dt>
<dd>The group to which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">state</span></tt></dt>
<dd>The state variable name or number that spikes will be
propagated to in the target group.</dd>
<dt><tt class="docutils literal"><span class="pre">delay</span></tt></dt>
<dd>The delay between a spike being generated at the source
and received at the target. At the moment, the mechanism
for delays only works for relatively short delays (an
error will be generated for delays that are too long).</dd>
<dt><tt class="docutils literal"><span class="pre">modulation</span></tt></dt>
<dd>The state variable name from the source group that scales
the synaptic weights (for short-term synaptic plasticity).</dd>
<dt><tt class="docutils literal"><span class="pre">structure</span></tt></dt>
<dd>Data structure: <tt class="docutils literal"><span class="pre">sparse</span></tt> (default), <tt class="docutils literal"><span class="pre">dense</span></tt> or
<tt class="docutils literal"><span class="pre">dynamic</span></tt>. See below for more information on structures.</dd>
</dl>
<p><strong>Methods</strong></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">connect_random(P,Q,p[,weight=1[,fixed=False[,seed=None]]])</span></tt></dt>
<dd>Connects each neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to each neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with independent
probability <tt class="docutils literal"><span class="pre">p</span></tt> and weight <tt class="docutils literal"><span class="pre">weight</span></tt> (this is the amount that
gets added to the target state variable). If <tt class="docutils literal"><span class="pre">fixed</span></tt> is True, then
the number of presynaptic neurons per neuron is constant. If <tt class="docutils literal"><span class="pre">seed</span></tt>
is given, it is used as the seed to the random number generators, for
exactly repeatable results.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_full(P,Q[,weight=1])</span></tt></dt>
<dd>Connect every neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to every neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with the given
weight.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_one_to_one(P,Q)</span></tt></dt>
<dd>If <tt class="docutils literal"><span class="pre">P</span></tt> and <tt class="docutils literal"><span class="pre">Q</span></tt> have the same number of neurons then neuron <tt class="docutils literal"><span class="pre">i</span></tt>
in <tt class="docutils literal"><span class="pre">P</span></tt> will be connected to neuron <tt class="docutils literal"><span class="pre">i</span></tt> in <tt class="docutils literal"><span class="pre">Q</span></tt> with weight 1.</dd>
<dt><tt class="docutils literal"><span class="pre">connect(P,Q,W)</span></tt></dt>
<dd>You can specify a matrix of weights directly (can be in any format
recognised by NumPy). Note that due to internal implementation details,
passing a full matrix rather than a sparse one may slow down your code
(because zeros will be propagated as well as nonzero values).
<strong>WARNING:</strong> No unit checking is done at the moment.</dd>
</dl>
<p>Additionally, you can directly access the matrix of weights by writing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="k">print</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Where here <tt class="docutils literal"><span class="pre">i</span></tt> is the source neuron and <tt class="docutils literal"><span class="pre">j</span></tt> is the target neuron.
Note: if <tt class="docutils literal"><span class="pre">C[i,j]</span></tt> should be zero, it is more efficient not to write
<tt class="docutils literal"><span class="pre">C[i,j]=0</span></tt>, if you write this then when neuron <tt class="docutils literal"><span class="pre">i</span></tt> fires all the
targets will have the value 0 added to them rather than just the
nonzero ones.
<strong>WARNING:</strong> No unit checking is currently done if you use this method.
Take care to set the right units.</p>
<p><strong>Connection matrix structures</strong></p>
<p>Brian currently features three types of connection matrix structures,
each of which is suited for different situations. Brian has two stages
of connection matrix. The first is the construction stage, used for
building a weight matrix. This stage is optimised for the construction
of matrices, with lots of features, but would be slow for runtime
behaviour. Consequently, the second stage is the connection stage,
used when Brian is being run. The connection stage is optimised for
run time behaviour, but many features which are useful for construction
are absent (e.g. the ability to add or remove synapses). Conversion
between construction and connection stages is done by the
<tt class="docutils literal"><span class="pre">compress()</span></tt> method of <a title="brian.Connection" class="reference internal" href="#brian.Connection"><tt class="xref docutils literal"><span class="pre">Connection</span></tt></a> which is called
automatically when it is used for the first time.</p>
<p>The structures are:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dense</span></tt></dt>
<dd>A dense matrix. Allows runtime modification of all values. If
connectivity is close to being dense this is probably the most
efficient, but in most cases it is less efficient. In addition,
a dense connection matrix will often do the wrong thing if
using STDP. Because a synapse will be considered to exist but
with weight 0, STDP will be able to create new synapses where
there were previously none. Memory requirements are <tt class="docutils literal"><span class="pre">8NM</span></tt>
bytes where <tt class="docutils literal"><span class="pre">(N,M)</span></tt> are the dimensions. (A <tt class="docutils literal"><span class="pre">double</span></tt> float
value uses 8 bytes.)</dd>
<dt><tt class="docutils literal"><span class="pre">sparse</span></tt></dt>
<dd>A sparse matrix. See <a title="brian.SparseConnectionMatrix" class="reference internal" href="#brian.SparseConnectionMatrix"><tt class="xref docutils literal"><span class="pre">SparseConnectionMatrix</span></tt></a> for
details on implementation. This class features very fast row
access, and slower column access if the <tt class="docutils literal"><span class="pre">column_access=True</span></tt>
keyword is specified (making it suitable for learning
algorithms such as STDP which require this). Memory
requirements are 12 bytes per nonzero entry for row access
only, or 20 bytes per nonzero entry if column access is
specified. Synapses cannot be created or deleted at runtime
with this class (although weights can be set to zero).</dd>
<dt><tt class="docutils literal"><span class="pre">dynamic</span></tt></dt>
<dd>A sparse matrix which allows runtime insertion and removal
of synapses. See <a title="brian.DynamicConnectionMatrix" class="reference internal" href="#brian.DynamicConnectionMatrix"><tt class="xref docutils literal"><span class="pre">DynamicConnectionMatrix</span></tt></a> for
implementation details. This class features row and column
access. The row access is slower than for <tt class="docutils literal"><span class="pre">sparse</span></tt> so this
class should only be used when insertion and removal of
synapses is crucial. Memory requirements are 24 bytes per
nonzero entry. However, note that more memory than this
may be required because memory is allocated using a
dynamic array which grows by doubling its size when it runs
out. If you know the maximum number of nonzero entries you will
have in advance, specify the <tt class="docutils literal"><span class="pre">nnzmax</span></tt> keyword to set the
initial size of the array.</dd>
</dl>
<p><strong>Advanced information</strong></p>
<p>The following methods are also defined and used internally, if you are
writing your own derived connection class you need to understand what
these do.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">propagate(spikes)</span></tt></dt>
<dd>Action to take when source neurons with indices in <tt class="docutils literal"><span class="pre">spikes</span></tt>
fired.</dd>
<dt><tt class="docutils literal"><span class="pre">do_propagate()</span></tt></dt>
<dd>The method called by the <a title="brian.Network" class="reference external" href="reference-network.html#brian.Network"><tt class="xref docutils literal"><span class="pre">Network</span></tt></a> <tt class="docutils literal"><span class="pre">update()</span></tt> step,
typically just propagates the spikes obtained by calling
the <tt class="docutils literal"><span class="pre">get_spikes</span></tt> method of the <tt class="docutils literal"><span class="pre">source</span></tt> <a title="brian.NeuronGroup" class="reference external" href="reference-models-and-groups.html#brian.NeuronGroup"><tt class="xref docutils literal"><span class="pre">NeuronGroup</span></tt></a>.</dd>
</dl>
</dd></dl>

<div class="section" id="connection-matrix-types">
<span id="index-67"></span><h2>Connection matrix types<a class="headerlink" href="#connection-matrix-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConnectionMatrix">
<!--[brian.ConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">ConnectionMatrix</tt><a class="headerlink" href="#brian.ConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for connection matrix objects</p>
<p>Connection matrix objects support a subset of the following methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">get_row(i)</span></tt>, <tt class="docutils literal"><span class="pre">get_col(i)</span></tt></dt>
<dd>Returns row/col <tt class="docutils literal"><span class="pre">i</span></tt> as a <a title="brian.DenseConnectionVector" class="reference internal" href="#brian.DenseConnectionVector"><tt class="xref docutils literal"><span class="pre">DenseConnectionVector</span></tt></a> or
<a title="brian.SparseConnectionVector" class="reference internal" href="#brian.SparseConnectionVector"><tt class="xref docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> as appropriate for the class.</dd>
<dt><tt class="docutils literal"><span class="pre">set_row(i,</span> <span class="pre">val)</span></tt>, <tt class="docutils literal"><span class="pre">set_col(i,</span> <span class="pre">val)</span></tt></dt>
<dd>Sets row/col with an array, <a title="brian.DenseConnectionVector" class="reference internal" href="#brian.DenseConnectionVector"><tt class="xref docutils literal"><span class="pre">DenseConnectionVector</span></tt></a> or
<a title="brian.SparseConnectionVector" class="reference internal" href="#brian.SparseConnectionVector"><tt class="xref docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> (if supported).</dd>
<dt><tt class="docutils literal"><span class="pre">get_element(i,</span> <span class="pre">j)</span></tt>, <tt class="docutils literal"><span class="pre">set_element(i,</span> <span class="pre">j,</span> <span class="pre">val)</span></tt></dt>
<dd>Gets or sets a single value.</dd>
<dt><tt class="docutils literal"><span class="pre">get_rows(rows)</span></tt></dt>
<dd>Returns a list of rows, should be implemented without Python
function calls for efficiency if possible.</dd>
<dt><tt class="docutils literal"><span class="pre">insert(i,j,x)</span></tt>, <tt class="docutils literal"><span class="pre">remove(i,j)</span></tt></dt>
<dd>For sparse connection matrices which support it, insert a new
entry or remove an existing one.</dd>
<dt><tt class="docutils literal"><span class="pre">getnnz()</span></tt></dt>
<dd>Return the number of nonzero entries.</dd>
<dt><tt class="docutils literal"><span class="pre">todense()</span></tt></dt>
<dd>Return the matrix as a dense array.</dd>
</dl>
<p>The <tt class="docutils literal"><span class="pre">__getitem__</span></tt> and <tt class="docutils literal"><span class="pre">__setitem__</span></tt> methods are implemented by
default, and automatically select the appropriate methods from the
above in the cases where the item to be got or set is of the form
<tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">i,:</span></tt>, <tt class="docutils literal"><span class="pre">:,j</span></tt> or <tt class="docutils literal"><span class="pre">i,j</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConnectionMatrix">
<!--[brian.DenseConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">DenseConnectionMatrix</tt><big>(</big><em>val</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DenseConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense connection matrix</p>
<p>See documentation for <a title="brian.ConnectionMatrix" class="reference internal" href="#brian.ConnectionMatrix"><tt class="xref docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This matrix implements a dense connection matrix. It is just
a numpy array. The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<tt class="xref docutils literal"><span class="pre">DenseConnectionVector`</span></tt> objects.</p>
</dd></dl>

<dl class="class">
<dt id="brian.SparseConnectionMatrix">
<!--[brian.SparseConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">SparseConnectionMatrix</tt><big>(</big><em>val</em>, <em>column_access=True</em><big>)</big><a class="headerlink" href="#brian.SparseConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse connection matrix</p>
<p>See documentation for <a title="brian.ConnectionMatrix" class="reference internal" href="#brian.ConnectionMatrix"><tt class="xref docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This class implements a sparse matrix with a fixed number of nonzero
entries. Row access is very fast, and if the <tt class="docutils literal"><span class="pre">column_access</span></tt> keyword
is <tt class="xref docutils literal"><span class="pre">True</span></tt> then column access is also supported (but is not as fast
as row access).</p>
<p>The matrix should be initialised with a scipy sparse matrix.</p>
<p>The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<a title="brian.SparseConnectionVector" class="reference internal" href="#brian.SparseConnectionVector"><tt class="xref docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> objects. In addition to the
usual slicing operations supported, <tt class="docutils literal"><span class="pre">M[:]=val</span></tt> is supported, where
<tt class="docutils literal"><span class="pre">val</span></tt> must be a scalar or an array of length <tt class="docutils literal"><span class="pre">nnz</span></tt>.</p>
<p>Implementation details:</p>
<p>The values are stored in an array <tt class="docutils literal"><span class="pre">alldata</span></tt> of length <tt class="docutils literal"><span class="pre">nnz</span></tt> (number
of nonzero entries). The slice <tt class="docutils literal"><span class="pre">alldata[rowind[i]:rowind[i+1]]</span></tt> gives
the values for row <tt class="docutils literal"><span class="pre">i</span></tt>. These slices are stored in the list <tt class="docutils literal"><span class="pre">rowdata</span></tt>
so that <tt class="docutils literal"><span class="pre">rowdata[i]</span></tt> is the data for row <tt class="docutils literal"><span class="pre">i</span></tt>. The array <tt class="docutils literal"><span class="pre">rowj[i]</span></tt>
gives the corresponding column <tt class="docutils literal"><span class="pre">j</span></tt> indices. For row access, the
memory requirements are 12 bytes per entry (8 bytes for the float value,
and 4 bytes for the column indices). The array <tt class="docutils literal"><span class="pre">allj</span></tt> of length <tt class="docutils literal"><span class="pre">nnz</span></tt>
gives the column <tt class="docutils literal"><span class="pre">j</span></tt> coordinates for each element in <tt class="docutils literal"><span class="pre">alldata</span></tt> (the
elements of <tt class="docutils literal"><span class="pre">rowj</span></tt> are slices of this array so no extra memory is
used).</p>
<p>If column access is being used, then in addition to the above there are
lists <tt class="docutils literal"><span class="pre">coli</span></tt> and <tt class="docutils literal"><span class="pre">coldataindices</span></tt>. For column <tt class="docutils literal"><span class="pre">j</span></tt>, the array
<tt class="docutils literal"><span class="pre">coli[j]</span></tt> gives the row indices for the data values in column <tt class="docutils literal"><span class="pre">j</span></tt>,
while <tt class="docutils literal"><span class="pre">coldataindices[j]</span></tt> gives the indices in the array <tt class="docutils literal"><span class="pre">alldata</span></tt>
for the values in column <tt class="docutils literal"><span class="pre">j</span></tt>. Column access therefore involves a
copy operation rather than a slice operation. Column access increases
the memory requirements to 20 bytes per entry (4 extra bytes for the
row indices and 4 extra bytes for the data indices).</p>
</dd></dl>

<dl class="class">
<dt id="brian.DynamicConnectionMatrix">
<!--[brian.DynamicConnectionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">DynamicConnectionMatrix</tt><big>(</big><em>val</em>, <em>nnzmax=None</em>, <em>dynamic_array_const=2</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DynamicConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic (sparse) connection matrix</p>
<p>See documentation for <a title="brian.ConnectionMatrix" class="reference internal" href="#brian.ConnectionMatrix"><tt class="xref docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This class implements a sparse matrix with a variable number of nonzero
entries. Row access and column access are provided, but are not as fast
as for <a title="brian.SparseConnectionMatrix" class="reference internal" href="#brian.SparseConnectionMatrix"><tt class="xref docutils literal"><span class="pre">SparseConnectionMatrix</span></tt></a>.</p>
<p>The matrix should be initialised with a scipy sparse matrix.</p>
<p>The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<a title="brian.SparseConnectionVector" class="reference internal" href="#brian.SparseConnectionVector"><tt class="xref docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> objects. In addition to the
usual slicing operations supported, <tt class="docutils literal"><span class="pre">M[:]=val</span></tt> is supported, where
<tt class="docutils literal"><span class="pre">val</span></tt> must be a scalar or an array of length <tt class="docutils literal"><span class="pre">nnz</span></tt>.</p>
<p><strong>Implementation details</strong></p>
<p>The values are stored in an array <tt class="docutils literal"><span class="pre">alldata</span></tt> of length <tt class="docutils literal"><span class="pre">nnzmax</span></tt> (maximum
number of nonzero entries). This is a dynamic array, see:</p>
<blockquote>
<a class="reference external" href="http://en.wikipedia.org/wiki/Dynamic_array">http://en.wikipedia.org/wiki/Dynamic_array</a></blockquote>
<p>You can set the resizing constant with the argument <tt class="docutils literal"><span class="pre">dynamic_array_const</span></tt>.
Normally the default value 2 is fine but if memory is a worry it could be
made smaller.</p>
<p>Rows and column point in to this data array, and the list <tt class="docutils literal"><span class="pre">rowj</span></tt> consists
of an array of column indices for each row, with <tt class="docutils literal"><span class="pre">coli</span></tt> containing arrays
of row indices for each column. Similarly, <tt class="docutils literal"><span class="pre">rowdataind</span></tt> and <tt class="docutils literal"><span class="pre">coldataind</span></tt>
consist of arrays of pointers to the indices in the <tt class="docutils literal"><span class="pre">alldata</span></tt> array.</p>
</dd></dl>

</div>
<div class="section" id="construction-matrix-types">
<h2>Construction matrix types<a class="headerlink" href="#construction-matrix-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConstructionMatrix">
<!--[brian.ConstructionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">ConstructionMatrix</tt><a class="headerlink" href="#brian.ConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for construction matrices</p>
<p>A construction matrix is used to initialise and build connection matrices.
A <tt class="docutils literal"><span class="pre">ConstructionMatrix</span></tt> class has to implement a method
<tt class="docutils literal"><span class="pre">connection_matrix(*args,</span> <span class="pre">**kwds)</span></tt> which returns a <a title="brian.ConnectionMatrix" class="reference internal" href="#brian.ConnectionMatrix"><tt class="xref docutils literal"><span class="pre">ConnectionMatrix</span></tt></a>
object of the appropriate type.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConstructionMatrix">
<!--[brian.DenseConstructionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">DenseConstructionMatrix</tt><big>(</big><em>val</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DenseConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense construction matrix. Essentially just numpy.ndarray.</p>
<p>The <tt class="docutils literal"><span class="pre">connection_matrix</span></tt> method returns a <a title="brian.DenseConnectionMatrix" class="reference internal" href="#brian.DenseConnectionMatrix"><tt class="xref docutils literal"><span class="pre">DenseConnectionMatrix</span></tt></a>
object.</p>
<p>The <tt class="docutils literal"><span class="pre">__setitem__</span></tt> method is overloaded so that you can set values with
a sparse matrix.</p>
</dd></dl>

<dl class="class">
<dt id="brian.SparseConstructionMatrix">
<!--[brian.SparseConstructionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">SparseConstructionMatrix</tt><big>(</big><em>arg</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.SparseConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd>SparseConstructionMatrix is converted to SparseConnectionMatrix.</dd></dl>

<dl class="class">
<dt id="brian.DynamicConstructionMatrix">
<!--[brian.DynamicConstructionMatrix]-->class <tt class="descclassname">brian.</tt><tt class="descname">DynamicConstructionMatrix</tt><big>(</big><em>arg</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DynamicConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd>DynamicConstructionMatrix is converted to DynamicConnectionMatrix.</dd></dl>

</div>
<div class="section" id="connection-vector-types">
<h2>Connection vector types<a class="headerlink" href="#connection-vector-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConnectionVector">
<!--[brian.ConnectionVector]-->class <tt class="descclassname">brian.</tt><tt class="descname">ConnectionVector</tt><a class="headerlink" href="#brian.ConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for connection vectors, just used for defining the interface</p>
<p>ConnectionVector objects are returned by ConnectionMatrix objects when
they retrieve rows or columns. At the moment, there are two choices,
sparse or dense.</p>
<p>This class has no real function at the moment.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConnectionVector">
<!--[brian.DenseConnectionVector]-->class <tt class="descclassname">brian.</tt><tt class="descname">DenseConnectionVector</tt><a class="headerlink" href="#brian.DenseConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd>Just a numpy array.</dd></dl>

<dl class="class">
<dt id="brian.SparseConnectionVector">
<!--[brian.SparseConnectionVector]-->class <tt class="descclassname">brian.</tt><tt class="descname">SparseConnectionVector</tt><a class="headerlink" href="#brian.SparseConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse vector class</p>
<p>A sparse vector is typically a row or column of a sparse matrix. This
class can be treated in many cases as if it were just a vector without
worrying about the fact that it is sparse. For example, if you write
<tt class="docutils literal"><span class="pre">2*v</span></tt> it will evaluate to a new sparse vector. There is one aspect
of the semantics which is potentially confusing. In a binary operation
with a dense vector such as <tt class="docutils literal"><span class="pre">sv+dv</span></tt> where <tt class="docutils literal"><span class="pre">sv</span></tt> is sparse and <tt class="docutils literal"><span class="pre">dv</span></tt>
is dense, the result will be a sparse vector with zeros where <tt class="docutils literal"><span class="pre">sv</span></tt>
has zeros, the potentially nonzero elements of <tt class="docutils literal"><span class="pre">dv</span></tt> where <tt class="docutils literal"><span class="pre">sv</span></tt> has
no entry will be simply ignored. It is for this reason that it is a
<tt class="docutils literal"><span class="pre">SparseConnectionVector</span></tt> and not a general <tt class="docutils literal"><span class="pre">SparseVector</span></tt>, because
these semantics make sense for rows and columns of connection matrices
but not in general.</p>
<p>Implementation details:</p>
<p>The underlying numpy array contains the values, the attribute <tt class="docutils literal"><span class="pre">n</span></tt> is
the length of the sparse vector, and <tt class="docutils literal"><span class="pre">ind</span></tt> is an array of the indices
of the nonzero elements.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Connections</a><ul>
<li><a class="reference external" href="#connection-matrix-types">Connection matrix types</a></li>
<li><a class="reference external" href="#construction-matrix-types">Construction matrix types</a></li>
<li><a class="reference external" href="#connection-vector-types">Connection vector types</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="reference-standard-groups.html" title="previous chapter">Standard Groups</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="reference-network.html" title="next chapter">Network</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/reference-connections.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="reference-network.html" title="Network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian v1.0.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Romain Brette, Dan Goodman.
      Last updated on Jan 19, 2009.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.1.
    </div>
  </body>
</html>