<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>brian.numpywrappers</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="brian-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="brian-module.html">Package&nbsp;brian</a> ::
        Module&nbsp;numpywrappers
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module numpywrappers</h1><br /><br />
<pre class="literalblock">

Numpy wrapper functions

To extend the functionality of the units system, this module
wraps any numpy function that hasn't already been defined by
the Brian units system so that it will work with dimensionless
quantity arrays, and will return arrays rather than qarrays.

Both numpy and scipy functions are wrapped, with scipy versions
given preference over numpy versions.
Behaviour defined by Brian comes from the following sources:

* unitsafefunctions module: any names in this are not wrapped
* ufuncs: any known ufunc implemented in quantityarray should not
  be wrapped, this is defined by the variable
  quantityarray.known_ufuncs.
* qarray methods: any method implemented specifically by
  qarray should not be wrapped (e.g. mean, std, var).

In addition, any numpy/scipy function with 'array' in its name
is not wrapped (e.g. array and asarray).

</pre><br /><br />

<hr />
<div class="fields">      <p><strong>Version:</strong>
        0.6.0
      </p>
</div><!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="test"></a><span class="summary-sig-name">test</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Run Scipy tests suite with level and verbosity.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#DataSource" class="summary-sig-name">DataSource</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      A generic data source file (file, http, ftp, ...).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#MachAr" class="summary-sig-name">MachAr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Diagnosing machine parameters.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#NumpyTest" class="summary-sig-name">NumpyTest</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Numpy tests site manager.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="PackageLoader"></a><span class="summary-sig-name">PackageLoader</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="RankWarning"></a><span class="summary-sig-name">RankWarning</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Issued by polyfit when Vandermonde matrix is rank deficient.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ScipyTest"></a><span class="summary-sig-name">ScipyTest</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#add_docstring" class="summary-sig-name">add_docstring</a>(<span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">docstring</span>)</span><br />
      Add a docstring to a built-in obj if possible.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#add_newdoc" class="summary-sig-name">add_newdoc</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Adds documentation to obj which is in module place.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#alen" class="summary-sig-name">alen</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the length of a Python object interpreted as an array
of at least 1 dimension.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#all" class="summary-sig-name">all</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Check if all of the elements of `a` are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#allclose" class="summary-sig-name">allclose</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns True if all components of a and b are equal subject to given
tolerances.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#alltrue" class="summary-sig-name">alltrue</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Check if all of the elements of `a` are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="alterdot"></a><span class="summary-sig-name">alterdot</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      alterdot() changes all dot functions to use blas.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#amax" class="summary-sig-name">amax</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the maximum along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#amin" class="summary-sig-name">amin</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the minimum along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#angle" class="summary-sig-name">angle</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the angle of the complex argument z.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#any" class="summary-sig-name">any</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Check if any of the elements of `a` are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#append" class="summary-sig-name">append</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Append to the end of an array along axis (ravel first if None)...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#apply_along_axis" class="summary-sig-name">apply_along_axis</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Execute func1d(arr[i],*args) where func1d takes 1-D arrays
and arr is an N-d array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#apply_over_axes" class="summary-sig-name">apply_over_axes</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Apply a function repeatedly over multiple axes, keeping the same shape
for the resulting array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="arctan2"></a><span class="summary-sig-name">arctan2</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = arctan2(x1,x2) a safe and correct arctan(x1/x2)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#argwhere" class="summary-sig-name">argwhere</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a 2-d array of shape N x a.ndim where each row
is a sequence of indices into a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#around" class="summary-sig-name">around</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Round a to the given number of decimals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#asmatrix" class="summary-sig-name">asmatrix</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns 'data' as a matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="asscalar"></a><span class="summary-sig-name">asscalar</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Convert an array of size 1 to its scalar equivalent.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#atleast_1d" class="summary-sig-name">atleast_1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Force a sequence of arrays to each be at least 1D.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#atleast_2d" class="summary-sig-name">atleast_2d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Force a sequence of arrays to each be at least 2D.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#atleast_3d" class="summary-sig-name">atleast_3d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Force a sequence of arrays to each be at least 3D.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#average" class="summary-sig-name">average</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the weighted average of array a over the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#bartlett" class="summary-sig-name">bartlett</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the Bartlett window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#base_repr" class="summary-sig-name">base_repr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the representation of a number in the given base.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#binary_repr" class="summary-sig-name">binary_repr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the binary representation of the input number as a string.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#bincount" class="summary-sig-name">bincount</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the number of occurrences of each value in x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bitwise_and"></a><span class="summary-sig-name">bitwise_and</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = bitwise_and(x1,x2) computes x1 &amp; x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bitwise_not"></a><span class="summary-sig-name">bitwise_not</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = invert(x) computes ~x (bit inversion) elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bitwise_or"></a><span class="summary-sig-name">bitwise_or</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = bitwise_or(x1,x2) computes x1 | x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bitwise_xor"></a><span class="summary-sig-name">bitwise_xor</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = bitwise_xor(x1,x2) computes x1 ^ x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="blackman"></a><span class="summary-sig-name">blackman</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      blackman(M) returns the M-point Blackman window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#bmat" class="summary-sig-name">bmat</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Build a matrix object from string, nested sequence, or array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bool8"></a><span class="summary-sig-name">bool8</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="bool_"></a><span class="summary-sig-name">bool_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="broadcast"></a><span class="summary-sig-name">broadcast</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="byte"></a><span class="summary-sig-name">byte</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#byte_bounds" class="summary-sig-name">byte_bounds</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      (low, high) are pointers to the end-points of an array

low is the first byte
high is just *past* the last byte

If the array is not single-segment, then it may not actually
use every byte between these bounds.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="can_cast"></a><span class="summary-sig-name">can_cast</span>(<span class="summary-sig-arg">from</span>=<span class="summary-sig-default">d1</span>,
        <span class="summary-sig-arg">to</span>=<span class="summary-sig-default">d2</span>)</span><br />
      Returns True if data type d1 can be cast to data type d2 without
losing precision.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="cdouble"></a><span class="summary-sig-name">cdouble</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 64 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#central_diff_weights" class="summary-sig-name">central_diff_weights</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return weights for an Np-point central derivative of order ndiv
assuming equally-spaced function points.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="cfloat"></a><span class="summary-sig-name">cfloat</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 64 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="character"></a><span class="summary-sig-name">character</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#choose" class="summary-sig-name">choose</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Use an index array to construct a new array from a set of
choices.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#clip" class="summary-sig-name">clip</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return an array whose values are limited to [a_min, a_max].</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="clongdouble"></a><span class="summary-sig-name">clongdouble</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 96 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="clongfloat"></a><span class="summary-sig-name">clongfloat</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 96 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#column_stack" class="summary-sig-name">column_stack</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Stack 1D arrays as columns into a 2D array

Description:
    Take a sequence of 1D arrays and stack them as columns
    to make a single 2D array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#comb" class="summary-sig-name">comb</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Combinations of N things taken k at a time.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#common_type" class="summary-sig-name">common_type</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Given a sequence of arrays as arguments, return the best inexact
scalar type which is &quot;most&quot; common amongst them.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="complex128"></a><span class="summary-sig-name">complex128</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 64 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="complex192"></a><span class="summary-sig-name">complex192</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 96 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="complex64"></a><span class="summary-sig-name">complex64</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 32 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="complex_"></a><span class="summary-sig-name">complex_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 64 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="complexfloating"></a><span class="summary-sig-name">complexfloating</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#compress" class="summary-sig-name">compress</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return selected slices of an array along given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#concatenate" class="summary-sig-name">concatenate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      concatenate((a1, a2, ...), axis=0)

Join arrays together.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="conj"></a><span class="summary-sig-name">conj</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = conjugate(x) takes the conjugate of x elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="conjugate"></a><span class="summary-sig-name">conjugate</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = conjugate(x) takes the conjugate of x elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="convolve"></a><span class="summary-sig-name">convolve</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns the discrete, linear convolution of 1-D sequences a and v; mode
can be 'valid', 'same', or 'full' to specify size of the resulting sequence.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#corrcoef" class="summary-sig-name">corrcoef</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      The correlation coefficients...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#correlate" class="summary-sig-name">correlate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the discrete, linear correlation of 1-D sequences a and v; mode...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#cov" class="summary-sig-name">cov</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Estimate the covariance matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#cross" class="summary-sig-name">cross</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the cross product of two (arrays of) vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="csingle"></a><span class="summary-sig-name">csingle</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 32 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#cumprod" class="summary-sig-name">cumprod</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the cumulative product of the elements along the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#cumproduct" class="summary-sig-name">cumproduct</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the cumulative product over the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="degrees"></a><span class="summary-sig-name">degrees</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = degrees(x) converts angle from radians to degrees</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#delete" class="summary-sig-name">delete</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a new array with sub-arrays along an axis deleted.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#deprecate" class="summary-sig-name">deprecate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Deprecate old functions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#deprecate_with_doc" class="summary-sig-name">deprecate_with_doc</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Decorator to deprecate functions and provide detailed documentation
with 'somestr' that is added to the functions docstring.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#derivative" class="summary-sig-name">derivative</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Given a function, use a central difference formula with spacing dx to
compute the nth derivative at x0.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="diag"></a><span class="summary-sig-name">diag</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns a copy of the the k-th diagonal if v is a 2-d array
or returns a 2-d array with v as the k-th diagonal if v is a
1-d array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#diagflat" class="summary-sig-name">diagflat</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a 2D array whose k'th diagonal is a flattened v and all other
elements are zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#diagonal" class="summary-sig-name">diagonal</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return specified diagonals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="diff"></a><span class="summary-sig-name">diff</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Calculate the nth order discrete difference along given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#digitize" class="summary-sig-name">digitize</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">bins</span>)</span><br />
      Return the index of the bin to which each value of x belongs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="disp"></a><span class="summary-sig-name">disp</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Display a message to the given device (default is sys.stdout)
with or without a linefeed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="divide"></a><span class="summary-sig-name">divide</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = divide(x1,x2) divides the arguments elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="double"></a><span class="summary-sig-name">double</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#dsplit" class="summary-sig-name">dsplit</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Split ary into multiple sub-arrays along the 3rd axis (depth)

Description:
    Split a single array into multiple sub arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#dstack" class="summary-sig-name">dstack</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Stack arrays in sequence depth wise (along third dimension)

Description:
    Take a sequence of arrays and stack them along the third axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#dtype" class="summary-sig-name">dtype</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Create a data type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ediff1d" class="summary-sig-name">ediff1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      The differences between consecutive elements of an array, possibly with
prefixed and/or appended values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#errstate" class="summary-sig-name">errstate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      with errstate(**state): --&gt; operations in following block use given state.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="expand_dims"></a><span class="summary-sig-name">expand_dims</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Expand the shape of a by including newaxis before given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="expm1"></a><span class="summary-sig-name">expm1</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = expm1(x) e**x-1 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#extract" class="summary-sig-name">extract</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the elements of ravel(arr) where ravel(condition) is True
(in 1D).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="fabs"></a><span class="summary-sig-name">fabs</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = fabs(x) absolute values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#factorial" class="summary-sig-name">factorial</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      n! = special.gamma(n+1)

If exact==0, then floating point precision is used, otherwise
exact long integer is computed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#factorial2" class="summary-sig-name">factorial2</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd
       = 2**(n) * n!                                 n even

If exact==0, then floating point precision is used, otherwise
exact long integer is computed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#factorialk" class="summary-sig-name">factorialk</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      n(!!...!)  = multifactorial of order k...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="fastCopyAndTranspose"></a><span class="summary-sig-name">fastCopyAndTranspose</span>(<span class="summary-sig-arg">a</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fft" class="summary-sig-name">fft</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">n</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Return the n point discrete Fourier transform of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#find_common_type" class="summary-sig-name">find_common_type</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Determine common type following standard coercion rules

Parameters
----------
array_types : sequence
    A list of dtype convertible objects representing arrays
scalar_types : sequence
    A list of dtype convertible objects representing scalars

Returns
-------
datatype : dtype
    The common data-type which is the maximum of the array_types
    ignoring the scalar_types unless the maximum of the scalar_types
    is of a different kind.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#finfo" class="summary-sig-name">finfo</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Machine limits for floating point types.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="fix"></a><span class="summary-sig-name">fix</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Round x to nearest integer towards zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="flatiter"></a><span class="summary-sig-name">flatiter</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#flatnonzero" class="summary-sig-name">flatnonzero</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return indicies that are not-zero in flattened version of a...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="flexible"></a><span class="summary-sig-name">flexible</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fliplr" class="summary-sig-name">fliplr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns an array m with the rows preserved and columns flipped
in the left/right direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#flipud" class="summary-sig-name">flipud</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns an array with the columns preserved and rows flipped in
the up/down direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="float32"></a><span class="summary-sig-name">float32</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="float64"></a><span class="summary-sig-name">float64</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="float96"></a><span class="summary-sig-name">float96</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="float_"></a><span class="summary-sig-name">float_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="floating"></a><span class="summary-sig-name">floating</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="floor_divide"></a><span class="summary-sig-name">floor_divide</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = floor_divide(x1,x2) floor divides the arguments elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="fmod"></a><span class="summary-sig-name">fmod</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = fmod(x1,x2) computes (C-like) x1 % x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#format_parser" class="summary-sig-name">format_parser</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Class to convert formats, names, titles description to a dtype

After constructing the format_parser object, the dtype attribute is
  the converted data-type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="frexp"></a><span class="summary-sig-name">frexp</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y1,y2 = frexp(x) Split the number, x, into a normalized fraction (y1) and exponent (y2)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#frombuffer" class="summary-sig-name">frombuffer</a>(<span class="summary-sig-arg">buffer</span>=<span class="summary-sig-default"></span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">0</span>)</span><br />
      Returns a 1-d array of data type dtype from buffer.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fromfile" class="summary-sig-name">fromfile</a>(<span class="summary-sig-arg">file</span>=<span class="summary-sig-default"></span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">sep</span>=<span class="summary-sig-default">''</span>)</span><br />
      Return an array of the given data type from a text or binary file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fromfunction" class="summary-sig-name">fromfunction</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns an array constructed by calling a function on a tuple of number
grids.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fromiter" class="summary-sig-name">fromiter</a>(<span class="summary-sig-arg">iterable</span>,
        <span class="summary-sig-arg">dtype</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Return a new 1d array initialized from iterable.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#frompyfunc" class="summary-sig-name">frompyfunc</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      frompyfunc(func, nin, nout) take an arbitrary python function that takes nin objects as input and returns nout objects and return a universal function (ufunc).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fromregex" class="summary-sig-name">fromregex</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Construct an array from a text file, using regular-expressions
parsing.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fromstring" class="summary-sig-name">fromstring</a>(<span class="summary-sig-arg">string</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">sep</span>=<span class="summary-sig-default">''</span>)</span><br />
      Return a new 1d array initialized from the raw binary data in string.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#fv" class="summary-sig-name">fv</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      future value computed by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Example
--------

What is the future value after 10 years of saving $100 now, with
  an additional monthly savings of $100.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="generic"></a><span class="summary-sig-name">generic</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#get_include" class="summary-sig-name">get_include</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the directory in the package that contains the numpy/*.h header
files.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#get_numpy_include" class="summary-sig-name">get_numpy_include</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      get_numpy_include is DEPRECATED!! -- use get_include instead

Return the directory in the package that contains the numpy/*.h header
    files.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#get_printoptions" class="summary-sig-name">get_printoptions</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the current print options.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#getbuffer" class="summary-sig-name">getbuffer</a>(<span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">...</span>,
        <span class="summary-sig-arg">size</span>=<span class="summary-sig-default">...</span>)</span><br />
      Create a buffer object from the given object referencing a slice of
length size starting at offset.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="getbufsize"></a><span class="summary-sig-name">getbufsize</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the size of the buffer used in ufuncs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#geterr" class="summary-sig-name">geterr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Get the current way of handling floating-point errors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="geterrcall"></a><span class="summary-sig-name">geterrcall</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the current callback function used on floating-point errors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#geterrobj" class="summary-sig-name">geterrobj</a>()</span><br />
      Used internally by `geterr`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#gradient" class="summary-sig-name">gradient</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Calculate the gradient of an N-dimensional scalar function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="hamming"></a><span class="summary-sig-name">hamming</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      hamming(M) returns the M-point Hamming window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="hanning"></a><span class="summary-sig-name">hanning</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      hanning(M) returns the M-point Hanning window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#histogram" class="summary-sig-name">histogram</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Compute the histogram from a set of data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#histogram2d" class="summary-sig-name">histogram2d</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>,
        <span class="summary-sig-arg">bins</span>=<span class="summary-sig-default">10</span>,
        <span class="summary-sig-arg">range</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normed</span>=<span class="summary-sig-default">False</span>)</span><br />
      Compute the 2D histogram from samples x,y.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#histogramdd" class="summary-sig-name">histogramdd</a>(<span class="summary-sig-arg">sample</span>,
        <span class="summary-sig-arg">bins</span>=<span class="summary-sig-default">10</span>,
        <span class="summary-sig-arg">range</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normed</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the N-dimensional histogram of the sample.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#hsplit" class="summary-sig-name">hsplit</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Split ary into multiple columns of sub-arrays

Description:
    Split a single array into multiple sub arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#hstack" class="summary-sig-name">hstack</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Stack arrays in sequence horizontally (column wise)

Description:
    Take a sequence of arrays and stack them horizontally
    to make a single array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="hypot"></a><span class="summary-sig-name">hypot</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = hypot(x1,x2) sqrt(x1**2 + x2**2) elementwise</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="i0"></a><span class="summary-sig-name">i0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ifft" class="summary-sig-name">ifft</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">n</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Return the n point inverse discrete Fourier transform of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#iinfo" class="summary-sig-name">iinfo</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Limits for integer types.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#imag" class="summary-sig-name">imag</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the imaginary part of val.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="indices"></a><span class="summary-sig-name">indices</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns an array representing a grid of indices with row-only, and
column-only variation.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="inexact"></a><span class="summary-sig-name">inexact</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#info" class="summary-sig-name">info</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Get help information for a function, class, or module.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#inner" class="summary-sig-name">inner</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Returns the inner product of a and b for arrays of floating point types.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#insert" class="summary-sig-name">insert</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a new array with values inserted along the given axis
before the given indices

If axis is None, then ravel the array first.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int0"></a><span class="summary-sig-name">int0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int16"></a><span class="summary-sig-name">int16</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int32"></a><span class="summary-sig-name">int32</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int64"></a><span class="summary-sig-name">int64</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int8"></a><span class="summary-sig-name">int8</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int_"></a><span class="summary-sig-name">int_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int_asbuffer"></a><span class="summary-sig-name">int_asbuffer</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="intc"></a><span class="summary-sig-name">intc</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="integer"></a><span class="summary-sig-name">integer</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#interp" class="summary-sig-name">interp</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the value of a piecewise-linear function at each value in x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#intersect1d" class="summary-sig-name">intersect1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Intersection of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#intersect1d_nu" class="summary-sig-name">intersect1d_nu</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Intersection of 1D arrays with any elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="intp"></a><span class="summary-sig-name">intp</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="invert"></a><span class="summary-sig-name">invert</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = invert(x) computes ~x (bit inversion) elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ipmt"></a><span class="summary-sig-name">ipmt</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#irr" class="summary-sig-name">irr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Internal Rate of Return...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#iscomplex" class="summary-sig-name">iscomplex</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a boolean array where elements are True if that element
is complex (has non-zero imaginary part).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#iscomplexobj" class="summary-sig-name">iscomplexobj</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return True if x is a complex type or an array of complex numbers.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="isfinite"></a><span class="summary-sig-name">isfinite</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = isfinite(x) returns True where x is finite</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#isfortran" class="summary-sig-name">isfortran</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns True if 'a' is arranged in Fortran-order in memory with a.ndim &gt; 1...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="isinf"></a><span class="summary-sig-name">isinf</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = isinf(x) returns True where x is +inf or -inf</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="isnan"></a><span class="summary-sig-name">isnan</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = isnan(x) returns True where x is Not-A-Number</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#isneginf" class="summary-sig-name">isneginf</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a boolean array y with y[i] True for x[i] = -Inf.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#isposinf" class="summary-sig-name">isposinf</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a boolean array y with y[i] True for x[i] = +Inf.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="isreal"></a><span class="summary-sig-name">isreal</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a boolean array where elements are True if that element
is real (has zero imaginary part)

For scalars, return a boolean.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#isrealobj" class="summary-sig-name">isrealobj</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return True if x is not a complex type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="isscalar"></a><span class="summary-sig-name">isscalar</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns True if the type of num is a scalar type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issctype"></a><span class="summary-sig-name">issctype</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Determines whether the given object represents
a numeric array type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issubclass_"></a><span class="summary-sig-name">issubclass_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issubdtype"></a><span class="summary-sig-name">issubdtype</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issubsctype"></a><span class="summary-sig-name">issubsctype</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="iterable"></a><span class="summary-sig-name">iterable</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ix_" class="summary-sig-name">ix_</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Construct an open mesh from multiple sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="kaiser"></a><span class="summary-sig-name">kaiser</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      kaiser(M, beta) returns a Kaiser window of length M with shape parameter
beta.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#kron" class="summary-sig-name">kron</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      kronecker product of a and b

Kronecker product of two arrays is block array
[[ a[ 0 ,0]*b, a[ 0 ,1]*b, ...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ldexp"></a><span class="summary-sig-name">ldexp</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = ldexp(x1,x2) Compute y = x1 * 2**x2.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="left_shift"></a><span class="summary-sig-name">left_shift</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = left_shift(x1,x2) computes x1 &lt;&lt; x2 (x1 shifted to left by x2 bits) elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="lena"></a><span class="summary-sig-name">lena</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#lexsort" class="summary-sig-name">lexsort</a>(<span class="summary-sig-arg">keys</span>=<span class="summary-sig-default"></span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Argsort with list of keys.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#load" class="summary-sig-name">load</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Load a binary file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="loads"></a><span class="summary-sig-name">loads</span>(<span class="summary-sig-arg">string</span>)</span><br />
      Load a pickle from the given string</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#loadtxt" class="summary-sig-name">loadtxt</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Load ASCII data from fname into an array and return the array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="log1p"></a><span class="summary-sig-name">log1p</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = log1p(x) log(1+x) to base e elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#log2" class="summary-sig-name">log2</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Take log base 2 of x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="logical_and"></a><span class="summary-sig-name">logical_and</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = logical_and(x1,x2) returns x1 and x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="logical_not"></a><span class="summary-sig-name">logical_not</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = logical_not(x) returns not x elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="logical_or"></a><span class="summary-sig-name">logical_or</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = logical_or(x1,x2) returns x1 or x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="logical_xor"></a><span class="summary-sig-name">logical_xor</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = logical_xor(x1,x2) returns x1 xor x2 elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="longcomplex"></a><span class="summary-sig-name">longcomplex</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 96 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="longdouble"></a><span class="summary-sig-name">longdouble</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="longfloat"></a><span class="summary-sig-name">longfloat</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="longlong"></a><span class="summary-sig-name">longlong</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#lookfor" class="summary-sig-name">lookfor</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Search for objects whose documentation contains all given words.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#mat" class="summary-sig-name">mat</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns 'data' as a matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#matrix" class="summary-sig-name">matrix</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      mat = matrix(data, dtype=None, copy=True)

Returns a matrix from an array-like object, or a string of
data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="maximum"></a><span class="summary-sig-name">maximum</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = maximum(x1,x2) returns maximum (if x1 &gt; x2: x1;  else: x2) elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="maximum_sctype"></a><span class="summary-sig-name">maximum_sctype</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns the sctype of highest precision of the same general kind as 't'</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#may_share_memory" class="summary-sig-name">may_share_memory</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Determine if two arrays can share memory

The memory-bounds of a and b are computed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#median" class="summary-sig-name">median</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Compute the median along the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#memmap" class="summary-sig-name">memmap</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Create a memory-map to an array stored in a file on disk.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#meshgrid" class="summary-sig-name">meshgrid</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      For vectors x, y with lengths Nx=len(x) and Ny=len(y), return X, Y...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="minimum"></a><span class="summary-sig-name">minimum</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = minimum(x1,x2) returns minimum (if x1 &lt; x2: x1;  else: x2) elementwise</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#mintypecode" class="summary-sig-name">mintypecode</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a minimum data type character from typeset that
handles all typechars given

The returned type character must be the smallest size such that
an array of the returned type can handle the data from an array of
type t for each t in typechars (or if typechars is an array,
then its dtype.char).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#mirr" class="summary-sig-name">mirr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Modified internal rate of return

Parameters
----------
values:
    Cash flows (must contain at least one positive and one negative value)
    or nan is returned.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="mod"></a><span class="summary-sig-name">mod</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = remainder(x1,x2) computes x1-n*x2 where n is floor(x1 / x2)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#modf" class="summary-sig-name">modf</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y1,y2 = modf(x) breaks x into fractional (y1) and integral (y2) parts.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="msort"></a><span class="summary-sig-name">msort</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="multiply"></a><span class="summary-sig-name">multiply</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = multiply(x1,x2) multiplies the arguments elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#nan_to_num" class="summary-sig-name">nan_to_num</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns a copy of replacing NaN's with 0 and Infs with large numbers...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nanargmax"></a><span class="summary-sig-name">nanargmax</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Find the maximum over the given axis ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nanargmin"></a><span class="summary-sig-name">nanargmin</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Find the indices of the minimium over the given axis ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nanmax"></a><span class="summary-sig-name">nanmax</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Find the maximum over the given axis ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nanmin"></a><span class="summary-sig-name">nanmin</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Find the minimium over the given axis, ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nansum"></a><span class="summary-sig-name">nansum</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Sum the array over the given axis, treating NaNs as 0.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ndenumerate" class="summary-sig-name">ndenumerate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      A simple nd index iterator over an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ndim" class="summary-sig-name">ndim</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the number of dimensions of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ndindex" class="summary-sig-name">ndindex</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Pass in a sequence of integers corresponding
to the number of dimensions in the counter.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="newbuffer"></a><span class="summary-sig-name">newbuffer</span>(<span class="summary-sig-arg">size</span>)</span><br />
      Return a new uninitialized buffer object of size bytes</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#nper" class="summary-sig-name">nper</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Number of periods found by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Examples
--------

If you only had $150 to spend as payment, how long would it take to pay-off
  a loan of $8,000 at 7% annual interest?

&gt;&gt;&gt; nper(0.07/12, -150, 8000)
64.073348770661852

So, over 64 months would be required to pay off the loan.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#npv" class="summary-sig-name">npv</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Net Present Value...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="number"></a><span class="summary-sig-name">number</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="obj2sctype"></a><span class="summary-sig-name">obj2sctype</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="object0"></a><span class="summary-sig-name">object0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="object_"></a><span class="summary-sig-name">object_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#outer" class="summary-sig-name">outer</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Returns the outer product of two vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#packbits" class="summary-sig-name">packbits</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      out = numpy.packbits(myarray, axis=None)

myarray : an integer type array whose elements should be packed to bits

 This routine packs the elements of a binary-valued dataset into a
 NumPy array of type uint8 ('B') whose bits correspond to
 the logical (0 or nonzero) value of the input elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="pade"></a><span class="summary-sig-name">pade</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Given Taylor series coefficients in an, return a Pade approximation to
the function as the ratio of two polynomials p / q  where the order of q is m.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#piecewise" class="summary-sig-name">piecewise</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a piecewise-defined function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#place" class="summary-sig-name">place</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Similar to putmask arr[mask] = vals but the 1D array vals has the
same number of elements as the non-zero values of mask.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#pmt" class="summary-sig-name">pmt</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Payment computed by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Examples
--------

What would the monthly payment need to be to pay off a $200,000 loan in 15
  years at an annual interest rate of 7.5%?

&gt;&gt;&gt; pmt(0.075/12, 12*15, 200000)
-1854.0247200054619

In order to pay-off (i.e.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#poly" class="summary-sig-name">poly</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a sequence representing a polynomial given a sequence of roots.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#poly1d" class="summary-sig-name">poly1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      A one-dimensional polynomial class.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#polyadd" class="summary-sig-name">polyadd</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Adds two polynomials represented as sequences...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="polyder"></a><span class="summary-sig-name">polyder</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the mth derivative of the polynomial p.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="polydiv"></a><span class="summary-sig-name">polydiv</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Computes q and r polynomials so that u(s) = q(s)*v(s) + r(s)
and deg r &lt; deg v.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#polyfit" class="summary-sig-name">polyfit</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Least squares polynomial fit.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#polyint" class="summary-sig-name">polyint</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the mth analytical integral of the polynomial p.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="polymul"></a><span class="summary-sig-name">polymul</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Multiplies two polynomials represented as sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#polysub" class="summary-sig-name">polysub</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Subtracts two polynomials represented as sequences...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#polyval" class="summary-sig-name">polyval</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Evaluate the polynomial p at x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#power" class="summary-sig-name">power</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return x**p.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ppmt"></a><span class="summary-sig-name">ppmt</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#prod" class="summary-sig-name">prod</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the product of the array elements over the given axis

Parameters
----------
a : {array_like}
    Array containing elements whose product is desired.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#product" class="summary-sig-name">product</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the product of the array elements over the given axis

Parameters
----------
a : {array_like}
    Array containing elements whose product is desired.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ptp" class="summary-sig-name">ptp</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return (maximum - minimum) along the the given dimension
(i.e.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#put" class="summary-sig-name">put</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set a.flat[n] = v[n] for all n in ind.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#putmask" class="summary-sig-name">putmask</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">values</span>)</span><br />
      Sets a.flat[n] = values[n] for each n where mask.flat[n] is true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#pv" class="summary-sig-name">pv</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Number of periods found by solving the equation...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="radians"></a><span class="summary-sig-name">radians</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = radians(x) converts angle from degrees to radians</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#rank" class="summary-sig-name">rank</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the number of dimensions of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#rate" class="summary-sig-name">rate</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Number of periods found by solving the equation...</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ravel" class="summary-sig-name">ravel</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a 1d array containing the elements of a (copy only if needed).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#real" class="summary-sig-name">real</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the real part of val.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#real_if_close" class="summary-sig-name">real_if_close</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      If a is a complex array, return it as a real array if the imaginary
part is close enough to zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="reciprocal"></a><span class="summary-sig-name">reciprocal</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = reciprocal(x) compute 1/x</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="record"></a><span class="summary-sig-name">record</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      A data-type scalar that allows field access as attribute lookup.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="remainder"></a><span class="summary-sig-name">remainder</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = remainder(x1,x2) computes x1-n*x2 where n is floor(x1 / x2)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#repeat" class="summary-sig-name">repeat</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Repeat elements of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#require" class="summary-sig-name">require</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return an ndarray of the provided type that satisfies requirements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#resize" class="summary-sig-name">resize</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a new array with the specified shape.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="restoredot"></a><span class="summary-sig-name">restoredot</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      restoredot() restores dots to defaults.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="right_shift"></a><span class="summary-sig-name">right_shift</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = right_shift(x1,x2) computes x1 &gt;&gt; x2 (x1 shifted to right by x2 bits) elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#roll" class="summary-sig-name">roll</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Roll the elements in the array by 'shift' positions along
the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#rollaxis" class="summary-sig-name">rollaxis</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return transposed array so that axis is rolled before start.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#roots" class="summary-sig-name">roots</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the roots of the polynomial coefficients in p.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#rot90" class="summary-sig-name">rot90</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns the array found by rotating m by k*90
degrees in the counterclockwise direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#round_" class="summary-sig-name">round_</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Round a to the given number of decimals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#row_stack" class="summary-sig-name">row_stack</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Stack arrays in sequence vertically (row wise)

Description:
    Take a sequence of arrays and stack them vertically
    to make a single array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#safe_eval" class="summary-sig-name">safe_eval</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#save" class="summary-sig-name">save</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Save an array to a binary file (a string or file-like object).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#savetxt" class="summary-sig-name">savetxt</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Save the data in X to file fname using fmt string to convert the
data to strings

Parameters
----------
fname : filename or a file handle
    If the filename ends in .gz, the file is automatically saved in
    compressed gzip format.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#savez" class="summary-sig-name">savez</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Save several arrays into an .npz file format which is a zipped-archive
of arrays

If keyword arguments are given, then filenames are taken from the keywords.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="sctype2char"></a><span class="summary-sig-name">sctype2char</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#searchsorted" class="summary-sig-name">searchsorted</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return indices where keys in v should be inserted to maintain order.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#select" class="summary-sig-name">select</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return an array composed of different elements in choicelist,
depending on the list of conditions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#set_numeric_ops" class="summary-sig-name">set_numeric_ops</a>(<span class="summary-sig-arg">op</span>=<span class="summary-sig-default">func</span>,
        <span class="summary-sig-arg">...</span>)</span><br />
      Set some or all of the number methods for all array objects.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#set_printoptions" class="summary-sig-name">set_printoptions</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set options associated with printing.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#set_string_function" class="summary-sig-name">set_string_function</a>(<span class="summary-sig-arg">f</span>,
        <span class="summary-sig-arg">repr</span>=<span class="summary-sig-default">1</span>)</span><br />
      Set the python function f to be the function used to obtain a pretty
printable string version of an array whenever an array is printed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="setbufsize"></a><span class="summary-sig-name">setbufsize</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set the size of the buffer used in ufuncs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#setdiff1d" class="summary-sig-name">setdiff1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set difference of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#seterr" class="summary-sig-name">seterr</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set how floating-point errors are handled.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#seterrcall" class="summary-sig-name">seterrcall</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set the callback function used when a floating-point error handler
is set to 'call' or the object with a write method for use when
the floating-point error handler is set to 'log'

'func' should be a function that takes two arguments.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#seterrobj" class="summary-sig-name">seterrobj</a>()</span><br />
      Used internally by `seterr`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#setmember1d" class="summary-sig-name">setmember1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a boolean array of shape of ar1 containing True where the elements
of ar1 are in ar2 and False otherwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#setxor1d" class="summary-sig-name">setxor1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Set exclusive-or of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#shape" class="summary-sig-name">shape</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the shape of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="short"></a><span class="summary-sig-name">short</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="show_config"></a><span class="summary-sig-name">show_config</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="sign"></a><span class="summary-sig-name">sign</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = sign(x) returns -1 if x &lt; 0 and 0 if x==0 and 1 if x &gt; 0</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="signbit"></a><span class="summary-sig-name">signbit</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = signbit(x) returns True where signbit of x is set (x&lt;0).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="signedinteger"></a><span class="summary-sig-name">signedinteger</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="sinc"></a><span class="summary-sig-name">sinc</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      sinc(x) returns sin(pi*x)/(pi*x) at all points of array x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="single"></a><span class="summary-sig-name">single</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="singlecomplex"></a><span class="summary-sig-name">singlecomplex</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Composed of two 32 bit floats</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#size" class="summary-sig-name">size</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the number of elements along given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#sometrue" class="summary-sig-name">sometrue</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Assert whether some values are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#sort" class="summary-sig-name">sort</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return copy of 'a' sorted along the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#sort_complex" class="summary-sig-name">sort_complex</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Sort 'a' as a complex array using the real part first and then
the imaginary part if the real part is equal (the default sort order
for complex arrays).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="source"></a><span class="summary-sig-name">source</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Write source for this object to output.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#split" class="summary-sig-name">split</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Divide an array into a list of sub-arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="square"></a><span class="summary-sig-name">square</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = square(x) compute x**2.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#squeeze" class="summary-sig-name">squeeze</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Remove single-dimensional entries from the shape of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="str_"></a><span class="summary-sig-name">str_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="string0"></a><span class="summary-sig-name">string0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="string_"></a><span class="summary-sig-name">string_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#swapaxes" class="summary-sig-name">swapaxes</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return a view of array a with axis1 and axis2 interchanged.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#take" class="summary-sig-name">take</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return an array formed from the elements of a at the given indices.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#tensordot" class="summary-sig-name">tensordot</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      tensordot returns the product for any (ndim &gt;= 1) arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#tile" class="summary-sig-name">tile</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Repeat an array the number of times given in the integer tuple, reps.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#trace" class="summary-sig-name">trace</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return the sum along diagonals of the array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#trapz" class="summary-sig-name">trapz</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Integrate y(x) using samples along the given axis and the composite
trapezoidal rule.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#tril" class="summary-sig-name">tril</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns the elements on and below the k-th diagonal of m.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#trim_zeros" class="summary-sig-name">trim_zeros</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Trim the leading and trailing zeros from a 1D array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#triu" class="summary-sig-name">triu</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      returns the elements on and above the k-th diagonal of m.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="true_divide"></a><span class="summary-sig-name">true_divide</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      y = true_divide(x1,x2) true divides the arguments elementwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="typename"></a><span class="summary-sig-name">typename</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return an english description for the given data type character.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ubyte"></a><span class="summary-sig-name">ubyte</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#ufunc" class="summary-sig-name">ufunc</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Functions that operate element by element on whole arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint"></a><span class="summary-sig-name">uint</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint0"></a><span class="summary-sig-name">uint0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint16"></a><span class="summary-sig-name">uint16</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint32"></a><span class="summary-sig-name">uint32</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint64"></a><span class="summary-sig-name">uint64</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uint8"></a><span class="summary-sig-name">uint8</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uintc"></a><span class="summary-sig-name">uintc</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="uintp"></a><span class="summary-sig-name">uintp</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ulonglong"></a><span class="summary-sig-name">ulonglong</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unicode0"></a><span class="summary-sig-name">unicode0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unicode_"></a><span class="summary-sig-name">unicode_</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#union1d" class="summary-sig-name">union1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Union of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#unique" class="summary-sig-name">unique</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Return sorted unique items from an array or sequence.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#unique1d" class="summary-sig-name">unique1d</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Find the unique elements of 1D array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unpackbits"></a><span class="summary-sig-name">unpackbits</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      out = numpy.unpackbits(myarray, axis=None)

myarray - array of uint8 type where each element represents a bit-field
   that should be unpacked into a boolean output array

   The shape of the output array is either 1-d (if axis is None) or
   the same shape as the input array with unpacking done along the
   axis specified.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#unravel_index" class="summary-sig-name">unravel_index</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Convert a flat index into an index tuple for an array of given shape.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unsignedinteger"></a><span class="summary-sig-name">unsignedinteger</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unwrap"></a><span class="summary-sig-name">unwrap</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Unwrap radian phase p by changing absolute jumps greater than
'discont' to their 2*pi complement along the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="ushort"></a><span class="summary-sig-name">ushort</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#vander" class="summary-sig-name">vander</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Generate the Vandermonde matrix of vector x.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#vdot" class="summary-sig-name">vdot</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Returns the dot product of a and b for scalars and vectors
of floating point and complex types.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#vectorize" class="summary-sig-name">vectorize</a>(<span class="summary-sig-arg">somefunction</span>,
        <span class="summary-sig-arg">otypes</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">doc</span>=<span class="summary-sig-default">None</span>)</span><br />
      Generalized function class.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="void"></a><span class="summary-sig-name">void</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="void0"></a><span class="summary-sig-name">void0</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#vsplit" class="summary-sig-name">vsplit</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Split ary into multiple rows of sub-arrays

Description:
    Split a single array into multiple sub arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#vstack" class="summary-sig-name">vstack</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Stack arrays in sequence vertically (row wise)

Description:
    Take a sequence of arrays and stack them vertically
    to make a single array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="brian.numpywrappers-module.html#where" class="summary-sig-name">where</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      where(condition, x, y) or where(condition)

Return elements from `x` or `y`, depending on `condition`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="who"></a><span class="summary-sig-name">who</span>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Print the Numpy arrays in the given dictionary (or globals() if None).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="DataSource"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">DataSource</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
A generic data source file (file, http, ftp, ...).

DataSources could be local files or remote files/URLs.  The files may
also be compressed or uncompressed.  DataSource hides some of the low-level
details of downloading the file, allowing you to simply pass in a valid
file path (or URL) and obtain a file object.

*Methods*:

    - exists : test if the file exists locally or remotely
    - abspath : get absolute path of the file in the DataSource directory
    - open : open the file

*Example URL DataSource*::

    # Initialize DataSource with a local directory, default is os.curdir.
    ds = DataSource('/home/guido')

    # Open remote file.
    # File will be downloaded and opened from here:
    #     /home/guido/site/xyz.txt
    ds.open('http://fake.xyz.web/site/xyz.txt')

*Example using DataSource for temporary files*::

    # Initialize DataSource with 'None' for the local directory.
    ds = DataSource(None)

    # Open local file.
    # Opened file exists in a temporary directory like:
    #     /tmp/tmpUnhcvM/foobar.txt
    # Temporary directories are deleted when the DataSource is deleted.
    ds.open('/home/guido/foobar.txt')

*Notes*:
    BUG : URLs require a scheme string ('http://') to be used.
          www.google.com will fail.

          &gt;&gt;&gt; repos.exists('www.google.com/index.html')
          False

          &gt;&gt;&gt; repos.exists('http://www.google.com/index.html')
          True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="MachAr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">MachAr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Diagnosing machine parameters.

The following attributes are available:

ibeta  - radix in which numbers are represented
it     - number of base-ibeta digits in the floating point mantissa M
machep - exponent of the smallest (most negative) power of ibeta that,
         added to 1.0,
         gives something different from 1.0
eps    - floating-point number beta**machep (floating point precision)
negep  - exponent of the smallest power of ibeta that, substracted
         from 1.0, gives something different from 1.0
epsneg - floating-point number beta**negep
iexp   - number of bits in the exponent (including its sign and bias)
minexp - smallest (most negative) power of ibeta consistent with there
         being no leading zeros in the mantissa
xmin   - floating point number beta**minexp (the smallest (in
         magnitude) usable floating value)
maxexp - smallest (positive) power of ibeta that causes overflow
xmax   - (1-epsneg)* beta**maxexp (the largest (in magnitude)
         usable floating value)
irnd   - in range(6), information on what kind of rounding is done
         in addition, and on how underflow is handled
ngrd   - number of 'guard digits' used when truncating the product
         of two mantissas to fit the representation

epsilon - same as eps
tiny    - same as xmin
huge    - same as xmax
precision   - int(-log10(eps))
resolution  - 10**(-precision)

Reference:
  Numerical Recipies.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="NumpyTest"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">NumpyTest</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Numpy tests site manager.

Usage: NumpyTest(&lt;package&gt;).test(level=1,verbosity=1)

&lt;package&gt; is package name or its module object.

Package is supposed to contain a directory tests/ with test_*.py
files where * refers to the names of submodules.  See .rename()
method to redefine name mapping between test_*.py files and names of
submodules. Pattern test_*.py can be overwritten by redefining
.get_testfile() method.

test_*.py files are supposed to define a classes, derived from
NumpyTestCase or unittest.TestCase, with methods having names
starting with test or bench or check. The names of TestCase classes
must have a prefix test. This can be overwritten by redefining
.check_testcase_name() method.

And that is it! No need to implement test or test_suite functions
in each .py file.

Old-style test_suite(level=1) hooks are also supported.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_docstring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_docstring</span>(<span class="sig-arg">obj</span>,
        <span class="sig-arg">docstring</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Add a docstring to a built-in obj if possible.
If the obj already has a docstring raise a RuntimeError
If this routine does not know how to add a docstring to the object
raise a TypeError

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_newdoc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_newdoc</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Adds documentation to obj which is in module place.

If doc is a string add it to obj as a docstring

If doc is a tuple, then the first element is interpreted as
   an attribute of obj and the second as the docstring
      (method, docstring)

If doc is a list, then each element of the list should be a
   sequence of length two --&gt; [(method1, docstring1),
   (method2, docstring2), ...]

This routine never raises an error.
   

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="alen"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">alen</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Return the length of a Python object interpreted as an array
of at least 1 dimension.

Parameters
----------
a : array_like

Returns
-------
alen : int
   Length of the first dimension of `a`.

Examples
--------
&gt;&gt;&gt; z = numpy.zeros((7,4,5))
&gt;&gt;&gt; z.shape[0]
7
&gt;&gt;&gt; numpy.alen(z)
7

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Check if all of the elements of `a` are true.

Performs a logical_and over the given axis and returns the result

Parameters
----------
a : array_like
axis : {None, integer}
    Axis to perform the operation over.
    If None, perform over flattened array and return a scalar.
out : {None, array}, optional
    Array into which the product can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

See Also
--------
ndarray.all : equivalent method

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="allclose"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">allclose</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns True if all components of a and b are equal subject to given
tolerances.

The relative error rtol must be positive and &lt;&lt; 1.0
The absolute error atol usually comes into play for those elements of b that
are very small or zero; it says how small a must be also.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="alltrue"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">alltrue</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Check if all of the elements of `a` are true.

Performs a logical_and over the given axis and returns the result

Parameters
----------
a : array_like
axis : {None, integer}
    Axis to perform the operation over.
    If None, perform over flattened array.
out : {None, array}, optional
    Array into which the product can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

See Also
--------
ndarray.all : equivalent method

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="amax"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">amax</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the maximum along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.

Returns
-------
amax : array_like
    New array holding the result, unless ``out`` was specified.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amax(x,0)
array([2, 3])
&gt;&gt;&gt; np.amax(x,1)
array([1, 3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="amin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">amin</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the minimum along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.

Returns
-------
amin : array_like
    New array holding the result, unless ``out`` was specified.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amin(x,0)
array([0, 1])
&gt;&gt;&gt; np.amin(x,1)
array([0, 2])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="angle"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">angle</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Return the angle of the complex argument z.

Examples
--------
&gt;&gt;&gt; numpy.angle(1+1j)          # in radians
0.78539816339744828
&gt;&gt;&gt; numpy.angle(1+1j,deg=True) # in degrees
45.0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="any"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">any</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Check if any of the elements of `a` are true.

Performs a logical_or over the given axis and returns the result

Parameters
----------
a : array_like
axis : {None, integer}
    Axis to perform the operation over.
    If None, perform over flattened array and return a scalar.
out : {None, array}, optional
    Array into which the product can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

See Also
--------
ndarray.any : equivalent method

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="append"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">append</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Append to the end of an array along axis (ravel first if None)
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="apply_along_axis"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">apply_along_axis</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Execute func1d(arr[i],*args) where func1d takes 1-D arrays
and arr is an N-d array.  i varies so as to apply the function
along the given axis for each 1-d subarray in arr.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="apply_over_axes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">apply_over_axes</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Apply a function repeatedly over multiple axes, keeping the same shape
for the resulting array.

func is called as res = func(a, axis).  The result is assumed
to be either the same shape as a or have one less dimension.
This call is repeated for each axis in the axes sequence.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="argwhere"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">argwhere</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a 2-d array of shape N x a.ndim where each row
is a sequence of indices into a.  This sequence must be
converted to a tuple in order to be used to index into a.

&gt;&gt;&gt; from numpy import ones, argwhere
&gt;&gt;&gt; argwhere(ones((2, 2)))
array([[0, 0],
       [0, 1],
       [1, 0],
       [1, 1]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="around"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">around</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Round a to the given number of decimals.

The real and imaginary parts of complex numbers are rounded separately. The
result of rounding a float is a float so the type must be cast if integers
are desired.  Nothing is done if the input is an integer array and the
decimals parameter has a value &gt;= 0.

Parameters
----------
a : {array_like}
    Array containing numbers whose rounded values are desired. If a is
    not an array, a conversion is attempted.
decimals : {0, int}, optional
    Number of decimal places to round to. When decimals is negative it
    specifies the number of positions to the left of the decimal point.
out : {None, array}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary. Numpy rounds floats to floats by default.

Returns
-------
rounded_array : {array}
    If out=None, returns a new array of the same type as a containing
    the rounded values, otherwise a reference to the output array is
    returned.

See Also
--------
round_ : equivalent function
ndarray.round : equivalent method

Notes
-----
Numpy rounds to even. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round
to 0.0, etc. Results may also be surprising due to the inexact
representation of decimal fractions in IEEE floating point and the
errors introduced when scaling by powers of ten.

Examples
--------
&gt;&gt;&gt; around([.5, 1.5, 2.5, 3.5, 4.5])
array([ 0.,  2.,  2.,  4.,  4.])
&gt;&gt;&gt; around([1,2,3,11], decimals=1)
array([ 1,  2,  3, 11])
&gt;&gt;&gt; around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asmatrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asmatrix</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns 'data' as a matrix.  Unlike matrix(), no copy is performed
if 'data' is already a matrix or array.  Equivalent to:
matrix(data, copy=False)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Force a sequence of arrays to each be at least 1D.

Description:
   Force an array to be at least 1D.  If an array is 0D, the
   array is converted to a single row of values.  Otherwise,
   the array is unaltered.
Arguments:
   *arys -- arrays to be converted to 1 or more dimensional array.
Returns:
   input array converted to at least 1D array.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_2d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_2d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Force a sequence of arrays to each be at least 2D.

Description:
   Force an array to each be at least 2D.  If the array
   is 0D or 1D, the array is converted to a single
   row of values.  Otherwise, the array is unaltered.
Arguments:
   arys -- arrays to be converted to 2 or more dimensional array.
Returns:
   input array converted to at least 2D array.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_3d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_3d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Force a sequence of arrays to each be at least 3D.

Description:
   Force an array each be at least 3D.  If the array is 0D or 1D,
   the array is converted to a single 1xNx1 array of values where
   N is the orginal length of the array. If the array is 2D, the
   array is converted to a single MxNx1 array of values where MxN
   is the orginal shape of the array. Otherwise, the array is
   unaltered.
Arguments:
   arys -- arrays to be converted to 3 or more dimensional array.
Returns:
   input array converted to at least 3D array.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="average"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">average</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the weighted average of array a over the given axis.


Parameters
----------
a : array_like
    Data to be averaged.
axis : {None, integer}, optional
    Axis along which to average a. If None, averaging is done over the
    entire array irrespective of its shape.
weights : {None, array_like}, optional
    The importance each datum has in the computation of the
    average. The weights array can either be 1D, in which case  its length
    must be the size of a along the given axis, or of the same shape as a.
    If weights=None, all data are assumed to have weight equal to one.
returned :{False, boolean}, optional
    If True, the tuple (average, sum_of_weights) is returned,
    otherwise only the average is returmed. Note that if weights=None, then
    the sum of the weights is also the number of elements averaged over.

Returns
-------
average, [sum_of_weights] : {array_type, double}
    Return the average along the specified axis. When returned is True,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is Float if a is
    of integer type, otherwise it is of the same type as a.
    sum_of_weights is has the same type as the average.


Examples
--------
  &gt;&gt;&gt; average(range(1,11), weights=range(10,0,-1))
  4.0

Raises
------
ZeroDivisionError
    When all weights along axis are zero. See numpy.ma.average for a
    version robust to this type of error.
TypeError
    When the length of 1D weights is not the same as the shape of a
    along axis.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bartlett"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bartlett</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Return the Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The triangular window, normalized to one (the value one
    appears only if the number of samples is odd), with the first
    and last samples equal to zero.

See Also
--------
blackman, hamming, hanning, kaiser

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \frac{2}{M-1} \left(
          \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
          \right)

Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means&quot;removing the foot&quot;, i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function.

References
----------
.. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,
       Biometrika 37, 1-16, 1950.
.. [2] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal
       Processing&quot;, Prentice-Hall, 1999, pp. 468-471.
.. [3] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.

Examples
--------
&gt;&gt;&gt; from numpy import bartlett
&gt;&gt;&gt; bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])

Plot the window and its frequency response:

&gt;&gt;&gt; from numpy import clip, log10, array, bartlett
&gt;&gt;&gt; from scipy.fftpack import fft
&gt;&gt;&gt; from matplotlib import pyplot as plt

&gt;&gt;&gt; window = bartlett(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*log10(mag)
&gt;&gt;&gt; response = clip(response,-100,100)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="base_repr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">base_repr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the representation of a number in the given base.

Base can't be larger than 36.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="binary_repr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">binary_repr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the binary representation of the input number as a string.

This is equivalent to using base_repr with base 2, but about 25x
faster.

For negative numbers, if width is not given, a - sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bincount"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bincount</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the number of occurrences of each value in x.

x must be a list of non-negative integers.  The output, b[i],
represents the number of times that i is found in x.  If weights
is specified, every occurrence of i at a position p contributes
weights[p] instead of 1.

See also: histogram, digitize, unique.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bmat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bmat</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Build a matrix object from string, nested sequence, or array.

Examples
--------
&gt;&gt;&gt; F = bmat('A, B; C, D')
&gt;&gt;&gt; F = bmat([[A,B],[C,D]])
&gt;&gt;&gt; F = bmat(r_[c_[A,B],c_[C,D]])

All of these produce the same matrix::

    [ A  B ]
    [ C  D ]

if A, B, C, and D are appropriately shaped 2-d arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="byte_bounds"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">byte_bounds</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
(low, high) are pointers to the end-points of an array

low is the first byte
high is just *past* the last byte

If the array is not single-segment, then it may not actually
use every byte between these bounds.

The array provided must conform to the Python-side of the array interface

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="central_diff_weights"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">central_diff_weights</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return weights for an Np-point central derivative of order ndiv
assuming equally-spaced function points.

If weights are in the vector w, then
derivative is w[0] * f(x-ho*dx) + ... + w[-1] * f(x+h0*dx)

Can be inaccurate for large number of points.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="choose"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">choose</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Use an index array to construct a new array from a set of
choices.

Given an array of integers and a set of n choice arrays, this function
will create a new array that merges each of the choice arrays.  Where a
value in `a` is i, then the new array will have the value that
choices[i] contains in the same place.

Parameters
----------
a : int array
    This array must contain integers in [0, n-1], where n is the number
    of choices.
choices : sequence of arrays
    Choice arrays. The index array and all of the choices should be
    broadcastable to the same shape.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' : raise an error
    'wrap' : wrap around
    'clip' : clip to the range

Returns
-------
merged_array : array

See Also
--------
ndarray.choose : equivalent method

Examples
--------

&gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],
...   [20, 21, 22, 23], [30, 31, 32, 33]]
&gt;&gt;&gt; choose([2, 3, 1, 0], choices)
array([20, 31, 12,  3])
&gt;&gt;&gt; choose([2, 4, 1, 0], choices, mode='clip')
array([20, 31, 12,  3])
&gt;&gt;&gt; choose([2, 4, 1, 0], choices, mode='wrap')
array([20,  1, 12,  3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="clip"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">clip</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return an array whose values are limited to [a_min, a_max].

Parameters
----------
a : {array_like}
    Array containing elements to clip.
a_min :
    Minimum value
a_max :
    Maximum value
out : array, optional
    The results will be placed in this array. It may be the input array for
    inplace clipping.

Returns
-------
clipped_array : {array}
    A new array whose elements are same as for a, but values
    &lt; a_min are replaced with a_min, and &gt; a_max with a_max.

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
&gt;&gt;&gt; a
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="column_stack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">column_stack</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Stack 1D arrays as columns into a 2D array

Description:
    Take a sequence of 1D arrays and stack them as columns
    to make a single 2D array.  All arrays in the sequence
    must have the same first dimension.  2D arrays are
    stacked as-is, just like with hstack.  1D arrays are turned
    into 2D columns first.

Arguments:
    tup -- sequence of 1D or 2D arrays.  All arrays must have the same
           first dimension.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a = array((1,2,3))
    &gt;&gt;&gt; b = array((2,3,4))
    &gt;&gt;&gt; numpy.column_stack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="comb"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">comb</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Combinations of N things taken k at a time.

If exact==0, then floating point precision is used, otherwise
exact long integer is computed.

Notes:
  - Array arguments accepted only for exact=0 case.
  - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="common_type"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">common_type</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Given a sequence of arrays as arguments, return the best inexact
scalar type which is &quot;most&quot; common amongst them.

The return type will always be a inexact scalar type, even if all
the arrays are integer arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="compress"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">compress</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return selected slices of an array along given axis.

Parameters
----------
condition : {array}
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
a : {array_type}
    Array from which to extract a part.
axis : {None, integer}
    Axis along which to take slices. If None, work on the flattened array.
out : array, optional
    Output array.  Its type is preserved and it must be of the right
    shape to hold the output.

Returns
-------
compressed_array : array
    A copy of a, without the slices along axis for which condition is false.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.compress([0, 1], a, axis=0)
array([[3, 4]])
&gt;&gt;&gt; np.compress([1], a, axis=1)
array([[1],
       [3]])
&gt;&gt;&gt; np.compress([0,1,1], a)
array([2, 3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="concatenate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">concatenate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
concatenate((a1, a2, ...), axis=0)

Join arrays together.

The tuple of sequences (a1, a2, ...) are joined along the given axis
(default is the first one) into a single numpy array.

Examples
--------
&gt;&gt;&gt; concatenate( ([0,1,2], [5,6,7]) )
array([0, 1, 2, 5, 6, 7])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="corrcoef"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">corrcoef</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
The correlation coefficients
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="correlate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">correlate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the discrete, linear correlation of 1-D sequences a and v; mode
can be 'valid', 'same', or 'full' to specify the size of the resulting
sequence

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cov"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cov</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Estimate the covariance matrix.

If m is a vector, return the variance.  For matrices return the
covariance matrix.

If y is given it is treated as an additional (set of)
variable(s).

Normalization is by (N-1) where N is the number of observations
(unbiased estimate).  If bias is 1 then normalization is by N.

If rowvar is non-zero (default), then each row is a variable with
observations in the columns, otherwise each column
is a variable and the observations are in the rows.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cross"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cross</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the cross product of two (arrays of) vectors.

The cross product is performed over the last axis of a and b by default,
and can handle axes with dimensions 2 and 3. For a dimension of 2,
the z-component of the equivalent three-dimensional cross product is
returned.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cumprod"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cumprod</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Return the cumulative product of the elements along the given axis.

The cumulative product is taken over the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array-like
    Input array or object that can be converted to an array.
axis : {None, -1, int}, optional
    Axis along which the product is computed. The default
    (`axis` = `None`) is to compute over the flattened array.
dtype : {None, dtype}, optional
    Type of the returned array and of the accumulator
    where the elements are multiplied. If `dtype` has the value `None` and
    the type of `a` is an integer type of precision less than the default
    platform integer, then the default platform integer precision is
    used.  Otherwise, the `dtype` is the same as that of `a`.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.

Returns
-------
cumprod : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to out is returned.

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
&gt;&gt;&gt; a=numpy.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; a=numpy.array([1,2,3])
&gt;&gt;&gt; numpy.cumprod(a) # intermediate results 1, 1*2
...                  # total product 1*2*3 = 6
array([1, 2, 6])
&gt;&gt;&gt; a=numpy.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; numpy.cumprod(a,dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])
&gt;&gt;&gt; numpy.cumprod(a,axis=0) # for each of the 3 columns:
...                         # product and intermediate results
array([[ 1,  2,  3],
       [ 4, 10, 18]])
&gt;&gt;&gt; numpy.cumprod(a,axis=1) # for each of the two rows:
...                         # product and intermediate results
array([[  1,   2,   6],
       [  4,  20, 120]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cumproduct"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cumproduct</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the cumulative product over the given axis.

See Also
--------
cumprod

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="delete"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">delete</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a new array with sub-arrays along an axis deleted.

Return a new array with the sub-arrays (i.e. rows or columns)
deleted along the given axis as specified by obj

obj may be a slice_object (s_[3:5:2]) or an integer
or an array of integers indicated which sub-arrays to
remove.

If axis is None, then ravel the array first.

Examples
--------
&gt;&gt;&gt; arr = [[3,4,5],
...       [1,2,3],
...       [6,7,8]]

&gt;&gt;&gt; delete(arr, 1, 1)
array([[3, 5],
       [1, 3],
       [6, 8]])
&gt;&gt;&gt; delete(arr, 1, 0)
array([[3, 4, 5],
       [6, 7, 8]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="deprecate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">deprecate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Deprecate old functions.
Issues a DeprecationWarning, adds warning to oldname's docstring,
rebinds oldname.__name__ and returns new function object.

Example:
oldfunc = deprecate(newfunc, 'oldfunc', 'newfunc')

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="deprecate_with_doc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">deprecate_with_doc</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Decorator to deprecate functions and provide detailed documentation
with 'somestr' that is added to the functions docstring.

Example:
depmsg = 'function scipy.foo has been merged into numpy.foobar'
@deprecate_with_doc(depmsg)
def foo():
    pass

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="derivative"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">derivative</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Given a function, use a central difference formula with spacing dx to
compute the nth derivative at x0.

order is the number of points to use and must be odd.

Warning: Decreasing the step size too small can result in
round-off error.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diagflat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diagflat</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a 2D array whose k'th diagonal is a flattened v and all other
elements are zero.

Examples
--------
  &gt;&gt;&gt; diagflat([[1,2],[3,4]]])
  array([[1, 0, 0, 0],
         [0, 2, 0, 0],
         [0, 0, 3, 0],
         [0, 0, 0, 4]])

  &gt;&gt;&gt; diagflat([1,2], 1)
  array([[0, 1, 0],
         [0, 0, 2],
         [0, 0, 0]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diagonal"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diagonal</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return specified diagonals.

If a is 2-d, returns the diagonal of self with the given offset, i.e., the
collection of elements of the form a[i,i+offset]. If a has more than two
dimensions, then the axes specified by axis1 and axis2 are used to determine
the 2-d subarray whose diagonal is returned. The shape of the resulting
array can be determined by removing axis1 and axis2 and appending an index
to the right equal to the size of the resulting diagonals.

Parameters
----------
a : {array_like}
    Array from whis the diagonals are taken.
offset : {0, integer}, optional
    Offset of the diagonal from the main diagonal. Can be both positive
    and negative. Defaults to main diagonal.
axis1 : {0, integer}, optional
    Axis to be used as the first axis of the 2-d subarrays from which
    the diagonals should be taken. Defaults to first axis.
axis2 : {1, integer}, optional
    Axis to be used as the second axis of the 2-d subarrays from which
    the diagonals should be taken. Defaults to second axis.

Returns
-------
array_of_diagonals : array of same type as a
    If a is 2-d, a 1-d array containing the diagonal is
    returned.  If a has larger dimensions, then an array of
    diagonals is returned.

See Also
--------
diag : Matlab workalike for 1-d and 2-d arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; a = arange(4).reshape(2,2)
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; a.diagonal()
array([0, 3])
&gt;&gt;&gt; a.diagonal(1)
array([1])

&gt;&gt;&gt; a = arange(8).reshape(2,2,2)
&gt;&gt;&gt; a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
&gt;&gt;&gt; a.diagonal(0,-2,-1)
array([[0, 3],
       [4, 7]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="digitize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">digitize</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">bins</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the index of the bin to which each value of x belongs.

Each index i returned is such that bins[i-1] &lt;= x &lt; bins[i] if
bins is monotonically increasing, or bins [i-1] &gt; x &gt;= bins[i] if
bins is monotonically decreasing.

Beyond the bounds of the bins 0 or len(bins) is returned as appropriate.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dsplit</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Split ary into multiple sub-arrays along the 3rd axis (depth)

Description:
    Split a single array into multiple sub arrays.  The array is
    divided into groups along the 3rd axis.  If indices_or_sections is
    an integer, ary is divided into that many equally sized sub arrays.
    If it is impossible to make the sub-arrays equally sized, the
    operation throws a ValueError exception. See array_split and
    split for other options on indices_or_sections.
Arguments:
   ary -- N-D array.
      Array to be divided into sub-arrays.
   indices_or_sections -- integer or 1D array.
      If integer, defines the number of (close to) equal sized
      sub-arrays.  If it is a 1D array of sorted indices, it
      defines the indexes at which ary is divided.  Any empty
      list results in a single sub-array equal to the original
      array.
Returns:
    sequence of sub-arrays.  The returned arrays have the same
    number of dimensions as the input array.
Caveats:
   See vsplit caveats.
Related:
    dstack, split, array_split, hsplit, vsplit.
Examples:
    &gt;&gt;&gt; a = array([[[1,2,3,4],[1,2,3,4]]])
    &gt;&gt;&gt; dsplit(a,2)
    [array([[[1, 2],
            [1, 2]]]), array([[[3, 4],
            [3, 4]]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dstack</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Stack arrays in sequence depth wise (along third dimension)

Description:
    Take a sequence of arrays and stack them along the third axis.
    All arrays in the sequence must have the same shape along all
    but the third axis.  This is a simple way to stack 2D arrays
    (images) into a single 3D array for processing.
    dstack will rebuild arrays divided by dsplit.
Arguments:
    tup -- sequence of arrays.  All arrays must have the same
           shape.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a = array((1,2,3))
    &gt;&gt;&gt; b = array((2,3,4))
    &gt;&gt;&gt; numpy.dstack((a,b))
    array([[[1, 2],
            [2, 3],
            [3, 4]]])
    &gt;&gt;&gt; a = array([[1],[2],[3]])
    &gt;&gt;&gt; b = array([[2],[3],[4]])
    &gt;&gt;&gt; numpy.dstack((a,b))
    array([[[1, 2]],
    &lt;BLANKLINE&gt;
           [[2, 3]],
    &lt;BLANKLINE&gt;
           [[3, 4]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dtype"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dtype</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Create a data type.

A numpy array is homogeneous, and contains elements described by a
dtype.  A dtype can be constructed from different combinations of
fundamental numeric types, as illustrated below.

Examples
--------

Using array-scalar type:
&gt;&gt;&gt; dtype(int16)
dtype('int16')

Record, one field name 'f1', containing int16:
&gt;&gt;&gt; dtype([('f1', int16)])
dtype([('f1', '&lt;i2')])

Record, one field named 'f1', in itself containing a record with one field:
&gt;&gt;&gt; dtype([('f1', [('f1', int16)])])
dtype([('f1', [('f1', '&lt;i2')])])

Record, two fields: the first field contains an unsigned int, the
second an int32:
&gt;&gt;&gt; dtype([('f1', uint), ('f2', int32)])
dtype([('f1', '&lt;u4'), ('f2', '&lt;i4')])

Using array-protocol type strings:
&gt;&gt;&gt; dtype([('a','f8'),('b','S10')])
dtype([('a', '&lt;f8'), ('b', '|S10')])

Using comma-separated field formats.  The shape is (2,3):
&gt;&gt;&gt; dtype(&quot;i4, (2,3)f8&quot;)
dtype([('f0', '&lt;i4'), ('f1', '&lt;f8', (2, 3))])

Using tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``
is a flexible type, here of size 10:
&gt;&gt;&gt; dtype([('hello',(int,3)),('world',void,10)])
dtype([('hello', '&lt;i4', 3), ('world', '|V10')])

Subdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are
the offsets in bytes:
&gt;&gt;&gt; dtype((int16, {'x':(int8,0), 'y':(int8,1)}))
dtype(('&lt;i2', [('x', '|i1'), ('y', '|i1')]))

Using dictionaries.  Two fields named 'gender' and 'age':
&gt;&gt;&gt; dtype({'names':['gender','age'], 'formats':['S1',uint8]})
dtype([('gender', '|S1'), ('age', '|u1')])

Offsets in bytes, here 0 and 25:
&gt;&gt;&gt; dtype({'surname':('S25',0),'age':(uint8,25)})
dtype([('surname', '|S25'), ('age', '|u1')])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ediff1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ediff1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
The differences between consecutive elements of an array, possibly with
prefixed and/or appended values.

Parameters
----------
ary : array
    This array will be flattened before the difference is taken.
to_end : number, optional
    If provided, this number will be tacked onto the end of the returned
    differences.
to_begin : number, optional
    If provided, this number will be taked onto the beginning of the
    returned differences.

Returns
-------
ed : array
    The differences. Loosely, this will be (ary[1:] - ary[:-1]).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="errstate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">errstate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
with errstate(**state): --&gt; operations in following block use given state.

# Set error handling to known state.
&gt;&gt;&gt; _ = seterr(invalid='raise', divide='raise', over='raise', under='ignore')

|&gt;&gt; a = -arange(3)
|&gt;&gt; with errstate(invalid='ignore'):
...     print sqrt(a)
[ 0.     -1.#IND -1.#IND]
|&gt;&gt; print sqrt(a.astype(complex))
[ 0. +0.00000000e+00j  0. +1.00000000e+00j  0. +1.41421356e+00j]
|&gt;&gt; print sqrt(a)
Traceback (most recent call last):
 ...
FloatingPointError: invalid encountered in sqrt
|&gt;&gt; with errstate(divide='ignore'):
...     print a/0
[0 0 0]
|&gt;&gt; print a/0
Traceback (most recent call last):
    ...
FloatingPointError: divide by zero encountered in divide

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="extract"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">extract</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the elements of ravel(arr) where ravel(condition) is True
(in 1D).

Equivalent to compress(ravel(condition), ravel(arr)).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="factorial"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">factorial</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
n! = special.gamma(n+1)

If exact==0, then floating point precision is used, otherwise
exact long integer is computed.

Notes:
  - Array argument accepted only for exact=0 case.
  - If n&lt;0, the return value is 0.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="factorial2"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">factorial2</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd
       = 2**(n) * n!                                 n even

If exact==0, then floating point precision is used, otherwise
exact long integer is computed.

Notes:
  - Array argument accepted only for exact=0 case.
  - If n&lt;0, the return value is 0.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="factorialk"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">factorialk</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
n(!!...!)  = multifactorial of order k
k times

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fft"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fft</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">n</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the n point discrete Fourier transform of a. n defaults to
the length of a. If n is larger than the length of a, then a will
be zero-padded to make up the difference.  If n is smaller than
the length of a, only the first n items in a will be used.

The packing of the result is &quot;standard&quot;: If A = fft(a, n), then A[0]
contains the zero-frequency term, A[1:n/2+1] contains the
positive-frequency terms, and A[n/2+1:] contains the negative-frequency
terms, in order of decreasingly negative frequency. So for an 8-point
transform, the frequencies of the result are [ 0, 1, 2, 3, 4, -3, -2, -1].

This is most efficient for n a power of two. This also stores a cache of
working memory for different sizes of fft's, so you could theoretically
run into memory problems if you call this too many times with too many
different n's.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="find_common_type"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">find_common_type</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Determine common type following standard coercion rules

Parameters
----------
array_types : sequence
    A list of dtype convertible objects representing arrays
scalar_types : sequence
    A list of dtype convertible objects representing scalars

Returns
-------
datatype : dtype
    The common data-type which is the maximum of the array_types
    ignoring the scalar_types unless the maximum of the scalar_types
    is of a different kind.

    If the kinds is not understood, then None is returned.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="finfo"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">finfo</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Machine limits for floating point types.

:Parameters:
    dtype : floating point type or instance

:SeeAlso:
  - numpy.lib.machar.MachAr

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="flatnonzero"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">flatnonzero</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return indicies that are not-zero in flattened version of a

Equivalent to a.ravel().nonzero()[0]

&gt;&gt;&gt; from numpy import arange, flatnonzero
&gt;&gt;&gt; arange(-2, 3)
array([-2, -1,  0,  1,  2])
&gt;&gt;&gt; flatnonzero(arange(-2, 3))
array([0, 1, 3, 4])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fliplr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fliplr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
returns an array m with the rows preserved and columns flipped
in the left/right direction.  Works on the first two dimensions of m.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="flipud"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">flipud</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
returns an array with the columns preserved and rows flipped in
the up/down direction.  Works on the first dimension of m.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="format_parser"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">format_parser</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Class to convert formats, names, titles description to a dtype

After constructing the format_parser object, the dtype attribute is
  the converted data-type.

dtype = format_parser(formats, names, titles).dtype

Parameters
----------
formats : string or list
    comma-separated format descriptions --- 'f8, i4, a5'
    list of format description strings --- ['f8', 'i4', 'a5']
names : string or (list or tuple of strings)
    comma-separated field names --- 'col1, col2, col3'
    list or tuple of field names
titles : sequence
    sequence of title strings or unicode
aligned : bool
    align the fields by padding as the C-compiler would
byteorder :
    If specified, all the fields will be changed to the
    provided byteorder.  Otherwise, the default byteorder is
    used.

Returns
-------
object
    A Python object whose dtype attribute is a data-type.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="frombuffer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">frombuffer</span>(<span class="sig-arg">buffer</span>=<span class="sig-default"></span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns a 1-d array of data type dtype from buffer.

Parameters
----------
buffer
    An object that exposes the buffer interface
dtype : data-type
    Data type of the returned array.
count : int
    Number of items to read. -1 means all data in the buffer.
offset : int
    Number of bytes to jump from the start of the buffer before reading

Notes
-----
If the buffer has data that is not in machine byte-order, then
use a proper data type descriptor. The data will not be
byteswapped, but the array will manage it in future operations.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromfile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromfile</span>(<span class="sig-arg">file</span>=<span class="sig-default"></span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">sep</span>=<span class="sig-default">''</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return an array of the given data type from a text or binary file.

Data written using the tofile() method can be conveniently recovered using
this function.

Parameters
----------
file : file or string
    Open file object or string containing a file name.
dtype : data-type
    Data type of the returned array.
    For binary files, it is also used to determine the size and order of
    the items in the file.
count : int
    Number of items to read. -1 means all data in the whole file.
sep : string
    Separator between items if file is a text file.
    Empty (&quot;&quot;) separator means the file should be treated as binary.

See also
--------
loadtxt : load data from text files

Notes
-----
WARNING: This function should be used sparingly as the binary files are not
platform independent. In particular, they contain no endianess or datatype
information. Nevertheless it can be useful for reading in simply formatted
or binary data quickly.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromfunction"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromfunction</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns an array constructed by calling a function on a tuple of number
grids.

The function should accept as many arguments as the length of shape and
work on array inputs.  The shape argument is a sequence of numbers
indicating the length of the desired output for each axis.

The function can also accept keyword arguments (except dtype), which will
be passed through fromfunction to the function itself.  The dtype argument
(default float) determines the data-type of the index grid passed to the
function.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromiter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromiter</span>(<span class="sig-arg">iterable</span>,
        <span class="sig-arg">dtype</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a new 1d array initialized from iterable.

Parameters
----------
iterable
    Iterable object from which to obtain data
dtype : data-type
    Data type of the returned array.
count : int
    Number of items to read. -1 means all data in the iterable.

Returns
-------
new_array : ndarray

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="frompyfunc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">frompyfunc</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
frompyfunc(func, nin, nout) take an arbitrary python function that takes nin objects as input and returns nout objects and return a universal function (ufunc).  This ufunc always returns PyObject arrays

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromregex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromregex</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Construct an array from a text file, using regular-expressions
parsing.

Array is constructed from all matches of the regular expression
in the file. Groups in the regular expression are converted to fields.

Parameters
----------
file : str or file
    File name or file object to read.
regexp : str or regexp
    Regular expression used to parse the file.
    Groups in the regular expression correspond to fields in the dtype.
dtype : dtype or dtype list
    Dtype for the structured array

Examples
--------
&gt;&gt;&gt; f = open('test.dat', 'w')
&gt;&gt;&gt; f.write(&quot;1312 foo\n1534  bar\n444   qux&quot;)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; np.fromregex('test.dat', r&quot;(\d+)\s+(...)&quot;,
...              [('num', np.int64), ('key', 'S3')])
array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],
      dtype=[('num', '&lt;i8'), ('key', '|S3')])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromstring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromstring</span>(<span class="sig-arg">string</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">sep</span>=<span class="sig-default">''</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a new 1d array initialized from the raw binary data in string.

If count is positive, the new array will have count elements, otherwise its
size is determined by the size of string.  If sep is not empty then the
string is interpreted in ASCII mode and converted to the desired number type
using sep as the separator between elements (extra whitespace is ignored).
ASCII integer conversions are base-10; octal and hex are not supported.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fv</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
future value computed by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Example
--------

What is the future value after 10 years of saving $100 now, with
  an additional monthly savings of $100.  Assume the interest rate is
  5% (annually) compounded monthly?

&gt;&gt;&gt; fv(0.05/12, 10*12, -100, -100)
15692.928894335748

By convention, the negative sign represents cash flow out (i.e. money not
  available today).  Thus, saving $100 a month at 5% annual interest leads
  to $15,692.93 available to spend in 10 years.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_include"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_include</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the directory in the package that contains the numpy/*.h header
files.

Extension modules that need to compile against numpy should use this
function to locate the appropriate include directory. Using distutils:

  import numpy
  Extension('extension_name', ...
            include_dirs=[numpy.get_include()])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_numpy_include"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_numpy_include</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
get_numpy_include is DEPRECATED!! -- use get_include instead

Return the directory in the package that contains the numpy/*.h header
    files.

    Extension modules that need to compile against numpy should use this
    function to locate the appropriate include directory. Using distutils:

      import numpy
      Extension('extension_name', ...
                include_dirs=[numpy.get_include()])
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_printoptions"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_printoptions</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the current print options.

:Returns:
    dictionary of current print options with keys
    - precision : int
    - threshold : int
    - edgeitems : int
    - linewidth : int
    - suppress : bool
    - nanstr : string
    - infstr : string

:SeeAlso:
 - set_printoptions : parameter descriptions

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="getbuffer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">getbuffer</span>(<span class="sig-arg">obj</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">...</span>,
        <span class="sig-arg">size</span>=<span class="sig-default">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Create a buffer object from the given object referencing a slice of
length size starting at offset.  Default is the entire buffer. A
read-write buffer is attempted followed by a read-only buffer.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="geterr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">geterr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Get the current way of handling floating-point errors.

Returns a dictionary with entries &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;, and
&quot;invalid&quot;, whose values are from the strings
&quot;ignore&quot;, &quot;print&quot;, &quot;log&quot;, &quot;warn&quot;, &quot;raise&quot;, and &quot;call&quot;.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="geterrobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">geterrobj</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Used internally by `geterr`.

Returns
-------
errobj : list
    Internal numpy buffer size, error mask, error callback function.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="gradient"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">gradient</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Calculate the gradient of an N-dimensional scalar function.

Uses central differences on the interior and first differences on boundaries
to give the same shape.

Inputs:

  f -- An N-dimensional array giving samples of a scalar function

  varargs -- 0, 1, or N scalars giving the sample distances in each direction

Outputs:

  N arrays of the same shape as f giving the derivative of f with respect
  to each dimension.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="histogram"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogram</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Compute the histogram from a set of data.

Parameters
----------
a : array
    The data to histogram.

bins : int or sequence
    If an int, then the number of equal-width bins in the given
    range.  If new=True, bins can also be the bin edges, allowing
    for non-constant bin widths.

range : (float, float)
    The lower and upper range of the bins. If not provided, range
    is simply (a.min(), a.max()). Using new=False, lower than
    range are ignored, and values higher than range are tallied in
    the rightmost bin. Using new=True, both lower and upper
    outliers are ignored.

normed : bool
    If False, the result array will contain the number of samples
    in each bin.  If True, the result array is the value of the
    probability *density* function at the bin normalized such that
    the *integral* over the range is 1. Note that the sum of all
    of the histogram values will not usually be 1; it is not a
    probability *mass* function.

weights : array
    An array of weights, the same shape as a. If normed is False,
    the histogram is computed by summing the weights of the values
    falling into each bin. If normed is True, the weights are
    normalized, so that the integral of the density over the range
    is 1. This option is only available with new=True.

new : bool
    Compatibility argument to transition from the old version
    (v1.1) to the new version (v1.2).

Returns
-------
hist : array
    The values of the histogram. See `normed` and `weights` for a
    description of the possible semantics.

bin_edges : float array
    With new=False, return the left bin edges (length(hist)).
    With new=True, return the bin edges (length(hist)+1).

See Also
--------
histogramdd

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="histogram2d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogram2d</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>,
        <span class="sig-arg">bins</span>=<span class="sig-default">10</span>,
        <span class="sig-arg">range</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normed</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Compute the 2D histogram from samples x,y.

:Parameters:
  - `x,y` : Sample arrays (1D).
  - `bins` : Number of bins -or- [nbin x, nbin y] -or-
         [bin edges] -or- [x bin edges, y bin edges].
  - `range` : A sequence of lower and upper bin edges (default: [min, max]).
  - `normed` : Boolean, if False, return the number of samples in each bin,
            if True, returns the density.
  - `weights` : An array of weights. The weights are normed only if normed
            is True. Should weights.sum() not equal N, the total bin count                 will not be equal to the number of samples.

:Return:
  - `hist` :    Histogram array.
  - `xedges, yedges` : Arrays defining the bin edges.

Example:
  &gt;&gt;&gt; x = random.randn(100,2)
  &gt;&gt;&gt; hist2d, xedges, yedges = histogram2d(x, bins = (6, 7))

:SeeAlso: histogramdd

</pre>
  <dl class="fields">
    <dt>Returns:</dt>
        <dd><pre class="literalblock">
H, xedges, yedges

</pre></dd>
  </dl>
</td></tr></table>
</div>
<a name="histogramdd"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogramdd</span>(<span class="sig-arg">sample</span>,
        <span class="sig-arg">bins</span>=<span class="sig-default">10</span>,
        <span class="sig-arg">range</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normed</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the N-dimensional histogram of the sample.

Parameters
----------
sample : sequence or array
    A sequence containing N arrays or an NxM array. Input data.

bins : sequence or scalar
    A sequence of edge arrays, a sequence of bin counts, or a scalar
    which is the bin count for all dimensions. Default is 10.

range : sequence
    A sequence of lower and upper bin edges. Default is [min, max].

normed : boolean
    If False, return the number of samples in each bin, if True,
    returns the density.

weights : array
    Array of weights.  The weights are normed only if normed is True.
    Should the sum of the weights not equal N, the total bin count will
    not be equal to the number of samples.

Returns
-------
hist : array
    Histogram array.

edges : list
    List of arrays defining the lower bin edges.

See Also
--------
histogram

Examples
--------
&gt;&gt;&gt; x = random.randn(100,3)
&gt;&gt;&gt; hist3d, edges = histogramdd(x, bins = (5, 6, 7))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hsplit</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Split ary into multiple columns of sub-arrays

Description:
    Split a single array into multiple sub arrays.  The array is
    divided into groups of columns.  If indices_or_sections is
    an integer, ary is divided into that many equally sized sub arrays.
    If it is impossible to make the sub-arrays equally sized, the
    operation throws a ValueError exception. See array_split and
    split for other options on indices_or_sections.
Arguments:
   ary -- N-D array.
      Array to be divided into sub-arrays.
   indices_or_sections -- integer or 1D array.
      If integer, defines the number of (close to) equal sized
      sub-arrays.  If it is a 1D array of sorted indices, it
      defines the indexes at which ary is divided.  Any empty
      list results in a single sub-array equal to the original
      array.
Returns:
    sequence of sub-arrays.  The returned arrays have the same
    number of dimensions as the input array.
Related:
    hstack, split, array_split, vsplit, dsplit.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a= array((1,2,3,4))
    &gt;&gt;&gt; numpy.hsplit(a,2)
    [array([1, 2]), array([3, 4])]
    &gt;&gt;&gt; a = array([[1,2,3,4],[1,2,3,4]])
    &gt;&gt;&gt; hsplit(a,2)
    [array([[1, 2],
           [1, 2]]), array([[3, 4],
           [3, 4]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hstack</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Stack arrays in sequence horizontally (column wise)

Description:
    Take a sequence of arrays and stack them horizontally
    to make a single array.  All arrays in the sequence
    must have the same shape along all but the second axis.
    hstack will rebuild arrays divided by hsplit.
Arguments:
    tup -- sequence of arrays.  All arrays must have the same
           shape.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a = array((1,2,3))
    &gt;&gt;&gt; b = array((2,3,4))
    &gt;&gt;&gt; numpy.hstack((a,b))
    array([1, 2, 3, 2, 3, 4])
    &gt;&gt;&gt; a = array([[1],[2],[3]])
    &gt;&gt;&gt; b = array([[2],[3],[4]])
    &gt;&gt;&gt; numpy.hstack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ifft"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ifft</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">n</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the n point inverse discrete Fourier transform of a.  n
defaults to the length of a. If n is larger than the length of a,
then a will be zero-padded to make up the difference. If n is
smaller than the length of a, then a will be truncated to reduce
its size.

The input array is expected to be packed the same way as the output of
fft, as discussed in it's documentation.

This is the inverse of fft: ifft(fft(a)) == a within numerical
accuracy.

This is most efficient for n a power of two. This also stores a cache of
working memory for different sizes of fft's, so you could theoretically
run into memory problems if you call this too many times with too many
different n's.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="iinfo"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">iinfo</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Limits for integer types.

:Parameters:
    type : integer type or instance

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="imag"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">imag</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the imaginary part of val.

Useful if val maybe a scalar or an array.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="info"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">info</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Get help information for a function, class, or module.

Example:
   &gt;&gt;&gt; from numpy import *
   &gt;&gt;&gt; info(polyval) # doctest: +SKIP

   polyval(p, x)

     Evaluate the polymnomial p at x.

     Description:
         If p is of length N, this function returns the value:
         p[0]*(x**N-1) + p[1]*(x**N-2) + ... + p[N-2]*x + p[N-1]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="inner"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">inner</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns the inner product of a and b for arrays of floating point types.
Like the generic NumPy equivalent the product sum is over
the last dimension of a and b.
NB: The first argument is not conjugated.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="insert"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">insert</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a new array with values inserted along the given axis
before the given indices

If axis is None, then ravel the array first.

The obj argument can be an integer, a slice, or a sequence of
integers.

Examples
--------
&gt;&gt;&gt; a = array([[1,2,3],
...            [4,5,6],
...            [7,8,9]])

&gt;&gt;&gt; insert(a, [1,2], [[4],[5]], axis=0)
array([[1, 2, 3],
       [4, 4, 4],
       [4, 5, 6],
       [5, 5, 5],
       [7, 8, 9]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="interp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">interp</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the value of a piecewise-linear function at each value in x.

The piecewise-linear function, f, is defined by the known data-points
fp=f(xp). The xp points must be sorted in increasing order but this is
not checked.

For values of x &lt; xp[0] return the value given by left.  If left is None,
then return fp[0].
For values of x &gt; xp[-1] return the value given by right. If right is
None, then return fp[-1].

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="intersect1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">intersect1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Intersection of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as inputs
to this function. Alternatively, use intersect1d_nu() which will find the
unique values for you.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
intersection : array

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="intersect1d_nu"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">intersect1d_nu</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Intersection of 1D arrays with any elements.

The input arrays do not have unique elements like intersect1d() requires.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
intersection : array

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="irr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">irr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Internal Rate of Return

This is the rate of return that gives a net present value of 0.0

npv(irr(values), values) == 0.0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="iscomplex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">iscomplex</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a boolean array where elements are True if that element
is complex (has non-zero imaginary part).

For scalars, return a boolean.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="iscomplexobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">iscomplexobj</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return True if x is a complex type or an array of complex numbers.

Unlike iscomplex(x), complex(3.0) is considered a complex object.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isfortran"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isfortran</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns True if 'a' is arranged in Fortran-order in memory with a.ndim &gt; 1
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isneginf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isneginf</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a boolean array y with y[i] True for x[i] = -Inf.

If y is an array, the result replaces the contents of y.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isposinf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isposinf</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a boolean array y with y[i] True for x[i] = +Inf.

If y is an array, the result replaces the contents of y.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isrealobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isrealobj</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return True if x is not a complex type.

Unlike isreal(x), complex(3.0) is considered a complex object.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ix_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ix_</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Construct an open mesh from multiple sequences.

This function takes n 1-d sequences and returns n outputs with n
dimensions each such that the shape is 1 in all but one dimension and
the dimension with the non-unit shape value cycles through all n
dimensions.

Using ix_() one can quickly construct index arrays that will index
the cross product.

a[ix_([1,3,7],[2,5,8])]  returns the array

a[1,2]  a[1,5]  a[1,8]
a[3,2]  a[3,5]  a[3,8]
a[7,2]  a[7,5]  a[7,8]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="kron"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">kron</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
kronecker product of a and b

Kronecker product of two arrays is block array
[[ a[ 0 ,0]*b, a[ 0 ,1]*b, ... , a[ 0 ,n-1]*b  ],
 [ ...                                   ...   ],
 [ a[m-1,0]*b, a[m-1,1]*b, ... , a[m-1,n-1]*b  ]]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="lexsort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">lexsort</span>(<span class="sig-arg">keys</span>=<span class="sig-default"></span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Argsort with list of keys.

Perform an indirect sort using a list of keys. The first key is sorted,
then the second, and so on through the list of keys. At each step the
previous order is preserved when equal keys are encountered. The result is
a sort on multiple keys.  If the keys represented columns of a spreadsheet,
for example, this would sort using multiple columns (the last key being
used for the primary sort order, the second-to-last key for the secondary
sort order, and so on).

Parameters
----------
keys : (k,N) array or tuple of (N,) sequences
    Array containing values that the returned indices should sort, or
    a sequence of things that can be converted to arrays of the same shape.

axis : integer
    Axis to be indirectly sorted.  Default is -1 (i.e. last axis).

Returns
-------
indices : (N,) integer array
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : indirect sort
sort : inplace sort

Examples
--------
&gt;&gt;&gt; a = [1,5,1,4,3,6,7]
&gt;&gt;&gt; b = [9,4,0,4,0,4,3]
&gt;&gt;&gt; ind = lexsort((b,a))
&gt;&gt;&gt; print ind
[2 0 4 3 1 5 6]
&gt;&gt;&gt; print take(a,ind)
[1 1 3 4 5 6 7]
&gt;&gt;&gt; print take(b,ind)
[0 9 0 4 4 4 3]

</pre>
  <dl class="fields">
    <dt>Returns:</dt>
        <dd><pre class="literalblock">
array of indices

</pre></dd>
  </dl>
</td></tr></table>
</div>
<a name="load"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">load</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Load a binary file.

Read a binary file (either a pickle, or a binary .npy/.npz file) and
return the result.

Parameters
----------
file : file-like object or string
    the file to read.  It must support seek and read methods
memmap : bool
    If true, then memory-map the .npy file or unzip the .npz file into
       a temporary directory and memory-map each component
    This has no effect for a pickle.

Returns
-------
result : array, tuple, dict, etc.
    data stored in the file.
    If file contains pickle data, then whatever is stored in the pickle is
      returned.
    If the file is .npy file, then an array is returned.
    If the file is .npz file, then a dictionary-like object is returned
      which has a filename:array key:value pair for every file in the zip.

Raises
------
IOError

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="loadtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">loadtxt</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Load ASCII data from fname into an array and return the array.

The data must be regular, same number of values in every row

Parameters
----------
fname : filename or a file handle.
  Support for gzipped files is automatic, if the filename ends in .gz

dtype : data-type
  Data type of the resulting array.  If this is a record data-type, the
  resulting array will be 1-d and each row will be interpreted as an
  element of the array. The number of columns used must match the number
  of fields in the data-type in this case.

comments : str
  The character used to indicate the start of a comment in the file.

delimiter : str
  A string-like character used to separate values in the file. If delimiter
  is unspecified or none, any whitespace string is a separator.

converters : {}
  A dictionary mapping column number to a function that will convert that
  column to a float.  Eg, if column 0 is a date string:
  converters={0:datestr2num}. Converters can also be used to provide
  a default value for missing data: converters={3:lambda s: float(s or 0)}.

skiprows : int
  The number of rows from the top to skip.

usecols : sequence
  A sequence of integer column indexes to extract where 0 is the first
  column, eg. usecols=(1,4,5) will extract the 2nd, 5th and 6th columns.

unpack : bool
  If True, will transpose the matrix allowing you to unpack into named
  arguments on the left hand side.

Examples
--------
  &gt;&gt;&gt; X = loadtxt('test.dat')  # data in two columns
  &gt;&gt;&gt; x,y,z = load('somefile.dat', usecols=(3,5,7), unpack=True)
  &gt;&gt;&gt; r = np.loadtxt('record.dat', dtype={'names':('gender','age','weight'),
            'formats': ('S1','i4', 'f4')})

SeeAlso: scipy.io.loadmat to read and write matfiles.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="log2"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">log2</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Take log base 2 of x.

If x contains negative inputs, the answer is computed and returned in the
complex domain.

Parameters
----------
x : array_like

Returns
-------
array_like

Examples
--------

(We set the printing precision so the example can be auto-tested)
&gt;&gt;&gt; import numpy as np; np.set_printoptions(precision=4)

&gt;&gt;&gt; log2([4,8])
array([ 2.,  3.])

&gt;&gt;&gt; log2([-4,-8,8])
array([ 2.+4.5324j,  3.+4.5324j,  3.+0.j    ])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="lookfor"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">lookfor</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Search for objects whose documentation contains all given words.
Shows a summary of matching objects, sorted roughly by relevance.

Parameters
----------
what : str
    String containing words to look for.

module : str, module
    Module whose docstrings to go through.
import_modules : bool
    Whether to import sub-modules in packages.
    Will import only modules in __all__
regenerate: bool
    Re-generate the docstring cache

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mat</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns 'data' as a matrix.  Unlike matrix(), no copy is performed
if 'data' is already a matrix or array.  Equivalent to:
matrix(data, copy=False)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="matrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">matrix</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

mat = matrix(data, dtype=None, copy=True)

Returns a matrix from an array-like object, or a string of
data.  A matrix is a specialized 2-d array that retains
its 2-d nature through operations and where '*' means matrix
multiplication and '**' means matrix power.

Parameters
----------
data : array-like or string
   If data is a string, then interpret the string as a matrix
   with commas or spaces separating columns and semicolons
   separating rows.
   If data is array-like than convert the array to a matrix.
dtype : data-type
   Anything that can be interpreted as a NumPy datatype.
copy : bool
   If data is already an ndarray, then this flag determines whether
   or not the data will be copied

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.matrix('1 2; 3 4')
&gt;&gt;&gt; print a
[[1 2]
 [3 4]]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="may_share_memory"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">may_share_memory</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Determine if two arrays can share memory

The memory-bounds of a and b are computed.  If they overlap then
this function returns True.  Otherwise, it returns False.

A return of True does not necessarily mean that the two arrays
share any element.  It just means that they *might*.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="median"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">median</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Compute the median along the specified axis.

Returns the median of the array elements.  The median is taken
over the first axis of the array by default, otherwise over
the specified axis.

Parameters
----------
a : array-like
    Input array or object that can be converted to an array
axis : {int, None}, optional
    Axis along which the medians are computed. The default is to
    compute the median along the first dimension.  axis=None
    returns the median of the flattened array

out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.

overwrite_input : {False, True}, optional
   If True, then allow use of memory of input array (a) for
   calculations. The input array will be modified by the call to
   median. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. Note that, if overwrite_input is true, and the input
   is not already an ndarray, an error will be raised.

Returns
-------
median : ndarray.
    A new array holding the result is returned unless out is
    specified, in which case a reference to out is returned.
    Return datatype is float64 for ints and floats smaller than
    float64, or the input datatype otherwise.

See Also
-------
mean

Notes
-----
Given a vector V length N, the median of V is the middle value of
a sorted copy of V (Vs) - i.e. Vs[(N-1)/2], when N is odd. It is
the mean of the two middle values of Vs, when N is even.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from numpy import median
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; median(a)
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; median(a, axis=None)
3.5
&gt;&gt;&gt; median(a, axis=1)
array([ 7.,  2.])
&gt;&gt;&gt; m = median(a)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; median(a, out=m)
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; m
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; median(b, axis=1, overwrite_input=True)
array([ 7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; median(b, axis=None, overwrite_input=True)
3.5
&gt;&gt;&gt; assert not np.all(a==b)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="memmap"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">memmap</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Create a memory-map to an array stored in a file on disk.

Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  Numpy's memmaps are
array-like objects.  This differs from python's mmap module which are
file-like objects.

Parameters
----------
filename : string or file-like object
    The file name or file object to be used as the array data
    buffer.
dtype : data-type, optional
    The data-type used to interpret the file contents.
    Default is uint8
mode : {'r', 'r+', 'w+', 'c'}, optional
    The mode to open the file.
    'r',  open existing file for read-only
    'r+', open existing file for read-write
    'w+', create or overwrite existing file and open for read-write
    'c',  copy-on-write, assignments effect data in memory, but changes
          are not saved to disk.  File on disk is read-only.
    Default is 'r+'
offset : integer, optional
    Byte offset into the file to start the array data. Should be a
    multiple of the data-type of the data.  Requires shape=None.
    Default is 0
shape : tuple, optional
    The desired shape of the array. If None, the returned array will be 1-D
    with the number of elements determined by file size and data-type.
    Default is None
order : {'C', 'F'}, optional
    Specify the order of the N-D array, C or Fortran ordered. This only
    has an effect if the shape is greater than 2-D.
    Default is 'C'

Methods
-------
close : close the memmap file
flush : flush any changes in memory to file on disk
    When you delete a memmap object, flush is called first to write
    changes to disk before removing the object.

Returns
-------
memmap : array-like memmap object
    The memmap object can be used anywhere an ndarray is accepted.
    If fp is a memmap, isinstance(fp, numpy.ndarray) will return True.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; data = np.arange(12, dtype='float32')
&gt;&gt;&gt; data.resize((3,4))

&gt;&gt;&gt; # Using a tempfile so doctest doesn't write files to your directory.
&gt;&gt;&gt; # You would use a 'normal' filename.
&gt;&gt;&gt; from tempfile import mkdtemp
&gt;&gt;&gt; import os.path as path
&gt;&gt;&gt; filename = path.join(mkdtemp(), 'newfile.dat')

&gt;&gt;&gt; # Create a memmap with dtype and shape that matches our data
&gt;&gt;&gt; fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))
&gt;&gt;&gt; fp
memmap([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]], dtype=float32)

&gt;&gt;&gt; # Write data to memmap array
&gt;&gt;&gt; fp[:] = data[:]
&gt;&gt;&gt; fp
memmap([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]], dtype=float32)

&gt;&gt;&gt; # Deletion flushes memory changes to disk before removing the object.
&gt;&gt;&gt; del fp
&gt;&gt;&gt; # Load the memmap and verify data was stored
&gt;&gt;&gt; newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
&gt;&gt;&gt; newfp
memmap([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]], dtype=float32)

&gt;&gt;&gt; # read-only memmap
&gt;&gt;&gt; fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
&gt;&gt;&gt; fpr.flags.writeable
False
&gt;&gt;&gt; # Cannot assign to read-only, obviously
&gt;&gt;&gt; fpr[0, 3] = 56
Traceback (most recent call last):
    ...
RuntimeError: array is not writeable

&gt;&gt;&gt; # copy-on-write memmap
&gt;&gt;&gt; fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))
&gt;&gt;&gt; fpc.flags.writeable
True
&gt;&gt;&gt; # Can assign to copy-on-write array, but values are only written
&gt;&gt;&gt; # into the memory copy of the array, and not written to disk.
&gt;&gt;&gt; fpc
memmap([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]], dtype=float32)
&gt;&gt;&gt; fpc[0,:] = 0
&gt;&gt;&gt; fpc
memmap([[  0.,   0.,   0.,   0.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]], dtype=float32)
&gt;&gt;&gt; # file on disk is unchanged
&gt;&gt;&gt; fpr
memmap([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]], dtype=float32)

&gt;&gt;&gt; # offset into a memmap
&gt;&gt;&gt; fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)
&gt;&gt;&gt; fpo
memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="meshgrid"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">meshgrid</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

For vectors x, y with lengths Nx=len(x) and Ny=len(y), return X, Y
where X and Y are (Ny, Nx) shaped arrays with the elements of x
and y repeated to fill the matrix

EG,

  [X, Y] = meshgrid([1,2,3], [4,5,6,7])

   X =
     1   2   3
     1   2   3
     1   2   3
     1   2   3


   Y =
     4   4   4
     5   5   5
     6   6   6
     7   7   7

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mintypecode"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mintypecode</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a minimum data type character from typeset that
handles all typechars given

The returned type character must be the smallest size such that
an array of the returned type can handle the data from an array of
type t for each t in typechars (or if typechars is an array,
then its dtype.char).

If the typechars does not intersect with the typeset, then default
is returned.

If t in typechars is not a string then t=asarray(t).dtype.char is
applied.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mirr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mirr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Modified internal rate of return

Parameters
----------
values:
    Cash flows (must contain at least one positive and one negative value)
    or nan is returned.
finance_rate :
    Interest rate paid on the cash flows
reinvest_rate :
    Interest rate received on the cash flows upon reinvestment

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="modf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">modf</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
y1,y2 = modf(x) breaks x into fractional (y1) and integral (y2) parts.

Each output has the same sign as the input.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nan_to_num"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nan_to_num</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Returns a copy of replacing NaN's with 0 and Infs with large numbers

The following mappings are applied:
    NaN -&gt; 0
    Inf -&gt; limits.double_max
   -Inf -&gt; limits.double_min

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ndenumerate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ndenumerate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

A simple nd index iterator over an array.

Example:
&gt;&gt;&gt; a = array([[1,2],[3,4]])
&gt;&gt;&gt; for index, x in ndenumerate(a):
...     print index, x
(0, 0) 1
(0, 1) 2
(1, 0) 3
(1, 1) 4

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ndim"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ndim</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the number of dimensions of a.

If a is not already an array, a conversion is attempted. Scalars are zero
dimensional.

Parameters
----------
a : {array_like}
    Array whose number of dimensions are desired. If a is not an
    array, a conversion is attempted.

Returns
-------
number_of_dimensions : {integer}
    Returns the number of dimensions.

See Also
--------
rank : equivalent function.
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
&gt;&gt;&gt; ndim([[1,2,3],[4,5,6]])
2
&gt;&gt;&gt; ndim(array([[1,2,3],[4,5,6]]))
2
&gt;&gt;&gt; ndim(1)
0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ndindex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ndindex</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Pass in a sequence of integers corresponding
to the number of dimensions in the counter.  This iterator
will then return an N-dimensional counter.

Example:
&gt;&gt;&gt; for index in ndindex(3,2,1):
...     print index
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nper"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nper</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Number of periods found by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Examples
--------

If you only had $150 to spend as payment, how long would it take to pay-off
  a loan of $8,000 at 7% annual interest?

&gt;&gt;&gt; nper(0.07/12, -150, 8000)
64.073348770661852

So, over 64 months would be required to pay off the loan.

The same analysis could be done with several different interest rates and/or
    payments and/or total amounts to produce an entire table.

&gt;&gt;&gt; nper(*(ogrid[0.06/12:0.071/12:0.01/12, -200:-99:100, 6000:7001:1000]))
array([[[ 32.58497782,  38.57048452],
        [ 71.51317802,  86.37179563]],

       [[ 33.07413144,  39.26244268],
        [ 74.06368256,  90.22989997]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="npv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">npv</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Net Present Value

sum ( values_k / (1+rate)**k, k = 1..n)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="outer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">outer</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns the outer product of two vectors.

result[i,j] = a[i]*b[j] when a and b are vectors.
Will accept any arguments that can be made into vectors.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="packbits"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">packbits</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
out = numpy.packbits(myarray, axis=None)

myarray : an integer type array whose elements should be packed to bits

 This routine packs the elements of a binary-valued dataset into a
 NumPy array of type uint8 ('B') whose bits correspond to
 the logical (0 or nonzero) value of the input elements.
 The dimension over-which bit-packing is done is given by axis.
 The shape of the output has the same number of dimensions as the input
 (unless axis is None, in which case the output is 1-d).

   Example:
   &gt;&gt;&gt; a = array([[[1,0,1],
   ...             [0,1,0]],
   ...            [[1,1,0],
   ...             [0,0,1]]])
   &gt;&gt;&gt; b = numpy.packbits(a,axis=-1)
   &gt;&gt;&gt; b
   array([[[160],[64]],[[192],[32]]], dtype=uint8)

   Note that 160 = 128 + 32
             192 = 128 + 64

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="piecewise"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">piecewise</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a piecewise-defined function.

x is the domain

condlist is a list of boolean arrays or a single boolean array
  The length of the condition list must be n2 or n2-1 where n2
  is the length of the function list.  If len(condlist)==n2-1, then
  an 'otherwise' condition is formed by |'ing all the conditions
  and inverting.

funclist is a list of functions to call of length (n2).
  Each function should return an array output for an array input
  Each function can take (the same set) of extra arguments and
  keyword arguments which are passed in after the function list.
  A constant may be used in funclist for a function that returns a
  constant (e.g. val  and lambda x: val are equivalent in a funclist).

The output is the same shape and type as x and is found by
  calling the functions on the appropriate portions of x.

Note: This is similar to choose or select, except
      the the functions are only evaluated on elements of x
      that satisfy the corresponding condition.

The result is
       |--
       |  f1(x)  for condition1
 y = --|  f2(x)  for condition2
       |   ...
       |  fn(x)  for conditionn
       |--

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="place"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">place</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Similar to putmask arr[mask] = vals but the 1D array vals has the
same number of elements as the non-zero values of mask. Inverse of
extract.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pmt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pmt</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Payment computed by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))


Examples
--------

What would the monthly payment need to be to pay off a $200,000 loan in 15
  years at an annual interest rate of 7.5%?

&gt;&gt;&gt; pmt(0.075/12, 12*15, 200000)
-1854.0247200054619

In order to pay-off (i.e. have a future-value of 0) the $200,000 obtained
  today, a monthly payment of $1,854.02 would be required.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="poly"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">poly</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a sequence representing a polynomial given a sequence of roots.

If the input is a matrix, return the characteristic polynomial.

Example:

    &gt;&gt;&gt; b = roots([1,3,1,5,6])
    &gt;&gt;&gt; poly(b)
    array([ 1.,  3.,  1.,  5.,  6.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="poly1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">poly1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
A one-dimensional polynomial class.

p = poly1d([1,2,3]) constructs the polynomial x**2 + 2 x + 3

p(0.5) evaluates the polynomial at the location
p.r  is a list of roots
p.c  is the coefficient array [1,2,3]
p.order is the polynomial order (after leading zeros in p.c are removed)
p[k] is the coefficient on the kth power of x (backwards from
     sequencing the coefficient array.

polynomials can be added, substracted, multplied and divided (returns
     quotient and remainder).
asarray(p) will also give the coefficient array, so polynomials can
     be used in all functions that accept arrays.

p = poly1d([1,2,3], variable='lambda') will use lambda in the
string representation of p.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyadd"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyadd</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Adds two polynomials represented as sequences
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyfit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyfit</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Least squares polynomial fit.

Do a best fit polynomial of degree 'deg' of 'x' to 'y'.  Return value is a
vector of polynomial coefficients [pk ... p1 p0].  Eg, for n=2

    p2*x0^2 +  p1*x0 + p0 = y1
    p2*x1^2 +  p1*x1 + p0 = y1
    p2*x2^2 +  p1*x2 + p0 = y2
    .....
    p2*xk^2 +  p1*xk + p0 = yk

Parameters
----------
x : array_like
    1D vector of sample points.
y : array_like
    1D vector or 2D array of values to fit. The values should run down the
    columes in the 2D case.
deg : integer
    Degree of the fitting polynomial
rcond: {None, float}, optional
    Relative condition number of the fit. Singular values smaller than this
    relative to the largest singular value will be ignored. The defaul value
    is len(x)*eps, where eps is the relative precision of the float type,
    about 2e-16 in most cases.
full : {False, boolean}, optional
    Switch determining nature of return value. When it is False just the
    coefficients are returned, when True diagnostic information from the
    singular value decomposition is also returned.

Returns
-------
coefficients, [residuals, rank, singular_values, rcond] : variable
    When full=False, only the coefficients are returned, running down the
    appropriate colume when y is a 2D array. When full=True, the rank of the
    scaled Vandermonde matrix, it's effective rank in light of the rcond
    value, its singular values, and the specified value of rcond are also
    returned.

Warns
-----
RankWarning : if rank is reduced and not full output
    The warnings can be turned off by:
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore',np.RankWarning)


See Also
--------
polyval : computes polynomial values.

Notes
-----
If X is a the Vandermonde Matrix computed from x (see
http://mathworld.wolfram.com/VandermondeMatrix.html), then the
polynomial least squares solution is given by the 'p' in

    X*p = y

where X.shape is a matrix of dimensions (len(x), deg + 1), p is a vector of
dimensions (deg + 1, 1), and y is a vector of dimensions (len(x), 1).

This equation can be solved as

    p = (XT*X)^-1 * XT * y

where XT is the transpose of X and -1 denotes the inverse. However, this
method is susceptible to rounding errors and generally the singular value
decomposition of the matrix X is preferred and that is what is done here.
The singular value method takes a paramenter, 'rcond', which sets a limit on
the relative size of the smallest singular value to be used in solving the
equation. This may result in lowering the rank of the Vandermonde matrix, in
which case a RankWarning is issued. If polyfit issues a RankWarning, try a
fit of lower degree or replace x by x - x.mean(), both of which will
generally improve the condition number. The routine already normalizes the
vector x by its maximum absolute value to help in this regard. The rcond
parameter can be set to a value smaller than its default, but the resulting
fit may be spurious. The current default value of rcond is len(x)*eps, where
eps is the relative precision of the floating type being used, generally
around 1e-7 and 2e-16 for IEEE single and double precision respectively.
This value of rcond is fairly conservative but works pretty well when x -
x.mean() is used in place of x.


DISCLAIMER: Power series fits are full of pitfalls for the unwary once the
degree of the fit becomes large or the interval of sample points is badly
centered. The problem is that the powers x**n are generally a poor basis for
the polynomial functions on the sample interval, resulting in a Vandermonde
matrix is ill conditioned and coefficients sensitive to rounding erros. The
computation of the polynomial values will also sensitive to rounding errors.
Consequently, the quality of the polynomial fit should be checked against
the data whenever the condition number is large.  The quality of polynomial
fits *can not* be taken for granted. If all you want to do is draw a smooth
curve through the y values and polyfit is not doing the job, try centering
the sample range or look into scipy.interpolate, which includes some nice
spline fitting functions that may be of use.

For more info, see
http://mathworld.wolfram.com/LeastSquaresFittingPolynomial.html,
but note that the k's and n's in the superscripts and subscripts
on that page.  The linear algebra is correct, however.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyint"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyint</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the mth analytical integral of the polynomial p.

If k is None, then zero-valued constants of integration are used.
otherwise, k should be a list of length m (or a scalar if m=1) to
represent the constants of integration to use for each integration
(starting with k[0])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polysub"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polysub</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Subtracts two polynomials represented as sequences
    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyval"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyval</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Evaluate the polynomial p at x.

If p is of length N, this function returns the value:

    p[0]*(x**N-1) + p[1]*(x**N-2) + ... + p[N-2]*x + p[N-1]

If x is a sequence then p(x) will be returned for all elements of x. If x is
another polynomial then the composite polynomial p(x) will be returned.

Parameters
----------
p : {array_like, poly1d}
    1D array of polynomial coefficients from highest degree to zero or an
    instance of poly1d.
x : {array_like, poly1d}
    A number, a 1D array of numbers, or an instance of poly1d.

Returns
-------
values : {array, poly1d}
    If either p or x is an instance of poly1d, then an instance of poly1d is
    returned, otherwise a 1D array is returned. In the case where x is a
    poly1d, the result is the composition of the two polynomials, i.e.,
    substitution is used.

Notes
-----
Horners method is used to evaluate the polynomial. Even so, for polynomial
if high degree the values may be inaccurate due to rounding errors. Use
carefully.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="power"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">power</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return x**p.

If x contains negative values, it is converted to the complex domain.

If p contains negative values, it is converted to floating point.

Parameters
----------
x : array_like
p : array_like of integers

Returns
-------
array_like

Examples
--------
(We set the printing precision so the example can be auto-tested)
&gt;&gt;&gt; import numpy as np; np.set_printoptions(precision=4)

&gt;&gt;&gt; power([2,4],2)
array([ 4, 16])

&gt;&gt;&gt; power([2,4],-2)
array([ 0.25  ,  0.0625])

&gt;&gt;&gt; power([-2,4],2)
array([  4.+0.j,  16.+0.j])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="prod"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">prod</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the product of the array elements over the given axis

Parameters
----------
a : {array_like}
    Array containing elements whose product is desired. If a is not an array, a
    conversion is attempted.
axis : {None, integer}
    Axis over which the product is taken. If None is used, then the
    product is over all the array elements.
dtype : {None, dtype}, optional
    Determines the type of the returned array and of the accumulator
    where the elements are multiplied. If dtype has the value None and
    the type of a is an integer type of precision less than the default
    platform integer, then the default platform integer precision is
    used.  Otherwise, the dtype is the same as that of a.
out : {None, array}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
product_along_axis : {array, scalar}, see dtype parameter above.
    Returns an array whose shape is the same as a with the specified
    axis removed. Returns a 0d array when a is 1d or axis=None.
    Returns a reference to the specified output array if specified.

See Also
--------
ndarray.prod : equivalent method

Examples
--------
&gt;&gt;&gt; prod([1.,2.])
2.0
&gt;&gt;&gt; prod([1.,2.], dtype=int32)
2
&gt;&gt;&gt; prod([[1.,2.],[3.,4.]])
24.0
&gt;&gt;&gt; prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="product"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">product</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the product of the array elements over the given axis

Parameters
----------
a : {array_like}
    Array containing elements whose product is desired. If a is not an array, a
    conversion is attempted.
axis : {None, integer}
    Axis over which the product is taken. If None is used, then the
    product is over all the array elements.
dtype : {None, dtype}, optional
    Determines the type of the returned array and of the accumulator
    where the elements are multiplied. If dtype has the value None and
    the type of a is an integer type of precision less than the default
    platform integer, then the default platform integer precision is
    used.  Otherwise, the dtype is the same as that of a.
out : {None, array}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
product_along_axis : {array, scalar}, see dtype parameter above.
    Returns an array whose shape is the same as a with the specified
    axis removed. Returns a 0d array when a is 1d or axis=None.
    Returns a reference to the specified output array if specified.

See Also
--------
ndarray.prod : equivalent method

Examples
--------
&gt;&gt;&gt; product([1.,2.])
2.0
&gt;&gt;&gt; product([1.,2.], dtype=int32)
2
&gt;&gt;&gt; product([[1.,2.],[3.,4.]])
24.0
&gt;&gt;&gt; product([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ptp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ptp</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return (maximum - minimum) along the the given dimension
(i.e. peak-to-peak value).

Parameters
----------
a : array_like
    Input values.
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : array_like
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.ptp(x,0)
array([2, 2])
&gt;&gt;&gt; np.ptp(x,1)
array([1, 1])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="put"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">put</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set a.flat[n] = v[n] for all n in ind.
If v is shorter than ind, it will repeat.

Parameters
----------
a : array_like (contiguous)
    Target array.
ind : array_like
    Target indices, interpreted as integers.
v : array_like
    Values to place in `a` at target indices.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' -- raise an error
    'wrap' -- wrap around
    'clip' -- clip to the range

Notes
-----
If v is shorter than mask it will be repeated as necessary.  In particular v
can be a scalar or length 1 array.  The routine put is the equivalent of the
following (although the loop is in C for speed):

    ind = array(indices, copy=False)
    v = array(values, copy=False).astype(a.dtype)
    for i in ind: a.flat[i] = v[i]

Examples
--------
&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.put(x,[0,2,4],[-1,-2,-3])
&gt;&gt;&gt; print x
[-1  1 -2  3 -3]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="putmask"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">putmask</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">values</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Sets a.flat[n] = values[n] for each n where mask.flat[n] is true.

If values is not the same size as `a` and `mask` then it will repeat.
This gives behavior different from a[mask] = values.

Parameters
----------
a : {array_like}
    Array to put data into
mask : {array_like}
    Boolean mask array
values : {array_like}
    Values to put

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pv</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Number of periods found by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rank"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rank</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the number of dimensions of a.

In old Numeric, rank was the term used for the number of dimensions. If a is
not already an array, a conversion is attempted. Scalars are zero
dimensional.

Parameters
----------
a : {array_like}
    Array whose number of dimensions is desired. If a is not an array, a
    conversion is attempted.

Returns
-------
number_of_dimensions : {integer}
    Returns the number of dimensions.

See Also
--------
ndim : equivalent function
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
&gt;&gt;&gt; rank([[1,2,3],[4,5,6]])
2
&gt;&gt;&gt; rank(array([[1,2,3],[4,5,6]]))
2
&gt;&gt;&gt; rank(1)
0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rate</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Number of periods found by solving the equation
    

                  nper       / (1 + rate*when) \   /        nper     fv + pv*(1+rate)    + pmt*|-------------------|*| (1+rate)    - 1 | = 0
                             \     rate        /   \               /

       fv + pv + pmt * nper = 0  (when rate == 0)

where (all can be scalars or sequences)

    Parameters
    ----------
    rate :
        Rate of interest (per period)
    nper :
        Number of compounding periods
    pmt :
        Payment
    pv :
        Present value
    fv :
        Future value
    when :
        When payments are due ('begin' (1) or 'end' (0))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ravel"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ravel</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a 1d array containing the elements of a (copy only if needed).

Returns the elements of a as a 1d array. The elements in the new array
are taken in the order specified by the order keyword. The new array is
a view of a if possible, otherwise it is a copy.

Parameters
----------
a : {array_like}

order : {'C','F'}, optional
    If order is 'C' the elements are taken in row major order. If order
    is 'F' they are taken in column major order.

Returns
-------
1d_array : {array}

See Also
--------
ndarray.flat : 1d iterator over the array.
ndarray.flatten : 1d array copy of the elements of a in C order.

Examples
--------
&gt;&gt;&gt; x = array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; x
array([[1, 2, 3],
      [4, 5, 6]])
&gt;&gt;&gt; ravel(x)
array([1, 2, 3, 4, 5, 6])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="real"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">real</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the real part of val.

Useful if val maybe a scalar or an array.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="real_if_close"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">real_if_close</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
If a is a complex array, return it as a real array if the imaginary
part is close enough to zero.

&quot;Close enough&quot; is defined as tol*(machine epsilon of a's element type).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="repeat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">repeat</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Repeat elements of an array.

Parameters
----------
a : {array_like}
    Input array.
repeats : {integer, integer_array}
    The number of repetitions for each element. If a plain integer, then
    it is applied to all elements. If an array, it needs to be of the
    same length as the chosen axis.
axis : {None, integer}, optional
    The axis along which to repeat values. If None, then this function
    will operated on the flattened array `a` and return a similarly flat
    result.

Returns
-------
repeated_array : array

See Also
--------
ndarray.repeat : equivalent method
tile : tile an array

Examples
--------
&gt;&gt;&gt; x = array([[1,2],[3,4]])
&gt;&gt;&gt; repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
&gt;&gt;&gt; repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
&gt;&gt;&gt; repeat(x, [1, 2], axis=0)
array([[1, 2],
       [3, 4],
       [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="require"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">require</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return an ndarray of the provided type that satisfies requirements.

This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).

Parameters
----------
 a : array-like
   The object to be converted to a type-and-requirement satisfying array
 dtype : data-type
   The required data-type (None is the default data-type -- float64)
 requirements : list of strings
   The requirements list can be any of the
   'ENSUREARRAY' ('E')  - ensure that  a base-class ndarray
   'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   'ALIGNED' ('A')      - ensure a data-type aligned array
   'WRITEABLE' ('W')    - ensure a writeable array
   'OWNDATA' ('O')      - ensure an array that owns its own data

   The returned array will be guaranteed to have the listed requirements
   by making a copy if needed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="resize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">resize</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a new array with the specified shape.

The original array's total size can be any size.  The new array is
filled with repeated copies of a.

Note that a.resize(new_shape) will fill the array with 0's beyond
current definition of a.

Parameters
----------
a : {array_like}
    Array to be reshaped.

new_shape : {tuple}
    Shape of reshaped array.

Returns
-------
reshaped_array : {array}
    The new array is formed from the data in the old array, repeated if
    necessary to fill out the required number of elements, with the new
    shape.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="roll"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">roll</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Roll the elements in the array by 'shift' positions along
the given axis.

&gt;&gt;&gt; from numpy import roll
&gt;&gt;&gt; arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; roll(arange(10), 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rollaxis"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rollaxis</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return transposed array so that axis is rolled before start.

&gt;&gt;&gt; from numpy import ones, rollaxis
&gt;&gt;&gt; a = ones((3,4,5,6))
&gt;&gt;&gt; rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
&gt;&gt;&gt; rollaxis(a, 2, 0).shape
(5, 3, 4, 6)
&gt;&gt;&gt; rollaxis(a, 1, 4).shape
(3, 5, 6, 4)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="roots"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">roots</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the roots of the polynomial coefficients in p.

The values in the rank-1 array p are coefficients of a polynomial.
If the length of p is n+1 then the polynomial is
p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rot90"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rot90</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
returns the array found by rotating m by k*90
degrees in the counterclockwise direction.  Works on the first two
dimensions of m.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="round_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">round_</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Round a to the given number of decimals.

The real and imaginary parts of complex numbers are rounded separately. The
result of rounding a float is a float so the type must be cast if integers
are desired.  Nothing is done if the input is an integer array and the
decimals parameter has a value &gt;= 0.

Parameters
----------
a : {array_like}
    Array containing numbers whose rounded values are desired. If a is
    not an array, a conversion is attempted.
decimals : {0, integer}, optional
    Number of decimal places to round to. When decimals is negative it
    specifies the number of positions to the left of the decimal point.
out : {None, array}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
rounded_array : {array}
    If out=None, returns a new array of the same type as a containing
    the rounded values, otherwise a reference to the output array is
    returned.

See Also
--------
around : equivalent function
ndarray.round : equivalent method

Notes
-----
Numpy rounds to even. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round
to 0.0, etc. Results may also be surprising due to the inexact
representation of decimal fractions in IEEE floating point and the
errors introduced when scaling by powers of ten.

Examples
--------
&gt;&gt;&gt; round_([.5, 1.5, 2.5, 3.5, 4.5])
array([ 0.,  2.,  2.,  4.,  4.])
&gt;&gt;&gt; round_([1,2,3,11], decimals=1)
array([ 1,  2,  3, 11])
&gt;&gt;&gt; round_([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="row_stack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">row_stack</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Stack arrays in sequence vertically (row wise)

Description:
    Take a sequence of arrays and stack them vertically
    to make a single array.  All arrays in the sequence
    must have the same shape along all but the first axis.
    vstack will rebuild arrays divided by vsplit.
Arguments:
    tup -- sequence of arrays.  All arrays must have the same
           shape.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a = array((1,2,3))
    &gt;&gt;&gt; b = array((2,3,4))
    &gt;&gt;&gt; numpy.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])
    &gt;&gt;&gt; a = array([[1],[2],[3]])
    &gt;&gt;&gt; b = array([[2],[3],[4]])
    &gt;&gt;&gt; numpy.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="safe_eval"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">safe_eval</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.

Parameters
----------
source : str

Returns
-------
obj : object

Raises
------
SyntaxError if the code is invalid Python expression syntax or if it
contains non-literal code.

Examples
--------
&gt;&gt;&gt; from numpy.lib.utils import safe_eval
&gt;&gt;&gt; safe_eval('1')
1
&gt;&gt;&gt; safe_eval('[1, 2, 3]')
[1, 2, 3]
&gt;&gt;&gt; safe_eval('{&quot;foo&quot;: (&quot;bar&quot;, 10.0)}')
{'foo': ('bar', 10.0)}
&gt;&gt;&gt; safe_eval('import os')
Traceback (most recent call last):
  ...
SyntaxError: invalid syntax
&gt;&gt;&gt; safe_eval('open(&quot;/home/user/.ssh/id_dsa&quot;).read()')
Traceback (most recent call last):
  ...
SyntaxError: Unsupported source construct: compiler.ast.CallFunc
&gt;&gt;&gt; safe_eval('dict')
Traceback (most recent call last):
  ...
SyntaxError: Unknown name: dict

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="save"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">save</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Save an array to a binary file (a string or file-like object).

If the file is a string, then if it does not have the .npy extension,
    it is appended and a file open.

Data is saved to the open file in NumPy-array format

Examples
--------
import numpy as np
...
np.save('myfile', a)
a = np.load('myfile.npy')

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="savetxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">savetxt</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Save the data in X to file fname using fmt string to convert the
data to strings

Parameters
----------
fname : filename or a file handle
    If the filename ends in .gz, the file is automatically saved in
    compressed gzip format.  The load() command understands gzipped
    files transparently.
X : array or sequence
    Data to write to file.
fmt : string or sequence of strings
    A single format (%10.5f), a sequence of formats, or a
    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
    case delimiter is ignored.
delimiter : str
    Character separating columns.

Examples
--------
&gt;&gt;&gt; savetxt('test.out', x, delimiter=',') # X is an array
&gt;&gt;&gt; savetxt('test.out', (x,y,z)) # x,y,z equal sized 1D arrays
&gt;&gt;&gt; savetxt('test.out', x, fmt='%1.4e') # use exponential notation

Notes on fmt
------------
flags:
    - : left justify
    + : Forces to preceed result with + or -.
    0 : Left pad the number with zeros instead of space (see width).

width:
    Minimum number of characters to be printed. The value is not truncated.

precision:
    - For integer specifiers (eg. d,i,o,x), the minimum number of
      digits.
    - For e, E and f specifiers, the number of digits to print
      after the decimal point.
    - For g and G, the maximum number of significant digits.
    - For s, the maximum number of charac ters.

specifiers:
    c : character
    d or i : signed decimal integer
    e or E : scientific notation with e or E.
    f : decimal floating point
    g,G : use the shorter of e,E or f
    o : signed octal
    s : string of characters
    u : unsigned decimal integer
    x,X : unsigned hexadecimal integer

This is not an exhaustive specification.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="savez"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">savez</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Save several arrays into an .npz file format which is a zipped-archive
of arrays

If keyword arguments are given, then filenames are taken from the keywords.
If arguments are passed in with no keywords, then stored file names are
arr_0, arr_1, etc.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="searchsorted"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">searchsorted</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return indices where keys in v should be inserted to maintain order.

Find the indices into a sorted array such that if the corresponding keys in
v were inserted before the indices the order of a would be preserved.  If
side='left', then the first such index is returned. If side='right', then
the last such index is returned. If there is no such index because the key
is out of bounds, then the length of a is returned, i.e., the key would need
to be appended. The returned index array has the same shape as v.

Parameters
----------
a : 1-d array
    Array must be sorted in ascending order.
v : array or list type
    Array of keys to be searched for in a.
side : {'left', 'right'}, optional
    If 'left', the index of the first location where the key could be
    inserted is found, if 'right', the index of the last such element is
    returned. If the is no such element, then either 0 or N is returned,
    where N is the size of the array.

Returns
-------
indices : integer array
    Array of insertion points with the same shape as v.

See Also
--------
sort : Inplace sort.
histogram : Produce histogram from 1-d data.

Notes
-----
The array a must be 1-d and is assumed to be sorted in ascending
order.  Searchsorted uses binary search to find the required
insertion points.

Examples
--------
&gt;&gt;&gt; searchsorted([1,2,3,4,5],[6,4,0])
array([5, 3, 0])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="select"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">select</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return an array composed of different elements in choicelist,
depending on the list of conditions.

:Parameters:
    condlist : list of N boolean arrays of length M
        The conditions C_0 through C_(N-1) which determine
        from which vector the output elements are taken.
    choicelist : list of N arrays of length M
        Th vectors V_0 through V_(N-1), from which the output
        elements are chosen.

:Returns:
    output : 1-dimensional array of length M
        The output at position m is the m-th element of the first
        vector V_n for which C_n[m] is non-zero.  Note that the
        output depends on the order of conditions, since the
        first satisfied condition is used.

        Equivalent to:

            output = []
            for m in range(M):
                output += [V[m] for V,C in zip(values,cond) if C[m]]
                          or [default]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_numeric_ops"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_numeric_ops</span>(<span class="sig-arg">op</span>=<span class="sig-default">func</span>,
        <span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set some or all of the number methods for all array objects.  Do not
forget **dict can be used as the argument list.  Return the functions
that were replaced, which can be stored and set later.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_printoptions"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_printoptions</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set options associated with printing.

:Parameters:
    precision : int
        Number of digits of precision for floating point output (default 8).
    threshold : int
        Total number of array elements which trigger summarization
        rather than full repr (default 1000).
    edgeitems : int
        Number of array items in summary at beginning and end of
        each dimension (default 3).
    linewidth : int
        The number of characters per line for the purpose of inserting
        line breaks (default 75).
    suppress : bool
        Whether or not suppress printing of small floating point values
        using scientific notation (default False).
    nanstr : string
        String representation of floating point not-a-number (default nan).
    infstr : string
        String representation of floating point infinity (default inf).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_string_function"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_string_function</span>(<span class="sig-arg">f</span>,
        <span class="sig-arg">repr</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set the python function f to be the function used to obtain a pretty
printable string version of an array whenever an array is printed.
f(M) should expect an array argument M, and should return a string
consisting of the desired representation of M for printing.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setdiff1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setdiff1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set difference of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as inputs
to this function.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
difference : array
    The values in ar1 that are not in ar2.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterr</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set how floating-point errors are handled.

Valid values for each type of error are the strings
&quot;ignore&quot;, &quot;warn&quot;, &quot;raise&quot;, and &quot;call&quot;. Returns the old settings.
If 'all' is specified, values that are not otherwise specified
will be set to 'all', otherwise they will retain their old
values.

Note that operations on integer scalar types (such as int16) are
handled like floating point, and are affected by these settings.

Example:

&gt;&gt;&gt; seterr(over='raise') # doctest: +SKIP
{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}

&gt;&gt;&gt; seterr(all='warn', over='raise') # doctest: +SKIP
{'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}

&gt;&gt;&gt; int16(32000) * int16(3) # doctest: +SKIP
Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in ?
FloatingPointError: overflow encountered in short_scalars
&gt;&gt;&gt; seterr(all='ignore') # doctest: +SKIP
{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterrcall"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterrcall</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set the callback function used when a floating-point error handler
is set to 'call' or the object with a write method for use when
the floating-point error handler is set to 'log'

'func' should be a function that takes two arguments. The first is
type of error (&quot;divide&quot;, &quot;over&quot;, &quot;under&quot;, or &quot;invalid&quot;), and the second
is the status flag (= divide + 2*over + 4*under + 8*invalid).

Returns the old handler.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterrobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterrobj</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Used internally by `seterr`.

Parameters
----------
errobj : list
    [buffer_size, error_mask, callback_func]

See Also
--------
seterrcall

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setmember1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setmember1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a boolean array of shape of ar1 containing True where the elements
of ar1 are in ar2 and False otherwise.

Use unique1d() to generate arrays with only unique elements to use as inputs
to this function.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
mask : bool array
    The values ar1[mask] are in ar2.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setxor1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setxor1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Set exclusive-or of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as inputs
to this function.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
xor : array
    The values that are only in one, but not both, of the input arrays.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="shape"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">shape</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the shape of a.

Parameters
----------
a : {array_like}
    Array whose shape is desired. If a is not an array, a conversion is
    attempted.

Returns
-------
tuple_of_integers :
    The elements of the tuple are the length of the corresponding array
    dimension.

Examples
--------
&gt;&gt;&gt; shape(eye(3))
(3, 3)
&gt;&gt;&gt; shape([[1,2]])
(1, 2)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="size"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">size</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the number of elements along given axis.

Parameters
----------
a : {array_like}
    Array whose axis size is desired. If a is not an array, a
    conversion is attempted.
axis : {None, integer}, optional
    Axis along which the elements are counted. None means all
    elements in the array.

Returns
-------
element_count : {integer}
    Count of elements along specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
&gt;&gt;&gt; a = array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; size(a)
6
&gt;&gt;&gt; size(a,1)
3
&gt;&gt;&gt; size(a,0)
2

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sometrue"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sometrue</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Assert whether some values are true.

`sometrue` performs a logical_or over the given axis.

Parameters
----------
a : array_like
    Array on which to operate.
axis : {None, integer}
    Axis to perform the operation over.
    If `None` (default), perform over flattened array.
out : {None, array}, optional
    Array into which the product can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

See Also
--------
ndarray.any : equivalent method

Examples
--------
&gt;&gt;&gt; b = numpy.array([True, False, True, True])
&gt;&gt;&gt; numpy.sometrue(b)
True
&gt;&gt;&gt; a = numpy.array([1, 5, 2, 7])
&gt;&gt;&gt; numpy.sometrue(a &gt;= 5)
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sort</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return copy of 'a' sorted along the given axis.

Perform an inplace sort along the given axis using the algorithm
specified by the kind keyword.

Parameters
----------
a : array
    Array to be sorted.
axis : {None, int} optional
    Axis along which to sort. None indicates that the flattened
    array should be used.
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
    Sorting algorithm to use.
order : {None, list type}, optional
    When a is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.

Returns
-------
sorted_array : array of same type as a

See Also
--------
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find keys in sorted array.

Notes
-----
The various sorts are characterized by average speed, worst case
performance, need for work space, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:

=========== ======= ============= ============ =======
   kind      speed   worst case    work space  stable
=========== ======= ============= ============ =======
'quicksort'    1     O(n^2)            0          no
'mergesort'    2     O(n*log(n))      ~n/2        yes
'heapsort'     3     O(n*log(n))       0          no
=========== ======= ============= ============ =======

All the sort algorithms make temporary copies of the data when
the sort is not along the last axis. Consequently, sorts along
the last axis are faster and use less space than sorts along
other axis.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sort_complex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sort_complex</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Sort 'a' as a complex array using the real part first and then
the imaginary part if the real part is equal (the default sort order
for complex arrays).  This function is a wrapper ensuring a complex
return type.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="split"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">split</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Divide an array into a list of sub-arrays.

Description:
   Divide ary into a list of sub-arrays along the
   specified axis.  If indices_or_sections is an integer,
   ary is divided into that many equally sized arrays.
   If it is impossible to make an equal split, an error is
   raised.  This is the only way this function differs from
   the array_split() function. If indices_or_sections is a
   list of sorted integers, its entries define the indexes
   where ary is split.

Arguments:
   ary -- N-D array.
      Array to be divided into sub-arrays.
   indices_or_sections -- integer or 1D array.
      If integer, defines the number of (close to) equal sized
      sub-arrays.  If it is a 1D array of sorted indices, it
      defines the indexes at which ary is divided.  Any empty
      list results in a single sub-array equal to the original
      array.
   axis -- integer. default=0.
      Specifies the axis along which to split ary.
Caveats:
   Currently, the default for axis is 0.  This
   means a 2D array is divided into multiple groups
   of rows.  This seems like the appropriate default

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="squeeze"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">squeeze</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Remove single-dimensional entries from the shape of a.

Examples
--------
&gt;&gt;&gt; x = array([[[1,1,1],[2,2,2],[3,3,3]]])
&gt;&gt;&gt; x.shape
(1, 3, 3)
&gt;&gt;&gt; squeeze(x).shape
(3, 3)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="swapaxes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">swapaxes</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return a view of array a with axis1 and axis2 interchanged.

Parameters
----------
a : array_like
    Input array.
axis1 : int
    First axis.
axis2 : int
    Second axis.

Examples
--------
&gt;&gt;&gt; x = np.array([[1,2,3]])
&gt;&gt;&gt; np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])

&gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
&gt;&gt;&gt; x
array([[[0, 1],
        [2, 3]],

       [[4, 5],
        [6, 7]]])
&gt;&gt;&gt; np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],

       [[1, 5],
        [3, 7]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="take"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">take</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return an array formed from the elements of a at the given indices.

This function does the same thing as &quot;fancy&quot; indexing; however, it can
be easier to use if you need to specify a given axis.

Parameters
----------
a : array
    The source array
indices : int array
    The indices of the values to extract.
axis : {None, int}, optional
    The axis over which to select values. None signifies that the
    operation should be performed over the flattened array.
out : {None, array}, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' -- raise an error
    'wrap' -- wrap around
    'clip' -- clip to the range

Returns
-------
subarray : array
    The returned array has the same type as a.

See Also
--------
ndarray.take : equivalent method

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tensordot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tensordot</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
tensordot returns the product for any (ndim &gt;= 1) arrays.

r_{xxx, yyy} = \sum_k a_{xxx,k} b_{k,yyy} where

the axes to be summed over are given by the axes argument.
the first element of the sequence determines the axis or axes
in arr1 to sum over, and the second element in axes argument sequence
determines the axis or axes in arr2 to sum over.

When there is more than one axis to sum over, the corresponding
arguments to axes should be sequences of the same length with the first
axis to sum over given first in both sequences, the second axis second,
and so forth.

If the axes argument is an integer, N, then the last N dimensions of a
and first N dimensions of b are summed over.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tile</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Repeat an array the number of times given in the integer tuple, reps.

If reps has length d, the result will have dimension of max(d, A.ndim).
If reps is scalar it is treated as a 1-tuple.

If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new axes.
So a shape (3,) array is promoted to (1,3) for 2-D replication,
or shape (1,1,3) for 3-D replication.
If this is not the desired behavior, promote A to d-dimensions manually
before calling this function.

If d &lt; A.ndim, tup is promoted to A.ndim by pre-pending 1's to it.  Thus
for an A.shape of (2,3,4,5), a tup of (2,2) is treated as (1,1,2,2)


Examples:
&gt;&gt;&gt; a = array([0,1,2])
&gt;&gt;&gt; tile(a,2)
array([0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; tile(a,(1,2))
array([[0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; tile(a,(2,2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; tile(a,(2,1,2))
array([[[0, 1, 2, 0, 1, 2]],
&lt;BLANKLINE&gt;
       [[0, 1, 2, 0, 1, 2]]])

See Also:
   repeat

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trace"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trace</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Return the sum along diagonals of the array.

If a is 2-d, returns the sum along the diagonal of self with the given offset, i.e., the
collection of elements of the form a[i,i+offset]. If a has more than two
dimensions, then the axes specified by axis1 and axis2 are used to determine
the 2-d subarray whose trace is returned. The shape of the resulting
array can be determined by removing axis1 and axis2 and appending an index
to the right equal to the size of the resulting diagonals.

Parameters
----------
a : {array_like}
    Array from whis the diagonals are taken.
offset : {0, integer}, optional
    Offset of the diagonal from the main diagonal. Can be both positive
    and negative. Defaults to main diagonal.
axis1 : {0, integer}, optional
    Axis to be used as the first axis of the 2-d subarrays from which
    the diagonals should be taken. Defaults to first axis.
axis2 : {1, integer}, optional
    Axis to be used as the second axis of the 2-d subarrays from which
    the diagonals should be taken. Defaults to second axis.
dtype : {None, dtype}, optional
    Determines the type of the returned array and of the accumulator
    where the elements are summed. If dtype has the value None and a is
    of integer type of precision less than the default integer
    precision, then the default integer precision is used. Otherwise,
    the precision is the same as that of a.
out : {None, array}, optional
    Array into which the sum can be placed. Its type is preserved and
    it must be of the right shape to hold the output.

Returns
-------
sum_along_diagonals : array
    If a is 2-d, a 0-d array containing the diagonal is
    returned.  If a has larger dimensions, then an array of
    diagonals is returned.

Examples
--------
&gt;&gt;&gt; trace(eye(3))
3.0
&gt;&gt;&gt; a = arange(8).reshape((2,2,2))
&gt;&gt;&gt; trace(a)
array([6, 8])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trapz"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trapz</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Integrate y(x) using samples along the given axis and the composite
trapezoidal rule.  If x is None, spacing given by dx is assumed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tril"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tril</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
returns the elements on and below the k-th diagonal of m.  k=0 is the
main diagonal, k &gt; 0 is above and k &lt; 0 is below the main diagonal.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trim_zeros"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trim_zeros</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Trim the leading and trailing zeros from a 1D array.

Examples
--------
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; a = array((0, 0, 0, 1, 2, 3, 2, 1, 0))
&gt;&gt;&gt; numpy.trim_zeros(a)
array([1, 2, 3, 2, 1])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="triu"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">triu</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
returns the elements on and above the k-th diagonal of m.  k=0 is the
main diagonal, k &gt; 0 is above and k &lt; 0 is below the main diagonal.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ufunc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ufunc</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Functions that operate element by element on whole arrays.

Unary ufuncs:
=============

op(X, out=None)
Apply op to X elementwise

Parameters
----------
X : array-like
out : array-like
    An array to store the output. Must be the same shape as X.

Returns
-------
r : array-like
    r will have the same shape as X; if out is provided, r will be
    equal to out.

Binary ufuncs:
==============

op(X, Y, out=None)
Apply op to X and Y elementwise. May &quot;broadcast&quot; to make
the shapes of X and Y congruent.

The broadcasting rules are:
* Dimensions of length 1 may be prepended to either array
* Arrays may be repeated along dimensions of length 1

Parameters
----------
X : array-like
Y : array-like
out : array-like
    An array to store the output. Must be the same shape as the
    output would have.

Returns
-------
r : array-like
    The return value; if out is provided, r will be equal to out.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="union1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">union1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Union of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as inputs
to this function.

Parameters
----------
ar1 : array
ar2 : array

Returns
-------
union : array

See also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unique"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unique</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Return sorted unique items from an array or sequence.

Examples
--------
&gt;&gt;&gt; numpy.unique([5,2,4,0,4,4,2,2,1])
array([0, 1, 2, 4, 5])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unique1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unique1d</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Find the unique elements of 1D array.

Most of the other array set operations operate on the unique arrays
generated by this function.

Parameters
----------
ar1 : array
    This array will be flattened if it is not already 1D.
return_index : bool, optional
    If True, also return the indices against ar1 that result in the unique
    array.

Returns
-------
unique : array
    The unique values.
unique_indices : int array, optional
    The indices of the unique values. Only provided if return_index is True.

See Also
--------
  numpy.lib.arraysetops : Module with a number of other functions
                          for performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unravel_index"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unravel_index</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Convert a flat index into an index tuple for an array of given shape.

e.g. for a 2x2 array, unravel_index(2,(2,2)) returns (1,0).

Example usage:
  p = x.argmax()
  idx = unravel_index(p,x.shape)
  x[idx] == x.max()

Note:  x.flat[p] == x.max()

  Thus, it may be easier to use flattened indexing than to re-map
  the index to a tuple.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vander"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vander</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">

Generate the Vandermonde matrix of vector x.

The i-th column of X is the the (N-i)-1-th power of x.  N is the
maximum power to compute; if N is None it defaults to len(x).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vdot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vdot</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Returns the dot product of a and b for scalars and vectors
of floating point and complex types.  The first argument, a, is conjugated.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vectorize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vectorize</span>(<span class="sig-arg">somefunction</span>,
        <span class="sig-arg">otypes</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">doc</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Generalized function class.

Define a vectorized function which takes nested sequence
of objects or numpy arrays as inputs and returns a
numpy array as output, evaluating the function over successive
tuples of the input arrays like the python map function except it uses
the broadcasting rules of numpy.

Data-type of output of vectorized is determined by calling the function
with the first element of the input.  This can be avoided by specifying
the otypes argument as either a string of typecode characters or a list
of data-types specifiers.  There should be one data-type specifier for
each output.

Parameters
----------
f : callable
  A Python function or method.

Examples
--------
&gt;&gt;&gt; def myfunc(a, b):
...    if a &gt; b:
...        return a-b
...    else:
...        return a+b

&gt;&gt;&gt; vfunc = vectorize(myfunc)

&gt;&gt;&gt; vfunc([1, 2, 3, 4], 2)
array([3, 4, 1, 2])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vsplit</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Split ary into multiple rows of sub-arrays

Description:
    Split a single array into multiple sub arrays.  The array is
    divided into groups of rows.  If indices_or_sections is
    an integer, ary is divided into that many equally sized sub arrays.
    If it is impossible to make the sub-arrays equally sized, the
    operation throws a ValueError exception. See array_split and
    split for other options on indices_or_sections.
Arguments:
   ary -- N-D array.
      Array to be divided into sub-arrays.
   indices_or_sections -- integer or 1D array.
      If integer, defines the number of (close to) equal sized
      sub-arrays.  If it is a 1D array of sorted indices, it
      defines the indexes at which ary is divided.  Any empty
      list results in a single sub-array equal to the original
      array.
Returns:
    sequence of sub-arrays.  The returned arrays have the same
    number of dimensions as the input array.
Caveats:
   How should we handle 1D arrays here?  I am currently raising
   an error when I encounter them.  Any better approach?

   Should we reduce the returned array to their minium dimensions
   by getting rid of any dimensions that are 1?
Related:
    vstack, split, array_split, hsplit, dsplit.
Examples:
    import numpy
    &gt;&gt;&gt; a = array([[1,2,3,4],
    ...            [1,2,3,4]])
    &gt;&gt;&gt; numpy.vsplit(a,2)
    [array([[1, 2, 3, 4]]), array([[1, 2, 3, 4]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vstack</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
Stack arrays in sequence vertically (row wise)

Description:
    Take a sequence of arrays and stack them vertically
    to make a single array.  All arrays in the sequence
    must have the same shape along all but the first axis.
    vstack will rebuild arrays divided by vsplit.
Arguments:
    tup -- sequence of arrays.  All arrays must have the same
           shape.
Examples:
    &gt;&gt;&gt; import numpy
    &gt;&gt;&gt; a = array((1,2,3))
    &gt;&gt;&gt; b = array((2,3,4))
    &gt;&gt;&gt; numpy.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])
    &gt;&gt;&gt; a = array([[1],[2],[3]])
    &gt;&gt;&gt; b = array([[2],[3],[4]])
    &gt;&gt;&gt; numpy.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="where"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">where</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </table>
  
  <pre class="literalblock">
where(condition, x, y) or where(condition)

Return elements from `x` or `y`, depending on `condition`.

Parameters
----------
condition : array of bool
    When True, yield x, otherwise yield y.
x,y : 1-dimensional arrays
    Values from which to choose.

Notes
-----
This is equivalent to

    [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]

The result is shaped like `condition` and has elements of `x`
or `y` where `condition` is respectively True or False.

In the special case, where only `condition` is given, the
tuple condition.nonzero() is returned, instead.

Examples
--------
&gt;&gt;&gt; where([True,False,True],[1,2,3],[4,5,6])
array([1, 5, 3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="brian-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0beta1 on Wed Aug 13 17:37:25 2008
    </td>
    <td align="right" class="footer">
      <a href="http://epydoc.sourceforge.net">http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie()
  // -->
</script>
  
</body>
</html>
