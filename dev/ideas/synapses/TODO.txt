TODO (Synapses)
---------------
* Synapses.compress():
	raise warning if there are no synapses
	precompute offsets (perhaps precompute unless it produces a memory error)
	calculate max delay (with option for specifying it, to allow dynamic delays)
	perhaps replace dynamic arrays by arrays
* Synapses.generate_code: check if postsynaptic variables are modified
* More careful namespace creation in Synapses.update()(see reset/threshold)
* SpikeQueue callback (to Synapses): this way the clock is only for state updates
* Bound checks in setitem/getitem
* pre/post code should include rand()
* Factor things in code generation
* Faster queue: C version of propagate or insert?
* Faster Synapses.update()
* Synapses with same underlying data (synaptic variables) as another Synapses object (for delayed STDP)
* setattr (S.w=...)
* State updates and event-driven stuff
* Replace spike queue data with a dynamic array object?
* Replace NeuronGroup.__init__ with own stuff
* include static variables in pre/post code
* have a list of variable names
* deal with suffixes (v_post, v_pre)
* S[:,:]='i<j'
* S[:,:]=array (boolean or int)
* generate synapses_post from postsynaptic (for connect_random)
* S.connect_random: fixed number of presynaptic neurons
* S.connect_one_to_one (or 'i==j')
* Update: Have namespaces partially built at run time (call state_(var)),
  or better, extract synaptic events from the synaptic state matrix;
  same stuff for postsynaptic variables
* S[2,3:5]=(2,3) # 2 synapses from 2 to 3, 3 from 2 to 4
* S[group1,group2]='rand()<0.2' # careful this is highly inefficient
* StateMonitor
