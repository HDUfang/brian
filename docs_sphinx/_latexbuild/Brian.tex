% Generated by Sphinx.
\documentclass[letterpaper,10pt]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\title{Brian Documentation}
\date{September 23, 2008}
\release{1.0.0}
\author{Romain Brette, Dan Goodman}
\newcommand{\sphinxlogo}{}

\makeindex
\makemodindex
\newcommand\at{@}
\newcommand\lb{[}
\newcommand\rb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaH[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaI[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaM[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
%% Check if we are compiling under latex or pdflatex.
\ifx\pdftexversion\undefined
  \usepackage{graphicx}
\else
  \usepackage[pdftex]{graphicx}
\fi


\begin{document}
\maketitle
\tableofcontents



\declaremodule[brian]{}{brian}
\modulesynopsis{The Brian package}
The manual for Brian is not yet entirely complete, we are working on filling in the gaps signposted `TODO'.
See also the automatically generated \href{http://brian.di.ens.fr/docs/api/}{API documentation} and
the \href{http://brian.di.ens.fr//BrianReference.pdf}{reference sheet}. You can also download a PDF
version of the documentation \href{http://brian.di.ens.fr/docs/Brian.pdf}{here}.

\resetcurrentobjects


\chapter{Introduction}

Brian is a clock driven simulator for spiking neural networks, written in the \href{http://www.python.org}{Python} programming language.

The simulator is written almost entirely in Python. The idea is that
it can be used at various levels
of abstraction without the steep learning curve of software like \href{http://www.neuron.yale.edu/neuron/}{Neuron}, where you have to learn their
own programming language to extend their models. As a language, Python is well suited to this task
because it is easy to learn, well known and supported, and allows a great deal of flexibility in usage
and in designing interfaces and abstraction mechanisms. As an interpreted language, and therefore slower
than say C++, Python is not the obvious choice for writing a computationally demanding scientific
application. However, the \href{http://www.scipy.org/}{SciPy} module for Python provides very efficient linear algebra routines, which
means that vectorised code can be very fast.

Here's what the Python web site has to say about themselves:
\begin{quote}

Python is an easy to learn, powerful programming language. It has efficient
high-level data structures and a simple but effective approach to
object-oriented programming. Python's elegant syntax and dynamic typing,
together with its interpreted nature, make it an ideal language for
scripting and rapid application development in many areas on most platforms.

The Python interpreter and the extensive standard library are freely
available in source or binary form for all major platforms from the
Python Web site, \href{http://www.python.org/}{http://www.python.org/}, and may be freely distributed.
The same site also contains distributions of and pointers to many free
third party Python modules, programs and tools, and additional documentation.
\end{quote}

As an example of the ease of use and clarity of programs written in Brian, the following script defines
and runs a randomly connected network of 4000 integrate and fire neurons with exponential currents:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad[''']
P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,reset@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV)
P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]@PYGaw[1.62]@PYGbe[*]mV)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)
M@PYGbe[=]SpikeMonitor(P,@PYGaA[True])
run(@PYGaw[1]@PYGbe[*]second)
raster_plot(M)
show()
\end{Verbatim}

As an example of the output of Brian, the following two images reproduce figures from Diesmann et al. 1999
on synfire chains. The first is a raster plot of a synfire chain showing the stabilisation of the chain.

\includegraphics{synfirechain-example.jpg}

The simulation of 1000 neurons in 10 layers, each all-to-all connected to the next, using integrate and fire
neurons with synaptic noise for 100ms of simulated time took 1 second to run with a timestep of 0.1ms on a
2.4GHz Intel Xeon dual-core processor. The next image is of the state space, figure 3:

\includegraphics{sfc-statespace.jpg}

The figure computed 50 averages for each of 121 starting points over 100ms at a timestep of 0.1ms and took
201s to run on the same processor as above.

\resetcurrentobjects


\chapter{Installation}

If you already have a copy of Python 2.5 or 2.6, try the Quick installation below,
otherwise take a look at Manual installation.


\section{Quick installation}

The easiest way to install Brian if you already have a version of Python 2.5 or 2.6 including the
\code{easy\_install} script is to simply run the following in a shell:

\begin{Verbatim}[commandchars=@\[\]]
easy_install brian
\end{Verbatim}

This will download and install Brian and all its required packages (NumPy, SciPy, etc.).


\section{Manual installation}

Installing Brian requires the following components:
\begin{enumerate}
\item {} 
\href{http://www.python.org/download/}{Python} version 2.5 or 2.6.

\item {} 
\href{http://www.scipy.org/Download}{NumPy and Scipy} packages for Python:
an efficient scientific library.

\item {} 
\href{http://matplotlib.sourceforge.net/}{PyLab} package for Python:
a plotting library similar to Matlab
(see the \href{http://matplotlib.sourceforge.net/installing.html}{detailed installation instructions}).

\item {} 
\href{http://code.google.com/p/sympy/}{SymPy} package for Python:
a library for symbolic mathematics (not mandatory yet for Brian).

\item {} 
Brian itself (don't forget to download the extras.zip file,
which includes examples, tutorials, and a complete copy of the documentation).
Download the latest release: file ending \code{.win32.exe} for Windows,
filenames ending \code{.tar.gz} or \code{.zip} for other operating systems.
Brian is also a Python package and can be installed as explained below.

\end{enumerate}

Fortunately, Python packages are very quick and easy to install, so the whole process shouldn't
take very long.

We also recommend using the following for writing programs in Python (see details below):
\begin{enumerate}
\item {} 
\href{http://www.eclipse.org/}{Eclipse} IDE with \href{http://pydev.sourceforge.net/}{PyDev}

\item {} 
\href{http://ipython.scipy.org/moin/}{IPython} shell

\end{enumerate}

Finally, if you want to use the (optional) automatic C++ code generation features of Brian, you should
have the \code{gcc} compiler installed (on \href{http://www.cygwin.com/}{Cygwin} if you are
running on Windows).

Mac users: the \href{http://trichech.us/?page\_id=5}{Scipy Superpack for Intel OS X} includes
recent versions of Numpy, Scipy, Pylab and IPython.


\subsection{Installing Python packages}

On Windows, Python packages (including Brian) are generally installed simply by running an .exe file.
On other operating systems, you can download the source release (typically a compressed
archive .tar.gz or .zip that you need to unzip) and then install the package by typing the following in your
shell:

\begin{Verbatim}[commandchars=@\[\]]
python setup.py install
\end{Verbatim}


\subsection{Installing Eclipse}

Eclipse is an Integrated Development Environment (IDE) for any programming language. PyDev is a plugin
for Eclipse with features specifically for Python development. The combination of these two is
excellent for Python development (it's what we use for writing Brian).

To install Eclipse, go to \href{http://www.eclipse.org/}{their web page} and download any of the base
language IDEs. It doesn't matter which one, but Python is not one of the base languages so you have
to choose an alternative language. Probably the most useful is the C++ one or the Java one. The C++
one can be downloaded \href{http://www.eclipse.org/cdt/downloads.php}{here}.

Having downloaded and installed Eclipse, you should download and install the PyDev plugin from
\href{http://pydev.sourceforge.net/}{their web site}. The best way to do this is directly from within
the Eclipse IDE. Follow the instructions on the \href{http://www.fabioz.com/pydev/manual\_101\_root.html}{PyDev manual page}.


\subsection{Installing IPython}

\href{http://ipython.scipy.org/moin/}{IPython} is an interactive shell for Python.
It has features for SciPy and PyLab built in, so it is a good choice for scientific work.
Download from \href{http://ipython.scipy.org/moin/Download}{their page}. If you are using Windows, you
will also need to download PyReadline from the same page.


\subsection{C++ compilers}

The default for Brian is to use the \code{gcc} compiler which will
be installed already on most unix or linux distributions. If you are using Windows, you can
install \href{http://www.cygwin.com/}{cygwin} (make sure to include the \code{gcc} package). Alternatively,
some but not all versions of Microsoft Visual C++ should be compatible, but this is untested
so far. See the documentation for the \href{http://www.scipy.org/Weave}{SciPy Weave} package for
more information on this.


\section{Testing}

You can test whether Brian has installed properly by running Python and typing
the following two lines:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
run_all_tests()
\end{Verbatim}

A series of tests should run and return `ok' for each one. If not, and all of the packages other than
Brian work OK, please let us know.

\resetcurrentobjects


\chapter{Getting started}

\resetcurrentobjects


\section{Tutorials}

These tutorials cover some basic topics in writing Brian scripts in Python. The
complete source code for the tutorials is available in the tutorials folder
in the extras package.

\resetcurrentobjects


\subsection{Tutorials for Python and Scipy}


\subsubsection{Python}

The first thing to do in learning how to use Brian
is to have a basic grasp of the Python programming language.
There are lots of good tutorials already out there. The best one is probably
\href{http://docs.python.org/tut/}{the official Python tutorial}.
There is also a course for biologists at the Pasteur Institute:
\href{http://www.pasteur.fr/formation/infobio/python/}{Introduction to programming using Python}.


\subsubsection{NumPy, SciPy and Pylab}

Unfortunately, the quality of the documentation and tutorials for SciPy lags a
long way behind the quality of the package itself. For the moment, the first
place to look is the SciPy \href{http://www.scipy.org/Getting\_Started}{getting started} page, and then the \href{http://www.scipy.org/Documentation}{complete documentation} page. To start using Brian, you do not need
to understand much about how NumPy and SciPy work, although understanding how their
array structures work will be useful for more advanced uses of Brian.

The syntax of the Numpy and Pylab functions is very similar to Matlab.
If you already know Matlab, you could read this tutorial:
\href{http://scipy.org/NumPy\_for\_Matlab\_Users}{NumPy for Matlab users}
and this list of \href{http://mathesaurus.sourceforge.net/}{Matlab-Python translations}
(\href{http://brian.di.ens.fr/matlab-python-xref.pdf}{pdf version here}).
A \href{http://matplotlib.sourceforge.net/tutorial.html}{tutorial} is also available on
the web site of Pylab.

\resetcurrentobjects


\hypertarget{tutorial1-basic-concepts}{}\subsection{Tutorial 1: Basic Concepts}

In this tutorial, we introduce some of the basic concepts of a Brian simulation:
\begin{itemize}
\item {} 
Importing the Brian module into Python

\item {} 
Using quantities with units

\item {} 
Defining a neuron model by its differential equation

\item {} 
Creating a group of neurons

\item {} 
Running a network

\item {} 
Looking at the output of the network

\item {} 
Modifying the state variables of the network directly

\item {} 
Defining the network structure by connecting neurons

\item {} 
Doing a raster plot of the output

\item {} 
Plotting the membrane potential of an individual neuron

\end{itemize}

The following Brian classes will be introduced:
\begin{itemize}
\item {} 
\hyperlink{brian.Model}{\code{Model}}

\item {} 
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}

\item {} 
\hyperlink{brian.Connection}{\code{Connection}}

\item {} 
\hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}}

\item {} 
\hyperlink{brian.StateMonitor}{\code{StateMonitor}}

\end{itemize}

We will build a Brian program that defines a randomly connected network of integrate
and fire neurons and plot its output.

This tutorial assumes you know:
\begin{itemize}
\item {} 
The very basics of Python, the \code{import} keyword, variables, basic
arithmetical expressions, calling functions, lists

\item {} 
The simplest leaky integrate and fire neuron model

\end{itemize}

The best place to start learning Python is the official tutorial:
\begin{quote}

\href{http://docs.python.org/tut/}{http://docs.python.org/tut/}
\end{quote}

\textbf{Tutorial contents}

\resetcurrentobjects


\subsubsection{Tutorial 1a: The simplest Brian program}


\paragraph{Importing the Brian module}

The first thing to do in any Brian program is to load Brian and the names of
its functions and classes. The standard way to do this is to use the Python
\code{from ... import *} statement.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
\end{Verbatim}
\end{quote}


\paragraph{Integrate and Fire model}

The neuron model we will use in this tutorial is the simplest possible
leaky integrate and fire neuron, defined by the differential equation:
\begin{quote}

tau dV/dt = -(V-El)
\end{quote}

and with a threshold value Vt and reset value Vr.


\paragraph{Parameters}

Brian has a system for defining physical quantities (quantities with
a physical dimension such as time). The code below illustrates how
to use this system, which (mostly) works just as you'd expect.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]
\end{Verbatim}
\end{quote}

The built in standard units in Brian consist of all the fundamental
SI units like second and metre, along with a selection of derived
SI units such as volt, farad, coulomb. All names are lowercase
following the SI standard. In addition, there are scaled versions
of these units using the standard SI prefixes m=1/1000, K=1000, etc.


\paragraph{Neuron model and equations}

The simplest way to define a neuron model in Brian is to write a list
of the differential equations that define it. For the moment, we'll just
give the simplest possible example, a single differential equation. You
write it in the following form:

\begin{Verbatim}[commandchars=@\[\]]
dx/dt = f(x) : unit
\end{Verbatim}

where \code{x} is the name of the variable, \code{f(x)} can be any valid Python
expression, and \code{unit} is the physical units of the variable \code{x}. In our
case we will write:

\begin{Verbatim}[commandchars=@\[\]]
dV/dt = -(V-El)/tau : volt
\end{Verbatim}

to define the variable \code{V} with units \code{volt}.

To complete the specification of the model, we also define a threshold and reset
value.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)
\end{Verbatim}
\end{quote}

The statement creates a new object `model' which is an instance of the
Brian class \hyperlink{brian.Model}{\code{Model}}, initialised with the values in the
line above. In Python, you can call a function or initialise
a class using keyword arguments as well as ordered arguments, so
if I defined a function \code{f(x,y)} I could call it as \code{f(1,2)} or
as \code{f(y=2,x=1)} and get the same effect. See the Python tutorial
for more information on this.


\paragraph{Group of neurons}

We create a group of 40 neurons with the model defined above.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)
\end{Verbatim}
\end{quote}

The \code{N} keyword gives the number of neurons in the group and the
\code{model} keyword is used to pass the neuron model.

For the moment, we leave the networks in this group unconnected
to each other, each evolves separately from the others.


\paragraph{Simulation}

Finally, we run the simulation for 1 second of simulated time.
By default, the simulator uses a timestep dt = 0.1 ms.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}
\end{quote}

And that's it! To see some of the output of this network, go
to the next part of the tutorial.


\paragraph{Exercise}

The units system of Brian is useful for ensuring that everything
is consistent, and that you don't make hard to find mistakes in
your code by using the wrong units. Try changing the units of one
of the parameters and see what happens.


\paragraph{Solution}

You should see an error message with a Python traceback (telling
you which functions were being called when the error happened),
ending in a line something like:

\begin{Verbatim}[commandchars=@\[\]]
Brian.units.DimensionMismatchError: The differential equations
are not homogeneous!, dimensions were (m^2 kg s^-3 A^-1)
(m^2 kg s^-4 A^-1)
\end{Verbatim}

\resetcurrentobjects


\subsubsection{Tutorial 1b: Counting spikes}

In the previous part of the tutorial we looked at the following:
\begin{itemize}
\item {} 
Importing the Brian module into Python

\item {} 
Using quantities with units

\item {} 
Defining a neuron model by its differential equation

\item {} 
Creating a group of neurons

\item {} 
Running a network

\end{itemize}

In this part, we move on to looking at the output of the network.

The first part of the code is the same.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]

model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)
\end{Verbatim}
\end{quote}


\paragraph{Counting spikes}

Now we would like to have some idea of what this network is
doing. In Brian, we use monitors to keep track of the behaviour
of the network during the simulation. The simplest monitor of
all is the \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}}, which just records the spikes from a
given \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
M @PYGbe[=] SpikeMonitor(G)
\end{Verbatim}
\end{quote}


\paragraph{Results}

Now we run the simulation as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}
\end{quote}

And finally, we print out how many spikes there were:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] M@PYGbe[.]nspikes
\end{Verbatim}
\end{quote}

So what's going on? Why are there 40 spikes? Well, the answer is
that the initial value of the membrane potential for every neuron
is 0 mV, which is above the threshold potential of -50 mV and so there
is an initial spike at t=0 and then it resets to -60 mV and stays there,
below the threshold potential. In the next part of this tutorial, we'll
make sure there are some more spikes to see.

\resetcurrentobjects


\subsubsection{Tutorial 1c: Making some activity}

In the previous part of the tutorial we found that each neuron
was producing only one spike. In this part, we alter the model so
that some more spikes will be generated. What we'll do is alter
the resting potential \code{El} so that it is above threshold, this
will ensure that some spikes are generated. The first few
lines remain the same:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
\end{Verbatim}
\end{quote}

But we change the resting potential to -49 mV, just above the
spike threshold:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
El  @PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]
\end{Verbatim}
\end{quote}

And then continue as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)

M @PYGbe[=] SpikeMonitor(G)

run(@PYGaw[1]@PYGbe[*]second)

@PYGay[print] M@PYGbe[.]nspikes
\end{Verbatim}
\end{quote}

Running this program gives the output \code{840}. That's because
every neuron starts at the same initial value and proceeds
deterministically, so that each neuron fires at exactly the
same time, in total 21 times during the 1s of the run.

In the next part, we'll introduce a random element into the
behaviour of the network.


\paragraph{Exercises}
\begin{enumerate}
\item {} 
Try varying the parameters and seeing how the number of
spikes generated varies.

\item {} 
Solve the differential equation by hand and compute a
formula for the number of spikes generated. Compare this
with the program output and thereby partially verify it.
(Hint: each neuron starts at above the threshold and so
fires a spike immediately.)

\end{enumerate}


\paragraph{Solution}

Solving the differential equation gives:
\begin{quote}

V = El + (Vr-El) exp (-t/tau)
\end{quote}

Setting V=Vt at time t gives:
\begin{quote}

t = tau log( (Vr-El) / (Vt-El) )
\end{quote}

If the simulator runs for time T, and fires a spike immediately
at the beginning of the run it will then generate n spikes,
where:
\begin{quote}

n = {[}T/t{]} + 1
\end{quote}

If you have m neurons all doing the same thing, you get nm
spikes. This calculation with the parameters above gives:
\begin{quote}

t = 48.0 ms
n = 21
nm = 840
\end{quote}

As predicted.

\resetcurrentobjects


\subsubsection{Tutorial 1d: Introducing randomness}

In the previous part of the tutorial, all the neurons start
at the same values and proceed deterministically, so they all
spike at exactly the same times. In this part, we introduce
some randomness by initialising all the membrane potentials
to uniform random values between the reset and threshold
values.

We start as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]

model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)

M @PYGbe[=] SpikeMonitor(G)
\end{Verbatim}
\end{quote}

But before we run the simulation, we set the values of the
membrane potentials directly. The notation \code{G.V} refers
to the array of values for the variable \code{V} in group \code{G}. In
our case, this is an array of length 40. We set its values
by generating an array of random numbers using Brian's
\code{rand} function. The syntax is \code{rand(size)} generates an
array of length \code{size} consisting of uniformly distributed
random numbers in the interval 0, 1.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G@PYGbe[.]V@PYGbe[=]Vr@PYGbe[+]rand(@PYGaw[40])@PYGbe[*](Vt@PYGbe[-]Vr)
\end{Verbatim}
\end{quote}

And now we run the simulation as before.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[1]@PYGbe[*]second)

@PYGay[print] M@PYGbe[.]nspikes
\end{Verbatim}
\end{quote}

But this time we get a varying number of spikes each time
we run it, roughly between 800 and 850 spikes. In the
next part of this tutorial, we introduce a bit more
interest into this network by connecting the neurons together.

\resetcurrentobjects


\subsubsection{Tutorial 1e: Connecting neurons}

In the previous parts of this tutorial, the neurons are
still all unconnected. We add in connections here. The
model we use is that when neuron i is connected to
neuron j and neuron i fires a spike, then the membrane
potential of neuron j is instantaneously increased by
a value \code{psp}. We start as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]
\end{Verbatim}
\end{quote}

Now we include a new parameter, the PSP size:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
psp @PYGbe[=] @PYGaw[0.5]@PYGbe[*]mvolt         @PYGaD[# postsynaptic potential size]
\end{Verbatim}
\end{quote}

And continue as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)
\end{Verbatim}
\end{quote}


\paragraph{Connections}

We now proceed to connect these neurons. Firstly, we declare
that there is a connection from neurons in \code{G} to neurons in \code{G}.
For the moment, this is just something that is necessary to
do, the reason for doing it this way will become clear in the
next tutorial.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(G,G)
\end{Verbatim}
\end{quote}

Now the interesting part, we make these neurons be randomly
connected with probability 0.1 and weight \code{psp}. Each neuron
i in \code{G} will be connected to each neuron j in \code{G}
with probability 0.1. The weight of the connection is the
amount that is added to the membrane potential of the target
neuron when the source neuron fires a spike.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
C@PYGbe[.]connect_random(G,G,@PYGaw[0.1],weight@PYGbe[=]psp)
\end{Verbatim}
\end{quote}

Now we continue as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
M @PYGbe[=] SpikeMonitor(G)

G@PYGbe[.]V@PYGbe[=]Vr@PYGbe[+]rand(@PYGaw[40])@PYGbe[*](Vt@PYGbe[-]Vr)

run(@PYGaw[1]@PYGbe[*]second)

@PYGay[print] M@PYGbe[.]nspikes
\end{Verbatim}
\end{quote}

You can see that the number of spikes has jumped from around
800-850 to around 1000-1200. In the next part of the tutorial,
we'll look at a way to plot the output of the network.


\paragraph{Exercise}

Try varying the parameter \code{psp} and see what happens. How large
can you make the number of spikes output by the network? Why?


\paragraph{Solution}

The logically maximum number of firings is
400,000 = 40 * 1000 / 0.1, the number of neurons in the
network * the time it runs for / the integration step size (you
cannot have more than one spike per step).

In fact, the number of firings is bounded above by 200,000. The
reason for this is that the network updates in the following way:
\begin{enumerate}
\item {} 
Integration step

\item {} 
Find neurons above threshold

\item {} 
Propagate spikes

\item {} 
Reset neurons which spiked

\end{enumerate}

You can see then that if neuron i has spiked at time t, then it
will not spike at time t+dt, even if it receives spikes from
another neuron. Those spikes it receives will be added at step
3 at time t, then reset to \code{Vr} at step 4 of time t, then the
thresholding function at time t+dt is applied at step 2, before
it has received any subsequent inputs. So the most a neuron
can spike is every other time step.

\resetcurrentobjects


\subsubsection{Tutorial 1f: Recording spikes}

In the previous part of the tutorial, we defined a network with
not entirely trivial behaviour, and printed the number of spikes.
In this part, we'll record every spike that the network generates
and display a raster plot of them. We start as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]
psp @PYGbe[=] @PYGaw[0.5]@PYGbe[*]mvolt         @PYGaD[# postsynaptic potential size]

model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)

C @PYGbe[=] Connection(G,G)
C@PYGbe[.]connect_random(G,G,@PYGaw[0.1],weight@PYGbe[=]psp)

M @PYGbe[=] SpikeMonitor(G)

G@PYGbe[.]V@PYGbe[=]Vr@PYGbe[+]rand(@PYGaw[40])@PYGbe[*](Vt@PYGbe[-]Vr)

run(@PYGaw[1]@PYGbe[*]second)

@PYGay[print] M@PYGbe[.]nspikes
\end{Verbatim}
\end{quote}

Having run the network, we simply use the \hyperlink{brian.raster_plot}{\code{raster\_plot()}} function
provided by Brian. After creating plots, we have to use the
\code{show()} function to display them. This function is from the
PyLab module that Brian uses for its built in plotting
routines.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
raster_plot()
show()
\end{Verbatim}
\end{quote}

\includegraphics{1f.jpg}

As you can see, despite having introduced some randomness into
our network, the output is very regular indeed. In the next part
we introduce one more way to plot the output of a network.

\resetcurrentobjects


\subsubsection{Tutorial 1g: Recording membrane potentials}

In the previous part of this tutorial, we plotted a raster plot of
the firing times of the network. In this tutorial, we introduce
a way to record the value of the membrane potential for a neuron
during the simulation, and plot it. We continue as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[20]@PYGbe[*]msecond        @PYGaD[# membrane time constant]
Vt  @PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mvolt          @PYGaD[# spike threshold]
Vr  @PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mvolt          @PYGaD[# reset value]
El  @PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mvolt          @PYGaD[# resting potential (same as the reset)]
psp @PYGbe[=] @PYGaw[0.5]@PYGbe[*]mvolt         @PYGaD[# postsynaptic potential size]

model @PYGbe[=] Model(equation@PYGbe[=]@PYGad[']@PYGad[dV/dt = -(V-El)/tau : volt]@PYGad['],
              threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)

G @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[40],model@PYGbe[=]model)

C @PYGbe[=] Connection(G,G)
C@PYGbe[.]connect_random(G,G,@PYGaw[0.1],weight@PYGbe[=]psp)
\end{Verbatim}
\end{quote}

This time we won't record the spikes.


\paragraph{Recording states}

Now we introduce a second type of monitor, the \hyperlink{brian.StateMonitor}{\code{StateMonitor}}.
The first argument is the group to monitor, and the second is
the state variable to monitor. The keyword \code{record} can be
an integer, list or the value \code{True}. If it is an integer \code{i},
the monitor will record the state of the variable for neuron \code{i}.
If it's a list of integers, it will record the states for
each neuron in the list. If it's set to \code{True} it will record
for all the neurons in the group.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
M @PYGbe[=] StateMonitor(G,@PYGad[']@PYGad[V]@PYGad['],record@PYGbe[=]@PYGaw[0])
\end{Verbatim}
\end{quote}

And then we continue as before:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G@PYGbe[.]V@PYGbe[=]Vr@PYGbe[+]rand(@PYGaw[40])@PYGbe[*](Vt@PYGbe[-]Vr)
\end{Verbatim}
\end{quote}

But this time we run it for a shorter time so we can look at
the output in more detail:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[200]@PYGbe[*]msecond)
\end{Verbatim}
\end{quote}

Having run the simulation, we plot the results using the
\code{plot} command from PyLab which has the same syntax as the Matlab
\code{plot`} command, i.e. \code{plot(xvals,yvals,...)}. The \hyperlink{brian.StateMonitor}{\code{StateMonitor}}
monitors the times at which it monitored a value in the
array \code{M.times}, and the values in the array \code{M{[}0{]}}. The notation
\code{M{[}i{]}} means the array of values of the monitored state
variable for neuron \code{i}.

In the following lines, we scale the times so that they're
measured in ms and the values so that they're measured in
mV. We also label the plot using PyLab's \code{xlabel}, \code{ylabel} and
\code{title} functions, which again mimic the Matlab equivalents.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
plot(M@PYGbe[.]times@PYGbe[/](@PYGaw[1]@PYGbe[*]msecond),M@lb[]@PYGaw[0]@rb[]@PYGbe[/](@PYGaw[1]@PYGbe[*]mvolt))
xlabel(@PYGad[']@PYGad[Time (in ms)]@PYGad['])
ylabel(@PYGad[']@PYGad[Memrane potential (in mV)]@PYGad['])
title(@PYGad[']@PYGad[Membrane potential for neuron 0]@PYGad['])
show()
\end{Verbatim}
\end{quote}

\includegraphics{1g.jpg}

You can clearly see the leaky integration exponential decay
toward the resting potential, as well as the jumps when a
spike was received.

\resetcurrentobjects


\hypertarget{tutorial2-connections}{}\subsection{Tutorial 2: Connections}

In this tutorial, we will cover in more detail the concept of the Connection
in Brian.

This tutorial assumes you have followed \hyperlink{tutorial1-basic-concepts}{\emph{Tutorial 1: Basic Concepts}}. It would
also be useful to read the \emph{Overview} section of the \emph{Concepts} chapter of
the main documentation.

\textbf{Tutorial contents}

\resetcurrentobjects


\subsubsection{Tutorial 2a: The concept of a Connection}


\paragraph{The network}

In this first part, we'll build a network consisting of three neurons. The
first two neurons will be under direct control and have no equations
defining them, they'll just produce spikes which will feed into the third
neuron. This third neuron has two different state variables, called Va
and Vb. The first two neurons will be connected to the third neuron, but
a spike arriving at the third neuron will be treated differently
according to whether it came from the first or second neuron (which you
can consider as meaning that the first two neurons have different
types of synapses on to the third neuron).

The program starts as follows.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau_a @PYGbe[=]  @PYGaw[1]@PYGbe[*]ms
tau_b @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
Vt    @PYGbe[=] @PYGaw[10]@PYGbe[*]mV
Vr    @PYGbe[=]  @PYGaw[0]@PYGbe[*]mV
\end{Verbatim}
\end{quote}


\paragraph{Differential equations}

This time, we will have multiple differential equations. We will use the
\hyperlink{brian.Equations}{\code{Equations}} object, although you could equally pass the multi-line string
defining the differential equations directly when initialising the \hyperlink{brian.Model}{\code{Model}}
object (see the next part of the tutorial for an example of this).
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
eqs @PYGbe[=] Equations(@PYGad[''']
@PYGad[      dVa/dt = -Va/tau_a : volt]
@PYGad[      dVb/dt = -Vb/tau_b : volt]
@PYGad[      ]@PYGad['''])
model @PYGbe[=] Model(equations@PYGbe[=]eqs,threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr)
\end{Verbatim}
\end{quote}

So far, we have defined a model neuron with two state variables, \code{Va}
and \code{Vb}, which both decay exponentially towards 0, but with different
time constants \code{tau\_a} and \code{tau\_b}. This is just so that you can see
the difference between them more clearly in the plot later on.


\paragraph{SpikeGeneratorGroup}

Now we introduce the \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} class. This is a group of
neurons without a model, which just produces spikes at the times
that you specify. You create a group like this by writing:

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] SpikeGeneratorGroup(N,spiketimes)
\end{Verbatim}

where \code{N} is the number of neurons in the group, and \code{spiketimes} is a
list of pairs \code{(i,t)} indicating that neuron \code{i} should fire at time \code{t}.
In fact, \code{spiketimes} can be any `iterable container' or `generator',
but we don't cover that here (see the detailed documentation for
\hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}).

In our case, we want to create a group with two neurons, the first
of which (neuron 0) fires at times 1 ms and 4 ms, and the second
of which (neuron 1) fires at times 2 ms and 3 ms. The list of
\code{spiketimes} then is:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
spiketimes @PYGbe[=] @lb[](@PYGaw[0],@PYGaw[1]@PYGbe[*]ms), (@PYGaw[0],@PYGaw[4]@PYGbe[*]ms),
              (@PYGaw[1],@PYGaw[2]@PYGbe[*]ms), (@PYGaw[1],@PYGaw[3]@PYGbe[*]ms)@rb[]
\end{Verbatim}
\end{quote}

and we create the group as follows:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G1 @PYGbe[=] SpikeGeneratorGroup(@PYGaw[2],spiketimes)
\end{Verbatim}
\end{quote}

Now we create a second group, with one neuron, according to the
model we defined earlier.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G2 @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[1],model@PYGbe[=]model)
\end{Verbatim}
\end{quote}


\paragraph{Connections}

In Brian, a \hyperlink{brian.Connection}{\code{Connection}} from one \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} to another is
defined by writing:

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(G,H,state)
\end{Verbatim}

Here \code{G} is the source group, \code{H} is the target group, and \code{state} is the
name of the target state variable. When a neuron \code{i} in \code{G} fires, Brian
finds all the neurons \code{j} in \code{H} that \code{i} in \code{G} is connected to, and adds
the amount \code{C{[}i,j{]}} to the specified state variable of neuron \code{j} in \code{H}.
Here \code{C{[}i,j{]}} is the (i,j)th entry of the connection matrix of \code{C} (which
is initially all zero).

To start with, we create two connections from the group of two
directly controlled neurons to the group of one neuron with the
differential equations. The first connection has the target state \code{Va}
and the second has the target state \code{Vb}.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
C1 @PYGbe[=] Connection(G1,G2,@PYGad[']@PYGad[Va]@PYGad['])
C2 @PYGbe[=] Connection(G1,G2,@PYGad[']@PYGad[Vb]@PYGad['])
\end{Verbatim}
\end{quote}

So far, this only declares our intention to connect neurons in group
\code{G1} to neurons in group \code{G2}, because the connection matrix is initially
all zeros. Now, with connection \code{C1} we connect neuron 0 in group \code{G1}
to neuron 0 in group \code{G2}, with weight 3 mV. This means that when neuron
0 in group \code{G1} fires, the state variable \code{Va} of the neuron in group \code{G2}
will be increased by 6 mV. Then we use connection \code{C2} to connection
neuron 1 in group \code{G1} to neuron 0 in group \code{G2}, this time with weight
3 mV.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
C1@lb[]@PYGaw[0],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[6]@PYGbe[*]mV
C2@lb[]@PYGaw[1],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[3]@PYGbe[*]mV
\end{Verbatim}
\end{quote}

The net effect of this is that when neuron 0 of \code{G1} fires, \code{Va} for
the neuron in \code{G2} will increase 6 mV, and when neuron 1 of \code{G1} fires,
\code{Vb} for the neuron in \code{G2} will increase 3 mV.

Now we set up monitors to record the activity of the network,
run it and plot it.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
Ma @PYGbe[=] StateMonitor(G2,@PYGad[']@PYGad[Va]@PYGad['],record@PYGbe[=]@PYGaA[True])
Mb @PYGbe[=] StateMonitor(G2,@PYGad[']@PYGad[Vb]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[10]@PYGbe[*]ms)

plot(Ma@PYGbe[.]times,Ma@lb[]@PYGaw[0]@rb[])
plot(Mb@PYGbe[.]times,Mb@lb[]@PYGaw[0]@rb[])
show()
\end{Verbatim}
\end{quote}

\includegraphics{2a.jpg}

The two plots show the state variables \code{Va} and \code{Vb} for the single
neuron in group \code{G2}. \code{Va} is shown in blue, and \code{Vb} in green.
According to the differential equations, \code{Va} decays much faster
than \code{Vb} (time constant 1 ms rather than 10 ms), but we have set
it up (through the connection strengths) that an incoming
spike from neuron 0 of \code{G1} causes a large increase of 6 mV to \code{Va},
whereas a spike from neuron 1 of \code{G1} causes a smaller increase of
3 mV to Vb. The value for \code{Va} then jumps at times 1 ms and 4 ms,
when we defined neuron 0 of \code{G1} to fire, and decays almost back
to rest in between. The value for \code{Vb} jumps at times 2 ms and
3 ms, and because the times are closer together and the time
constant is longer, they add together.

In the next part of this tutorial, we'll see how to use this
system to do something useful.


\paragraph{Exercises}
\begin{enumerate}
\item {} 
Try playing with the parameters \code{tau\_a}, \code{tau\_b} and the connection
strengths, \code{C1{[}0,0{]}} and \code{C2{[}0,1{]}}. Try changing the list of
spike times.

\item {} 
In this part of the tutorial, the states \code{Va} and \code{Vb} are
independent of one another. Try rewriting the differential
equations so that they're not independent and play around
with that.

\item {} 
Write a network with inhibitory and excitatory neurons. Hint: you
only need one connection.

\item {} 
Write a network with inhibitory and excitatory neurons whose
actions have different time constants (for example, excitatory
neurons have a slower effect than inhibitory ones).

\end{enumerate}


\paragraph{Solutions}
\begin{enumerate}
\item {} 
Simple write \code{C{[}i,j{]}=-3*mV} to make the connection from neuron
i to neuron j inhibitory.

\item {} 
See the next part of this tutorial.

\end{enumerate}

\resetcurrentobjects


\subsubsection{Tutorial 2b: Excitatory and inhibitory currents}

In this tutorial, we use multiple connections to solve a real problem, how
to implement two types of synapses with excitatory and inhibitory currents
with different time constants.


\paragraph{The scheme}

The scheme we implement is the following diffential equations:
\begin{quote}
{\raggedright{}taum~dV/dt~=~-V~+~ge~-~gi\\
taue~dge/dt~=~-ge\\
taui~dgi/dt~=~-gi}
\end{quote}

An excitatory neuron connects to state ge, and an inhibitory neuron connects
to state gi. When an excitatory spike arrives, ge instantaneously increases,
then decays exponentially. Consequently, V will initially but continuously
rise and then fall. Solving these equations, if V(0)=0, ge(0)=g0 corresponding
to an excitatory spike arriving at time 0, and gi(0)=0 then:
\begin{quote}
{\raggedright{}gi~=~0\\
ge~=~g0~exp(-t/taue)\\
V~=~(exp(-t/taum)~-~exp(-t/taue))~taue~g0~/~(taum-taue)}
\end{quote}

We use a very short time constant for the excitatory currents, a longer one
for the inhibitory currents, and an even longer one for the membrane
potential.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

taum @PYGbe[=] @PYGaw[20]@PYGbe[*]ms
taue @PYGbe[=]  @PYGaw[1]@PYGbe[*]ms
taui @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
Vt   @PYGbe[=] @PYGaw[10]@PYGbe[*]mV
Vr   @PYGbe[=]  @PYGaw[0]@PYGbe[*]mV

model @PYGbe[=] Model(equations @PYGbe[=] @PYGad[''']
@PYGad[        dV/dt  = (-V+ge-gi)/taum : volt]
@PYGad[        dge/dt = -ge/taue        : volt]
@PYGad[        dgi/dt = -gi/taui        : volt]
@PYGad[        ]@PYGad['''], threshold@PYGbe[=]Vt, reset@PYGbe[=]Vr)
\end{Verbatim}
\end{quote}


\paragraph{Connections}

As before, we'll have a group of two neurons under direct control, the first
of which will be excitatory this time, and the second will be inhibitory. To
demonstrate the effect, we'll have two excitatory spikes reasonably close
together, followed by an inhibitory spike later on, and then shortly after
that two excitatory spikes close together.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
spiketimes @PYGbe[=] @lb[](@PYGaw[0],@PYGaw[1]@PYGbe[*]ms),(@PYGaw[0],@PYGaw[10]@PYGbe[*]ms),
              (@PYGaw[1],@PYGaw[40]@PYGbe[*]ms),
              (@PYGaw[0],@PYGaw[50]@PYGbe[*]ms),(@PYGaw[0],@PYGaw[55]@PYGbe[*]ms)@rb[]

G1 @PYGbe[=] SpikeGeneratorGroup(@PYGaw[2],spiketimes)
G2 @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[1],model@PYGbe[=]model)

C1 @PYGbe[=] Connection(G1,G2,@PYGad[']@PYGad[ge]@PYGad['])
C2 @PYGbe[=] Connection(G1,G2,@PYGad[']@PYGad[gi]@PYGad['])
\end{Verbatim}
\end{quote}

The weights are the same - when we increase \code{ge} the effect on \code{V} is excitatory
and when we increase \code{gi} the effect on \code{V} is inhibitory.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
C1@lb[]@PYGaw[0],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[3]@PYGbe[*]mV
C2@lb[]@PYGaw[1],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[3]@PYGbe[*]mV
\end{Verbatim}
\end{quote}

We set up monitors and run as normal.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
Mv  @PYGbe[=] StateMonitor(G2,@PYGad[']@PYGad[V]@PYGad['],record@PYGbe[=]@PYGaA[True])
Mge @PYGbe[=] StateMonitor(G2,@PYGad[']@PYGad[ge]@PYGad['],record@PYGbe[=]@PYGaA[True])
Mgi @PYGbe[=] StateMonitor(G2,@PYGad[']@PYGad[gi]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[100]@PYGbe[*]ms)
\end{Verbatim}
\end{quote}

This time we do something a little bit different when plotting it. We want
a plot with two subplots, the top one will show \code{V}, and the bottom one will
show both \code{ge} and \code{gi}. We use the \code{subplot} command from pylab which mimics the
same command from Matlab.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
figure()
subplot(@PYGaw[211])
plot(Mv@PYGbe[.]times,Mv@lb[]@PYGaw[0]@rb[])
subplot(@PYGaw[212])
plot(Mge@PYGbe[.]times,Mge@lb[]@PYGaw[0]@rb[])
plot(Mgi@PYGbe[.]times,Mgi@lb[]@PYGaw[0]@rb[])
show()
\end{Verbatim}
\end{quote}

\includegraphics{2b.jpg}

The top figure shows the voltage trace, and the bottom figure shows \code{ge} in
blue and \code{gi} in green. You can see that although the inhibitory and
excitatory weights are the same, the inhibitory current is much more
powerful. This is because the effect of \code{ge} or \code{gi} on \code{V} is related to the
integral of the differential equation for those variables, and \code{gi} decays
much more slowly than \code{ge}. Thus the size of the negative deflection at
40 ms is much bigger than the excitatory ones, and even the double
excitatory spike after the inhibitory one can't cancel it out.

In the next part of this tutorial, we set up our first serious network,
with 4000 neurons, excitatory and inhibitory.


\paragraph{Exercises}
\begin{enumerate}
\item {} 
Try changing the parameters and spike times to get a feel for how it
works.

\item {} 
Try an equivalent implementation with the equation taum dV/dt = -V+ge+gi

\item {} 
Verify that the differential equation has been solved correctly.

\end{enumerate}


\paragraph{Solutions}

Solution for 2:

Simply use the line \code{C2{[}1,0{]} = -3*mV} to get the same effect.

Solution for 3:

First, set up the situation we described at the top for which we
already know the solution of the differential equations, by changing
the spike times as follows:

\begin{Verbatim}[commandchars=@\[\]]
spiketimes @PYGbe[=] @lb[](@PYGaw[0],@PYGaw[0]@PYGbe[*]ms)@rb[]
\end{Verbatim}

Now we compute what the values ought to be as follows:

\begin{Verbatim}[commandchars=@\[\]]
t @PYGbe[=] Mv@PYGbe[.]times
Vpredicted @PYGbe[=] (exp(@PYGbe[-]t@PYGbe[/]taum) @PYGbe[-] exp(@PYGbe[-]t@PYGbe[/]taue))@PYGbe[*]taue@PYGbe[*](@PYGaw[3]@PYGbe[*]mV) @PYGbe[/] (taum@PYGbe[-]taue)
\end{Verbatim}

Now we can compute the difference between the predicted and actual values:

\begin{Verbatim}[commandchars=@\[\]]
Vdiff @PYGbe[=] @PYGaX[abs](Vpredicted @PYGbe[-] Mv@lb[]@PYGaw[0]@rb[])
\end{Verbatim}

This should be zero:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[print] @PYGaX[max](Vdiff)
\end{Verbatim}

Sure enough, it's as close as you can expect on a computer. When I run this
it gives me the value 1.3 aV, which is 1.3 * 10\textasciicircum{}-18 volts, i.e. effectively
zero given the finite precision of the calculations involved.

\resetcurrentobjects


\subsubsection{Tutorial 2c: The CUBA network}

In this part of the tutorial, we set up our first serious network
that actually does something. It implements the CUBA network, Benchmark 2 from:
\begin{quote}

Simulation of networks of spiking neurons: A review of tools and strategies (2006).
Brette, Rudolph, Carnevale, Hines, Beeman, Bower, Diesmann, Goodman, Harris, Zirpe,
Natschlager, Pecevski, Ermentrout, Djurfeldt, Lansner, Rochel, Vibert, Alvarez, Muller,
Davison, El Boustani and Destexhe.
Journal of Computational Neuroscience
\end{quote}

This is a network of 4000 neurons, of which 3200 excitatory, and 800 inhibitory, with
exponential synaptic currents. The neurons are randomly connected with probability 0.02.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

taum @PYGbe[=]  @PYGaw[20]@PYGbe[*]ms          @PYGaD[# membrane time constant]
taue @PYGbe[=]   @PYGaw[5]@PYGbe[*]ms          @PYGaD[# excitatory synaptic time constant]
taui @PYGbe[=]  @PYGaw[10]@PYGbe[*]ms          @PYGaD[# inhibitory synaptic time constant]
Vt   @PYGbe[=] @PYGbe[-]@PYGaw[50]@PYGbe[*]mV          @PYGaD[# spike threshold]
Vr   @PYGbe[=] @PYGbe[-]@PYGaw[60]@PYGbe[*]mV          @PYGaD[# reset value]
El   @PYGbe[=] @PYGbe[-]@PYGaw[49]@PYGbe[*]mV          @PYGaD[# resting potential]
we   @PYGbe[=] (@PYGaw[60]@PYGbe[*]@PYGaw[0.27]@PYGbe[/]@PYGaw[10])@PYGbe[*]mV @PYGaD[# excitatory synaptic weight]
wi   @PYGbe[=]  (@PYGaw[20]@PYGbe[*]@PYGaw[4.5]@PYGbe[/]@PYGaw[10])@PYGbe[*]mV @PYGaD[# inhibitory synaptic weight]

model @PYGbe[=] Model(equations @PYGbe[=] @PYGad[''']
@PYGad[        dV/dt  = (ge-gi-(V-El))/taum : volt]
@PYGad[        dge/dt = -ge/taue            : volt]
@PYGad[        dgi/dt = -gi/taui            : volt]
@PYGad[        ]@PYGad['''], threshold@PYGbe[=]Vt, reset@PYGbe[=]Vr)
\end{Verbatim}
\end{quote}

So far, this has been pretty similar to the previous part, the only
difference is we have a couple more parameters, and we've added a
resting potential \code{El} into the equation for \code{V}.

Now we make lots of neurons:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] NeuronGroup(@PYGaw[4000], model@PYGbe[=]model)
\end{Verbatim}
\end{quote}

Next, we divide them into subgroups. The \hyperlink{brian.NeuronGroup.subgroup}{\code{subgroup()}} method of a
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} returns a new \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} that can be used in
exactly the same way as its parent group. At the moment, the
subgrouping mechanism can only be used to create contiguous
groups of neurons (so you can't have a subgroup consisting
of neurons 0-100 and also 200-300 say). We designate the
first 3200 neurons as \code{Ge} and the second 800 as \code{Gi}, these
will be the excitatory and inhibitory neurons.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
Ge @PYGbe[=] G@PYGbe[.]subgroup(@PYGaw[3200]) @PYGaD[# Excitatory neurons]
Gi @PYGbe[=] G@PYGbe[.]subgroup(@PYGaw[800])  @PYGaD[# Inhibitory neurons]
\end{Verbatim}
\end{quote}

Now we define the connections. As in the previous part of the
tutorial, \code{ge} is the excitatory current and \code{gi} is the inhibitory
one. \code{Ce} says that an excitatory neuron can synapse onto any
neuron in \code{G}, be it excitatory or inhibitory. Similarly for
inhibitory neurons.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
Ce@PYGbe[=]Connection(Ge, G, @PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Gi, G, @PYGad[']@PYGad[gi]@PYGad['])
\end{Verbatim}
\end{quote}

We randomly connect \code{Ge} and \code{Gi} to the whole of \code{G} with
probability 0.02 and the weights given in the list of
parameters at the top.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
Ce@PYGbe[.]connect_random(Ge, G, @PYGaw[0.02], weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Gi, G, @PYGaw[0.02], weight@PYGbe[=]wi)
\end{Verbatim}
\end{quote}

Set up some monitors as usual. The line \code{record=0} in the \hyperlink{brian.StateMonitor}{\code{StateMonitor}}
declarations indicates that we only want to record the activity of
neuron 0. This saves time and memory.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
M   @PYGbe[=] SpikeMonitor(G)
MV  @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[V]@PYGad['], record@PYGbe[=]@PYGaw[0])
Mge @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[ge]@PYGad['], record@PYGbe[=]@PYGaw[0])
Mgi @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[gi]@PYGad['], record@PYGbe[=]@PYGaw[0])
\end{Verbatim}
\end{quote}

And in order to start the network off in a somewhat
more realistic state, we initialise the membrane
potentials uniformly randomly between the reset and
the threshold.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
G@PYGbe[.]V @PYGbe[=] Vr @PYGbe[+] (Vt@PYGbe[-]Vr) @PYGbe[*] rand(@PYGaX[len](G))
\end{Verbatim}
\end{quote}

Now we run.
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[500]@PYGbe[*]ms)
\end{Verbatim}
\end{quote}

And finally we plot the results. Just for fun, we do a rather more
complicated plot than we've been doing so far, with three subplots.
The upper one is the raster plot of the whole network, and the
lower two are the values of \code{V} (on the left) and \code{ge} and \code{gi} (on the
right) for the neuron we recorded from. See the PyLab documentation
for an explanation of the plotting functions, but note that the
\hyperlink{brian.raster_plot}{\code{raster\_plot()}} keyword \code{newfigure=False} instructs the (Brian) function
\hyperlink{brian.raster_plot}{\code{raster\_plot()}} not to create a new figure (so that it can be placed
as a subplot of a larger figure).
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
subplot(@PYGaw[211])
raster_plot(M, title@PYGbe[=]@PYGad[']@PYGad[The CUBA network]@PYGad['], newfigure@PYGbe[=]@PYGaA[False])
subplot(@PYGaw[223])
plot(MV@PYGbe[.]times@PYGbe[/]ms, MV@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
xlabel(@PYGad[']@PYGad[Time (ms)]@PYGad['])
ylabel(@PYGad[']@PYGad[V (mV)]@PYGad['])
subplot(@PYGaw[224])
plot(Mge@PYGbe[.]times@PYGbe[/]ms, Mge@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
plot(Mgi@PYGbe[.]times@PYGbe[/]ms, Mgi@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
xlabel(@PYGad[']@PYGad[Time (ms)]@PYGad['])
ylabel(@PYGad[']@PYGad[ge and gi (mV)]@PYGad['])
legend((@PYGad[']@PYGad[ge]@PYGad['],@PYGad[']@PYGad[gi]@PYGad[']), @PYGad[']@PYGad[upper right]@PYGad['])
show()
\end{Verbatim}
\end{quote}

\includegraphics{2c.jpg}

\resetcurrentobjects


\section{Examples}

These examples cover some basic topics in writing Brian scripts in Python. The
complete source code for the examples is available in the examples folder
in the extras package.

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{Connection}\indexii{example usage}{PoissonGroup}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-26}{}\subsection{Example: adaptive}

An adaptive neuron model

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

PG @PYGbe[=] PoissonGroup(@PYGaw[1],@PYGaw[500]@PYGbe[*]Hz)
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (-w-v)/(10*ms) : volt # the membrane equation]
@PYGad[dw/dt = -w/(30*ms) : volt # the adaptation current]
@PYGad[''']
@PYGay[def] @PYGaK[myreset](P,spikes):
    P@PYGbe[.]v@lb[]spikes@rb[]@PYGbe[=]@PYGaw[0]@PYGbe[*]mV @PYGaD[# Faster: P.v_@lb[]spikes@rb[]=0*mV]
    P@PYGbe[.]w@lb[]spikes@rb[]@PYGbe[+]@PYGbe[=]@PYGaw[3]@PYGbe[*]mV @PYGaD[# the adaptation variable increases with each spike]
IF @PYGbe[=] NeuronGroup(@PYGaw[1],model@PYGbe[=]eqs,reset@PYGbe[=]myreset,threshold@PYGbe[=]@PYGaw[20]@PYGbe[*]mV)

C @PYGbe[=] Connection(PG,IF,@PYGad[']@PYGad[v]@PYGad['])
C@PYGbe[.]connect_full(PG,IF,@PYGaw[3]@PYGbe[*]mV)

MS @PYGbe[=] SpikeMonitor(PG,@PYGaA[True])
Mv @PYGbe[=] StateMonitor(IF,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True])
Mw @PYGbe[=] StateMonitor(IF,@PYGad[']@PYGad[w]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[100]@PYGbe[*]ms)

plot(Mv@PYGbe[.]times@PYGbe[/]ms,Mv@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
plot(Mw@PYGbe[.]times@PYGbe[/]ms,Mw@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)

show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{PoissonGroup}\indexii{example usage}{run}\indexii{example usage}{Connection}\indexii{example usage}{StateMonitor}

\hypertarget{index-27}{}\subsection{Example: adaptive\_threshold}

A model with adaptive threshold (increases with each spike)

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = -v/(10*ms) : volt]
@PYGad[dvt/dt = (10*mV-vt)/(15*ms) : volt]
@PYGad[''']

@PYGay[def] @PYGaK[myreset](P, spikes):
    P@PYGbe[.]v@lb[]spikes@rb[]@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
    P@PYGbe[.]vt@lb[]spikes@rb[]@PYGbe[+]@PYGbe[=]@PYGaw[3]@PYGbe[*]mV

IF @PYGbe[=] NeuronGroup(@PYGaw[1], model@PYGbe[=]eqs,
        reset@PYGbe[=]myreset,
        threshold@PYGbe[=]@PYGay[lambda] v,vt:v@PYGbe[>]@PYGbe[=]vt)
IF@PYGbe[.]rest()
PG @PYGbe[=] PoissonGroup(@PYGaw[1], @PYGaw[500]@PYGbe[*]Hz)

C @PYGbe[=] Connection(PG, IF, @PYGad[']@PYGad[v]@PYGad['])
C@PYGbe[.]connect_full(PG, IF, @PYGaw[3]@PYGbe[*]mV)

Mv @PYGbe[=] StateMonitor(IF, @PYGad[']@PYGad[v]@PYGad['], record@PYGbe[=]@PYGaA[True])
Mvt @PYGbe[=] StateMonitor(IF, @PYGad[']@PYGad[vt]@PYGad['], record@PYGbe[=]@PYGaA[True])

run(@PYGaw[100]@PYGbe[*]ms)

plot(Mv@PYGbe[.]times@PYGbe[/]ms, Mv@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
plot(Mvt@PYGbe[.]times@PYGbe[/]ms, Mvt@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)

show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{Current}\indexii{example usage}{MembraneEquation}\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-28}{}\subsection{Example: cable}

Dendrite with 100 compartments

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.compartments] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.ionic_currents] @PYGay[import] @PYGbe[*]

length@PYGbe[=]@PYGaw[1]@PYGbe[*]mm
nseg@PYGbe[=]@PYGaw[100]
dx@PYGbe[=]length@PYGbe[/]nseg
Cm@PYGbe[=]@PYGaw[1]@PYGbe[*]uF@PYGbe[/]cm@PYGbe[*]@PYGbe[*]@PYGaw[2]
gl@PYGbe[=]@PYGaw[0.02]@PYGbe[*]msiemens@PYGbe[/]cm@PYGbe[*]@PYGbe[*]@PYGaw[2]
diam@PYGbe[=]@PYGaw[1]@PYGbe[*]um
area@PYGbe[=]pi@PYGbe[*]diam@PYGbe[*]dx
El@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
Ri@PYGbe[=]@PYGaw[100]@PYGbe[*]ohm@PYGbe[*]cm
ra@PYGbe[=]Ri@PYGbe[*]@PYGaw[4]@PYGbe[/](pi@PYGbe[*]diam@PYGbe[*]@PYGbe[*]@PYGaw[2])

@PYGay[print] @PYGad["]@PYGad[Time constant =]@PYGad["],Cm@PYGbe[/]gl
@PYGay[print] @PYGad["]@PYGad[Space constant =]@PYGad["],@PYGbe[.]@PYGaw[5]@PYGbe[*](diam@PYGbe[/](gl@PYGbe[*]Ri))@PYGbe[*]@PYGbe[*]@PYGbe[.]@PYGaw[5]

segments@PYGbe[=]{}
@PYGay[for] i @PYGan[in] @PYGaX[range](nseg):
    segments@lb[]i@rb[]@PYGbe[=]MembraneEquation(Cm@PYGbe[*]area)@PYGbe[+]leak_current(gl@PYGbe[*]area,El)

segments@lb[]@PYGaw[0]@rb[]@PYGbe[+]@PYGbe[=]Current(@PYGad[']@PYGad[I:nA]@PYGad['])

cable@PYGbe[=]Compartments(segments)
@PYGay[for] i @PYGan[in] @PYGaX[range](nseg@PYGbe[-]@PYGaw[1]):
    cable@PYGbe[.]connect(i,i@PYGbe[+]@PYGaw[1],ra@PYGbe[*]dx)

neuron@PYGbe[=]NeuronGroup(@PYGaw[1],model@PYGbe[=]cable)
@PYGaD[#neuron.vm_0=10*mV]
neuron@PYGbe[.]I_0@PYGbe[=]@PYGbe[.]@PYGaw[05]@PYGbe[*]nA

trace@PYGbe[=]@lb[]@rb[]
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[10]):
    trace@PYGbe[.]append(StateMonitor(neuron,@PYGad[']@PYGad[vm_]@PYGad[']@PYGbe[+]@PYGaX[str](@PYGaw[10]@PYGbe[*]i),record@PYGbe[=]@PYGaA[True]))

run(@PYGaw[200]@PYGbe[*]ms)

@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[10]):
    plot(trace@lb[]i@rb[]@PYGbe[.]times@PYGbe[/]ms,trace@lb[]i@rb[]@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{PopulationSpikeCounter}\indexii{example usage}{Connection}\indexii{example usage}{Equations}\indexii{example usage}{run}\indexii{example usage}{NeuronGroup}

\hypertarget{index-19}{}\subsection{Example: COBA}

This is a Brian script implementing a benchmark described
in the following review paper:

Simulation of networks of spiking neurons: A review of tools and strategies (2007).
Brette, Rudolph, Carnevale, Hines, Beeman, Bower, Diesmann, Goodman, Harris, Zirpe,
Natschlager, Pecevski, Ermentrout, Djurfeldt, Lansner, Rochel, Vibert, Alvarez, Muller,
Davison, El Boustani and Destexhe.
Journal of Computational Neuroscience 23(3):349-98

Benchmark 1: random network of integrate-and-fire neurons with exponential synaptic conductances

Clock-driven implementation with Euler integration
(no spike time interpolation)


\subsubsection{R. Brette - Dec 2007}

Brian is a simulator for spiking neural networks written in Python, developed by
R. Brette and D. Goodman.
\href{http://brian.di.ens.fr}{http://brian.di.ens.fr}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

@PYGaD[# Time constants]
taum@PYGbe[=]@PYGaw[20]@PYGbe[*]msecond
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]msecond
taui@PYGbe[=]@PYGaw[10]@PYGbe[*]msecond
@PYGaD[# Reversal potentials]
Ee@PYGbe[=](@PYGaw[0.]@PYGbe[+]@PYGaw[60.])@PYGbe[*]mvolt
Ei@PYGbe[=](@PYGbe[-]@PYGaw[80.]@PYGbe[+]@PYGaw[60.])@PYGbe[*]mvolt

start_time@PYGbe[=]time@PYGbe[.]time()
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dv/dt = (-v+ge*(Ee-v)+gi*(Ei-v))*(1./taum) : volt]
@PYGad[dge/dt = -ge*(1./taue) : 1]
@PYGad[dgi/dt = -gi*(1./taui) : 1]
@PYGad['''])
@PYGaD[# NB 1: conductances are in units of the leak conductance]
@PYGaD[# NB 2: multiplication is faster than division]

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mvolt,\
              reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mvolt,refractory@PYGbe[=]@PYGaw[5]@PYGbe[*]msecond,
              order@PYGbe[=]@PYGaw[1],@PYGaX[compile]@PYGbe[=]@PYGaA[True])
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
we@PYGbe[=]@PYGaw[6.]@PYGbe[/]@PYGaw[10.] @PYGaD[# excitatory synaptic weight (voltage)]
wi@PYGbe[=]@PYGaw[67.]@PYGbe[/]@PYGaw[10.] @PYGaD[# inhibitory synaptic weight]
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]wi)
@PYGaD[# Initialization]
P@PYGbe[.]v@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[5]@PYGbe[-]@PYGaw[5])@PYGbe[*]mvolt
P@PYGbe[.]ge@PYGbe[=]randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[1.5]@PYGbe[+]@PYGaw[4]
P@PYGbe[.]gi@PYGbe[=]randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[12]@PYGbe[+]@PYGaw[20]

@PYGaD[# Record the number of spikes]
Me@PYGbe[=]PopulationSpikeCounter(Pe)
Mi@PYGbe[=]PopulationSpikeCounter(Pi)

@PYGay[print] @PYGad["]@PYGad[Network construction time:]@PYGad["],time@PYGbe[.]time()@PYGbe[-]start_time,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] @PYGad["]@PYGad[Simulation running...]@PYGad["]
start_time@PYGbe[=]time@PYGbe[.]time()

run(@PYGaw[1]@PYGbe[*]second)
duration@PYGbe[=]time@PYGbe[.]time()@PYGbe[-]start_time
@PYGay[print] @PYGad["]@PYGad[Simulation time:]@PYGad["],duration,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] Me@PYGbe[.]nspikes,@PYGad["]@PYGad[excitatory spikes]@PYGad["]
@PYGay[print] Mi@PYGbe[.]nspikes,@PYGad["]@PYGad[inhibitory spikes]@PYGad["]
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationSpikeCounter}\indexii{example usage}{Connection}\indexii{example usage}{EmpiricalThreshold}\indexii{example usage}{Equations}\indexii{example usage}{StateMonitor}

\hypertarget{index-20}{}\subsection{Example: COBAHH}

This is a Brian script implementing a benchmark described
in the following review paper:

Simulation of networks of spiking neurons: A review of tools and strategies (2007).
Brette, Rudolph, Carnevale, Hines, Beeman, Bower, Diesmann, Goodman, Harris, Zirpe,
Natschlager, Pecevski, Ermentrout, Djurfeldt, Lansner, Rochel, Vibert, Alvarez, Muller,
Davison, El Boustani and Destexhe.
Journal of Computational Neuroscience 23(3):349-98

Benchmark 3: random network of HH neurons with exponential synaptic conductances

Clock-driven implementation with exponential Euler integration
(no spike time interpolation)


\subsubsection{R. Brette - Dec 2007}

Brian is a simulator for spiking neural networks written in Python, developed by
R. Brette and D. Goodman.
\href{http://brian.di.ens.fr}{http://brian.di.ens.fr}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

@PYGaD[# Parameters]
area@PYGbe[=]@PYGaw[20000]@PYGbe[*]umetre@PYGbe[*]@PYGbe[*]@PYGaw[2]
Cm@PYGbe[=](@PYGaw[1]@PYGbe[*]ufarad@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
gl@PYGbe[=](@PYGaw[5e-5]@PYGbe[*]siemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
El@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
EK@PYGbe[=]@PYGbe[-]@PYGaw[90]@PYGbe[*]mV
ENa@PYGbe[=]@PYGaw[50]@PYGbe[*]mV
g_na@PYGbe[=](@PYGaw[100]@PYGbe[*]msiemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
g_kd@PYGbe[=](@PYGaw[30]@PYGbe[*]msiemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
VT@PYGbe[=]@PYGbe[-]@PYGaw[63]@PYGbe[*]mV
@PYGaD[# Time constants]
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]ms
taui@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
@PYGaD[# Reversal potentials]
Ee@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
Ei@PYGbe[=]@PYGbe[-]@PYGaw[80]@PYGbe[*]mV
we@PYGbe[=]@PYGaw[6]@PYGbe[*]nS @PYGaD[# excitatory synaptic weight (voltage)]
wi@PYGbe[=]@PYGaw[67]@PYGbe[*]nS @PYGaD[# inhibitory synaptic weight]

start_time@PYGbe[=]time@PYGbe[.]time()
@PYGaD[# The model]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dv/dt = (gl*(El-v)+ge*(Ee-v)+gi*(Ei-v)-g_na*(m*m*m)*h*(v-ENa)-g_kd*(n*n*n*n)*(v-EK))/Cm : volt]
@PYGad[dm/dt = alpham*(1-m)-betam*m : 1]
@PYGad[dn/dt = alphan*(1-n)-betan*n : 1]
@PYGad[dh/dt = alphah*(1-h)-betah*h : 1]
@PYGad[dge/dt = -ge*(1./taue) : siemens]
@PYGad[dgi/dt = -gi*(1./taui) : siemens]
@PYGad[alpham = 0.32*(mV**-1)*(13*mV-v+VT)/(exp((13*mV-v+VT)/(4*mV))-1.)/ms : Hz]
@PYGad[betam = 0.28*(mV**-1)*(v-VT-40*mV)/(exp((v-VT-40*mV)/(5*mV))-1)/ms : Hz]
@PYGad[alphah = 0.128*exp((17*mV-v+VT)/(18*mV))/ms : Hz]
@PYGad[betah = 4./(1+exp((40*mV-v+VT)/(5*mV)))/ms : Hz]
@PYGad[alphan = 0.032*(mV**-1)*(15*mV-v+VT)/(exp((15*mV-v+VT)/(5*mV))-1.)/ms : Hz]
@PYGad[betan = .5*exp((10*mV-v+VT)/(40*mV))/ms : Hz]
@PYGad['''])

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,\
              threshold@PYGbe[=]EmpiricalThreshold(threshold@PYGbe[=]@PYGbe[-]@PYGaw[20]@PYGbe[*]mV,refractory@PYGbe[=]@PYGaw[3]@PYGbe[*]ms),\
              implicit@PYGbe[=]@PYGaA[True],freeze@PYGbe[=]@PYGaA[True],@PYGaX[compile]@PYGbe[=]@PYGaA[False])
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]wi)
@PYGaD[# Initialization]
P@PYGbe[.]v@PYGbe[=]El@PYGbe[+](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[5]@PYGbe[-]@PYGaw[5])@PYGbe[*]mV
P@PYGbe[.]ge@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[1.5]@PYGbe[+]@PYGaw[4])@PYGbe[*]@PYGaw[10.]@PYGbe[*]nS
P@PYGbe[.]gi@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[12]@PYGbe[+]@PYGaw[20])@PYGbe[*]@PYGaw[10.]@PYGbe[*]nS

@PYGaD[# Record the number of spikes and a few traces]
Me@PYGbe[=]PopulationSpikeCounter(Pe)
Mi@PYGbe[=]PopulationSpikeCounter(Pi)
trace@PYGbe[=]StateMonitor(P,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[1],@PYGaw[10],@PYGaw[100]@rb[])

@PYGay[print] @PYGad["]@PYGad[Network construction time:]@PYGad["],time@PYGbe[.]time()@PYGbe[-]start_time,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] @PYGad["]@PYGad[Simulation running...]@PYGad["]
run(@PYGaw[1]@PYGbe[*]msecond)
start_time@PYGbe[=]time@PYGbe[.]time()

run(@PYGaw[1000]@PYGbe[*]msecond)
duration@PYGbe[=]time@PYGbe[.]time()@PYGbe[-]start_time
@PYGay[print] @PYGad["]@PYGad[Simulation time:]@PYGad["],duration,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] Me@PYGbe[.]nspikes,@PYGad["]@PYGad[excitatory spikes]@PYGad["]
@PYGay[print] Mi@PYGbe[.]nspikes,@PYGad["]@PYGad[inhibitory spikes]@PYGad["]

plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[1]@rb[]@PYGbe[/]mV)
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[10]@rb[]@PYGbe[/]mV)
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[100]@rb[]@PYGbe[/]mV)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{Connection}\indexii{example usage}{EmpiricalThreshold}\indexii{example usage}{Equations}\indexii{example usage}{StateMonitor}

\hypertarget{index-29}{}\subsection{Example: cobahh\_simplified}

This is an implementation of a benchmark described
in the following review paper:

Simulation of networks of spiking neurons: A review of tools and strategies (2006).
Brette, Rudolph, Carnevale, Hines, Beeman, Bower, Diesmann, Goodman, Harris, Zirpe,
NatschlAger, Pecevski, Ermentrout, Djurfeldt, Lansner, Rochel, Vibert, Alvarez, Muller,
Davison, El Boustani and Destexhe.
Journal of Computational Neuroscience

Benchmark 3: random network of HH neurons with exponential synaptic conductances

Clock-driven implementation
(no spike time interpolation)

R. Brette - Dec 2007

70s for dt=0.1 ms with exponential Euler

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

@PYGaD[# Parameters]
area@PYGbe[=]@PYGaw[20000]@PYGbe[*]umetre@PYGbe[*]@PYGbe[*]@PYGaw[2]
Cm@PYGbe[=](@PYGaw[1]@PYGbe[*]ufarad@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
gl@PYGbe[=](@PYGaw[5e-5]@PYGbe[*]siemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
El@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
EK@PYGbe[=]@PYGbe[-]@PYGaw[90]@PYGbe[*]mV
ENa@PYGbe[=]@PYGaw[50]@PYGbe[*]mV
g_na@PYGbe[=](@PYGaw[100]@PYGbe[*]msiemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
g_kd@PYGbe[=](@PYGaw[30]@PYGbe[*]msiemens@PYGbe[*]cm@PYGbe[*]@PYGbe[*]@PYGbe[-]@PYGaw[2])@PYGbe[*]area
VT@PYGbe[=]@PYGbe[-]@PYGaw[63]@PYGbe[*]mV
@PYGaD[# Time constants]
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]ms
taui@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
@PYGaD[# Reversal potentials]
Ee@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
Ei@PYGbe[=]@PYGbe[-]@PYGaw[80]@PYGbe[*]mV
we@PYGbe[=]@PYGaw[6]@PYGbe[*]nS @PYGaD[# excitatory synaptic weight (voltage)]
wi@PYGbe[=]@PYGaw[67]@PYGbe[*]nS @PYGaD[# inhibitory synaptic weight]

@PYGaD[# The model]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dv/dt = (gl*(El-v)+ge*(Ee-v)+gi*(Ei-v)-]@PYGao[\]
@PYGad[    g_na*(m*m*m)*h*(v-ENa)-]@PYGao[\]
@PYGad[    g_kd*(n*n*n*n)*(v-EK))/Cm : volt]
@PYGad[dm/dt = alpham*(1-m)-betam*m : 1]
@PYGad[dn/dt = alphan*(1-n)-betan*n : 1]
@PYGad[dh/dt = alphah*(1-h)-betah*h : 1]
@PYGad[dge/dt = -ge*(1./taue) : siemens]
@PYGad[dgi/dt = -gi*(1./taui) : siemens]
@PYGad[alpham = 0.32*(mV**-1)*(13*mV-v+VT)/ ]@PYGao[\]
@PYGad[    (exp((13*mV-v+VT)/(4*mV))-1.)/ms : Hz]
@PYGad[betam = 0.28*(mV**-1)*(v-VT-40*mV)/ ]@PYGao[\]
@PYGad[    (exp((v-VT-40*mV)/(5*mV))-1)/ms : Hz]
@PYGad[alphah = 0.128*exp((17*mV-v+VT)/(18*mV))/ms : Hz]
@PYGad[betah = 4./(1+exp((40*mV-v+VT)/(5*mV)))/ms : Hz]
@PYGad[alphan = 0.032*(mV**-1)*(15*mV-v+VT)/ ]@PYGao[\]
@PYGad[    (exp((15*mV-v+VT)/(5*mV))-1.)/ms : Hz]
@PYGad[betan = .5*exp((10*mV-v+VT)/(40*mV))/ms : Hz]
@PYGad['''])

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,
    threshold@PYGbe[=]EmpiricalThreshold(threshold@PYGbe[=]@PYGbe[-]@PYGaw[20]@PYGbe[*]mV,
                                 refractory@PYGbe[=]@PYGaw[3]@PYGbe[*]ms),
    implicit@PYGbe[=]@PYGaA[True],freeze@PYGbe[=]@PYGaA[True])
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]wi)
@PYGaD[# Initialization]
P@PYGbe[.]v@PYGbe[=]El@PYGbe[+](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[5]@PYGbe[-]@PYGaw[5])@PYGbe[*]mV
P@PYGbe[.]ge@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[1.5]@PYGbe[+]@PYGaw[4])@PYGbe[*]@PYGaw[10.]@PYGbe[*]nS
P@PYGbe[.]gi@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[12]@PYGbe[+]@PYGaw[20])@PYGbe[*]@PYGaw[10.]@PYGbe[*]nS

@PYGaD[# Record the number of spikes and a few traces]
trace@PYGbe[=]StateMonitor(P,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[1],@PYGaw[10],@PYGaw[100]@rb[])

run(@PYGaw[1]@PYGbe[*]second)

plot(trace@lb[]@PYGaw[1]@rb[])
plot(trace@lb[]@PYGaw[10]@rb[])
plot(trace@lb[]@PYGaw[100]@rb[])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-30}{}\subsection{Example: correlated\_inputs}

An example with correlated spike trains
From: Brette, R. (2007). Generation of correlated spike trains.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.correlatedspikes] @PYGay[import] @PYGbe[*]

@PYGaX[input]@PYGbe[=]HomogeneousCorrelatedSpikeTrains(@PYGaw[1000],r@PYGbe[=]@PYGaw[30]@PYGbe[*]Hz,c@PYGbe[=]@PYGaw[0.05],tauc@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)

S@PYGbe[=]SpikeMonitor(@PYGaX[input])
S2@PYGbe[=]PopulationRateMonitor(@PYGaX[input])
M@PYGbe[=]StateMonitor(@PYGaX[input],@PYGad[']@PYGad[rate]@PYGad['],record@PYGbe[=]@PYGaA[True])
run(@PYGaw[1000]@PYGbe[*]ms)
subplot(@PYGaw[211])
raster_plot(S)
subplot(@PYGaw[212])
plot(S2@PYGbe[.]times@PYGbe[/]ms,S2@PYGbe[.]smooth_rate(@PYGaw[5]@PYGbe[*]ms))
plot(M@PYGbe[.]times@PYGbe[/]ms,M@lb[]@PYGaw[0]@rb[]@PYGbe[/]Hz)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{PopulationSpikeCounter}\indexii{example usage}{Connection}\indexii{example usage}{Equations}

\hypertarget{index-21}{}\subsection{Example: CUBA}

This is a Brian script implementing a benchmark described
in the following review paper:

Simulation of networks of spiking neurons: A review of tools and strategies (2007).
Brette, Rudolph, Carnevale, Hines, Beeman, Bower, Diesmann, Goodman, Harris, Zirpe,
Natschlager, Pecevski, Ermentrout, Djurfeldt, Lansner, Rochel, Vibert, Alvarez, Muller,
Davison, El Boustani and Destexhe.
Journal of Computational Neuroscience 23(3):349-98

Benchmark 2: random network of integrate-and-fire neurons with exponential synaptic currents

Clock-driven implementation with exact subthreshold integration
(but spike times are aligned to the grid)


\subsubsection{R. Brette - Oct 2007}

Brian is a simulator for spiking neural networks written in Python, developed by
R. Brette and D. Goodman.
\href{http://brian.di.ens.fr}{http://brian.di.ens.fr}

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

start_time@PYGbe[=]time@PYGbe[.]time()
taum@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]ms
taui@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
Vt@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV
Vr@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
El@PYGbe[=]@PYGbe[-]@PYGaw[49]@PYGbe[*]mV

eqs@PYGbe[=] Equations(@PYGad[''']
@PYGad[dv/dt  = (ge+gi-(v-El))/taum : volt]
@PYGad[dge/dt = -ge/taue : volt]
@PYGad[dgi/dt = -gi/taui : volt]
@PYGad['''])

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr,refractory@PYGbe[=]@PYGaw[5]@PYGbe[*]ms)
P@PYGbe[.]v@PYGbe[=]Vr
P@PYGbe[.]ge@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
P@PYGbe[.]gi@PYGbe[=]@PYGaw[0]@PYGbe[*]mV

Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
we@PYGbe[=](@PYGaw[60]@PYGbe[*]@PYGaw[0.27]@PYGbe[/]@PYGaw[10])@PYGbe[*]mV @PYGaD[# excitatory synaptic weight (voltage)]
wi@PYGbe[=](@PYGbe[-]@PYGaw[20]@PYGbe[*]@PYGaw[4.5]@PYGbe[/]@PYGaw[10])@PYGbe[*]mV @PYGaD[# inhibitory synaptic weight]
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]wi)
P@PYGbe[.]v@PYGbe[=]Vr@PYGbe[+]rand(@PYGaX[len](P))@PYGbe[*](Vt@PYGbe[-]Vr)

@PYGaD[# Record the number of spikes]
Me@PYGbe[=]PopulationSpikeCounter(Pe)
Mi@PYGbe[=]PopulationSpikeCounter(Pi)
@PYGaD[# A population rate monitor]
M @PYGbe[=] PopulationRateMonitor(P)

@PYGay[print] @PYGad["]@PYGad[Network construction time:]@PYGad["],time@PYGbe[.]time()@PYGbe[-]start_time,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] @PYGaX[len](P),@PYGad["]@PYGad[neurons in the network]@PYGad["]
@PYGay[print] @PYGad["]@PYGad[Simulation running...]@PYGad["]
run(@PYGaw[1]@PYGbe[*]msecond)
start_time@PYGbe[=]time@PYGbe[.]time()

run(@PYGaw[1]@PYGbe[*]second)

duration@PYGbe[=]time@PYGbe[.]time()@PYGbe[-]start_time
@PYGay[print] @PYGad["]@PYGad[Simulation time:]@PYGad["],duration,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] Me@PYGbe[.]nspikes,@PYGad["]@PYGad[excitatory spikes]@PYGad["]
@PYGay[print] Mi@PYGbe[.]nspikes,@PYGad["]@PYGad[inhibitory spikes]@PYGad["]
plot(M@PYGbe[.]times@PYGbe[/]ms,M@PYGbe[.]smooth_rate(@PYGaw[2]@PYGbe[*]ms,@PYGad[']@PYGad[gaussian]@PYGad[']))
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{Equations}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-31}{}\subsection{Example: current\_clamp}

An example of single-electrode current clamp recording
with bridge compensation (using the electrophysiology library).

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.electrophysiology] @PYGay[import] @PYGbe[*]

taum@PYGbe[=]@PYGaw[20]@PYGbe[*]ms        @PYGaD[# membrane time constant]
gl@PYGbe[=]@PYGaw[1.]@PYGbe[/](@PYGaw[50]@PYGbe[*]Mohm)   @PYGaD[# leak conductance]
Cm@PYGbe[=]taum@PYGbe[*]gl        @PYGaD[# membrane capacitance]
Re@PYGbe[=]@PYGaw[50]@PYGbe[*]Mohm        @PYGaD[# electrode resistance]
Ce@PYGbe[=]@PYGaw[0.5]@PYGbe[*]ms@PYGbe[/]Re      @PYGaD[# electrode capacitance]

eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dvm/dt=(-gl*vm+i_inj)/Cm : volt]
@PYGad[Rbridge:ohm # bridge resistance]
@PYGad[I:amp # command current]
@PYGad['''])
eqs@PYGbe[+]@PYGbe[=]current_clamp(i_cmd@PYGbe[=]@PYGad[']@PYGad[I]@PYGad['],Re@PYGbe[=]Re,Ce@PYGbe[=]Ce,bridge@PYGbe[=]@PYGad[']@PYGad[Rbridge]@PYGad['])
setup@PYGbe[=]NeuronGroup(@PYGaw[1],model@PYGbe[=]eqs)
soma@PYGbe[=]StateMonitor(setup,@PYGad[']@PYGad[vm]@PYGad['],record@PYGbe[=]@PYGaA[True])
recording@PYGbe[=]StateMonitor(setup,@PYGad[']@PYGad[v_rec]@PYGad['],record@PYGbe[=]@PYGaA[True])

@PYGaD[# No compensation]
run(@PYGaw[50]@PYGbe[*]ms)
setup@PYGbe[.]I@PYGbe[=]@PYGbe[.]@PYGaw[5]@PYGbe[*]nA
run(@PYGaw[100]@PYGbe[*]ms)
setup@PYGbe[.]I@PYGbe[=]@PYGaw[0]@PYGbe[*]nA
run(@PYGaw[50]@PYGbe[*]ms)

@PYGaD[# Full compensation]
setup@PYGbe[.]Rbridge@PYGbe[=]Re
run(@PYGaw[50]@PYGbe[*]ms)
setup@PYGbe[.]I@PYGbe[=]@PYGbe[.]@PYGaw[5]@PYGbe[*]nA
run(@PYGaw[100]@PYGbe[*]ms)
setup@PYGbe[.]I@PYGbe[=]@PYGaw[0]@PYGbe[*]nA
run(@PYGaw[50]@PYGbe[*]ms)

plot(recording@PYGbe[.]times@PYGbe[/]ms,recording@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV,@PYGad[']@PYGad[b]@PYGad['])
plot(soma@PYGbe[.]times@PYGbe[/]ms,soma@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV,@PYGad[']@PYGad[r]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{run}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-32}{}\subsection{Example: delays}

Random network with external noise and transmission delays

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
sigma@PYGbe[=]@PYGaw[5]@PYGbe[*]mV
eqs@PYGbe[=]@PYGad[']@PYGad[dv/dt = -v/tau+sigma*xi/tau**.5 : volt]@PYGad[']
P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,\
              refractory@PYGbe[=]@PYGaw[5]@PYGbe[*]ms)
P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
C@PYGbe[=]Connection(P,P,@PYGad[']@PYGad[v]@PYGad['],delay@PYGbe[=]@PYGaw[2]@PYGbe[*]ms)
C@PYGbe[.]connect_random(Pe, P, @PYGaw[0.05],weight@PYGbe[=]@PYGbe[.]@PYGaw[7]@PYGbe[*]mV)
C@PYGbe[.]connect_random(Pi, P, @PYGaw[0.05],weight@PYGbe[=]@PYGbe[-]@PYGaw[2.8]@PYGbe[*]mV)
M@PYGbe[=]SpikeMonitor(P,@PYGaA[True])
run(@PYGaw[1]@PYGbe[*]second)
@PYGay[print] @PYGad[']@PYGad[Mean rate =]@PYGad['],M@PYGbe[.]nspikes@PYGbe[/]@PYGaw[4000.]@PYGbe[/]second
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{IdentityConnection}\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{Current}\indexii{example usage}{PoissonGroup}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-33}{}\subsection{Example: expIF\_network}

A network of exponential IF models with synaptic conductances

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.IF] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.synapses] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF
taum@PYGbe[=]@PYGaw[10]@PYGbe[*]msecond
gL@PYGbe[=]C@PYGbe[/]taum
EL@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV
VT@PYGbe[=]@PYGbe[-]@PYGaw[55]@PYGbe[*]mV
DeltaT@PYGbe[=]@PYGaw[3]@PYGbe[*]mV

@PYGaD[# Synapse parameters]
Ee@PYGbe[=]@PYGaw[0]@PYGbe[*]mvolt
Ei@PYGbe[=]@PYGbe[-]@PYGaw[80]@PYGbe[*]mvolt
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]msecond
taui@PYGbe[=]@PYGaw[10]@PYGbe[*]msecond

eqs@PYGbe[=]exp_IF(C,gL,EL,VT,DeltaT)
@PYGaD[# Two different ways of adding synaptic currents:]
eqs@PYGbe[+]@PYGbe[=]Current(@PYGad[''']
@PYGad[Ie=ge*(Ee-vm) : amp]
@PYGad[dge/dt=-ge/taue : siemens]
@PYGad['''])
eqs@PYGbe[+]@PYGbe[=]exp_conductance(@PYGad[']@PYGad[gi]@PYGad['],Ei,taui) @PYGaD[# from library.synapses]

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[20]@PYGbe[*]mvolt,reset@PYGbe[=]EL,refractory@PYGbe[=]@PYGaw[2]@PYGbe[*]ms)
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
we@PYGbe[=]@PYGaw[1.5]@PYGbe[*]nS @PYGaD[# excitatory synaptic weight]
wi@PYGbe[=]@PYGaw[2.5]@PYGbe[*]we @PYGaD[# inhibitory synaptic weight]
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.05],weight@PYGbe[=]we)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.05],weight@PYGbe[=]wi)
@PYGaD[# Initialization]
P@PYGbe[.]vm@PYGbe[=]randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[10]@PYGbe[*]mV@PYGbe[-]@PYGaw[70]@PYGbe[*]mV
P@PYGbe[.]ge@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[2]@PYGbe[+]@PYGaw[5])@PYGbe[*]we
P@PYGbe[.]gi@PYGbe[=](randn(@PYGaX[len](P))@PYGbe[*]@PYGaw[2]@PYGbe[+]@PYGaw[5])@PYGbe[*]wi

@PYGaD[# Excitatory input to a subset of excitatory and inhibitory neurons]
@PYGaD[# Excitatory neurons are excited for the first 200 ms]
@PYGaD[# Inhibitory neurons are excited for the first 100 ms]
input_layer1@PYGbe[=]Pe@PYGbe[.]subgroup(@PYGaw[200])
input_layer2@PYGbe[=]Pi@PYGbe[.]subgroup(@PYGaw[200])
input1@PYGbe[=]PoissonGroup(@PYGaw[200],rates@PYGbe[=]@PYGay[lambda] t: (t@PYGbe[<]@PYGaw[200]@PYGbe[*]ms @PYGan[and] @PYGaw[2000]@PYGbe[*]Hz) @PYGan[or] @PYGaw[0]@PYGbe[*]Hz)
input2@PYGbe[=]PoissonGroup(@PYGaw[200],rates@PYGbe[=]@PYGay[lambda] t: (t@PYGbe[<]@PYGaw[100]@PYGbe[*]ms @PYGan[and] @PYGaw[2000]@PYGbe[*]Hz) @PYGan[or] @PYGaw[0]@PYGbe[*]Hz)
input_co1@PYGbe[=]IdentityConnection(input1,input_layer1,@PYGad[']@PYGad[ge]@PYGad['],weight@PYGbe[=]we)
input_co2@PYGbe[=]IdentityConnection(input2,input_layer2,@PYGad[']@PYGad[ge]@PYGad['],weight@PYGbe[=]we)

@PYGaD[# Record the number of spikes]
M@PYGbe[=]SpikeMonitor(P)

@PYGay[print] @PYGad["]@PYGad[Simulation running...]@PYGad["]
start_time@PYGbe[=]time@PYGbe[.]time()
run(@PYGaw[500]@PYGbe[*]ms)
duration@PYGbe[=]time@PYGbe[.]time()@PYGbe[-]start_time
@PYGay[print] @PYGad["]@PYGad[Simulation time:]@PYGad["],duration,@PYGad["]@PYGad[seconds]@PYGad["]
@PYGay[print] M@PYGbe[.]nspikes@PYGbe[/]@PYGaw[4000.],@PYGad["]@PYGad[spikes per neuron]@PYGad["]
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{raster\_plot}\indexii{example usage}{network\_operation}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-34}{}\subsection{Example: gap\_junctions}

Network of noisy IF neurons with gap junctions

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[300]
v0@PYGbe[=]@PYGaw[5]@PYGbe[*]mV
tau@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
sigma@PYGbe[=]@PYGaw[5]@PYGbe[*]mV
vt@PYGbe[=]@PYGaw[10]@PYGbe[*]mV
vr@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
g_gap@PYGbe[=]@PYGaw[1.]@PYGbe[/]N
beta@PYGbe[=]@PYGaw[60]@PYGbe[*]mV@PYGbe[*]@PYGaw[2]@PYGbe[*]ms
delta@PYGbe[=]vt@PYGbe[-]vr

eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(v0-v)/tau+g_gap*(u-N*v)/tau : volt]
@PYGad[du/dt=(N*v0-u)/tau : volt # input from other neurons]
@PYGad[''']

@PYGay[def] @PYGaK[myreset](P,spikes):
    P@PYGbe[.]v_@lb[]spikes@rb[]@PYGbe[=]vr @PYGaD[# reset]
    P@PYGbe[.]v_@PYGbe[+]@PYGbe[=]g_gap@PYGbe[*]beta@PYGbe[*]@PYGaX[len](spikes) @PYGaD[# spike effect]
    P@PYGbe[.]u_@PYGbe[-]@PYGbe[=]delta@PYGbe[*]@PYGaX[len](spikes)

group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]vt,reset@PYGbe[=]myreset)

@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[noise](cl):
    x@PYGbe[=]randn(N)@PYGbe[*]sigma@PYGbe[*](cl@PYGbe[.]dt@PYGbe[/]tau)@PYGbe[*]@PYGbe[*]@PYGbe[.]@PYGaw[5]
    group@PYGbe[.]v_@PYGbe[+]@PYGbe[=]x
    group@PYGbe[.]u_@PYGbe[+]@PYGbe[=]@PYGaX[sum](x)

trace@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[0],@PYGaw[1]@rb[])
spikes@PYGbe[=]SpikeMonitor(group)
rate@PYGbe[=]PopulationRateMonitor(group)

run(@PYGaw[1]@PYGbe[*]second)
subplot(@PYGaw[311])
raster_plot(spikes)
subplot(@PYGaw[312])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[1]@rb[]@PYGbe[/]mV)
subplot(@PYGaw[313])
plot(rate@PYGbe[.]times@PYGbe[/]ms,rate@PYGbe[.]smooth_rate(@PYGaw[5]@PYGbe[*]ms)@PYGbe[/]Hz)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{Current}\indexii{example usage}{MembraneEquation}\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-22}{}\subsection{Example: HodgkinHuxley}

Hodgkin-Huxley model
Assuming area 1*cm**2

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[#import brian_no_units]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.ionic_currents] @PYGay[import] @PYGbe[*]

@PYGaD[#c=Clock(dt=.01*ms) # more precise]
El@PYGbe[=]@PYGaw[10.6]@PYGbe[*]mV
EK@PYGbe[=]@PYGbe[-]@PYGaw[12]@PYGbe[*]mV
ENa@PYGbe[=]@PYGaw[120]@PYGbe[*]mV
eqs@PYGbe[=]MembraneEquation(@PYGaw[1]@PYGbe[*]uF)@PYGbe[+]leak_current(@PYGbe[.]@PYGaw[3]@PYGbe[*]msiemens,El)
eqs@PYGbe[+]@PYGbe[=]K_current_HH(@PYGaw[36]@PYGbe[*]msiemens,EK)@PYGbe[+]Na_current_HH(@PYGaw[120]@PYGbe[*]msiemens,ENa)
eqs@PYGbe[+]@PYGbe[=]Current(@PYGad[']@PYGad[I:amp]@PYGad['])

neuron@PYGbe[=]NeuronGroup(@PYGaw[1],eqs,implicit@PYGbe[=]@PYGaA[True],freeze@PYGbe[=]@PYGaA[True])

trace@PYGbe[=]StateMonitor(neuron,@PYGad[']@PYGad[vm]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[100]@PYGbe[*]ms)
neuron@PYGbe[.]I@PYGbe[=]@PYGaw[10]@PYGbe[*]uA
run(@PYGaw[100]@PYGbe[*]ms)
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{Current}\indexii{example usage}{IdentityConnection}\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-23}{}\subsection{Example: I-F\_curve}

Input-Frequency curve of a neuron (cortical RS type)
Network: 1000 unconnected integrate-and-fire neurons (Brette-Gerstner)
with an input parameter I.
The input is set differently for each neuron.
Spikes are sent to a `neuron' group with the same size and variable n,
which has the role of a spike counter.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.IF] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[1000]
eqs@PYGbe[=]Brette_Gerstner()@PYGbe[+]Current(@PYGad[']@PYGad[I:amp]@PYGad['])
group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[20]@PYGbe[*]mV,reset@PYGbe[=]AdaptiveReset())
group@PYGbe[.]vm@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV
group@PYGbe[.]I@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]nA,@PYGaw[1]@PYGbe[*]nA,N)

counter@PYGbe[=]NeuronGroup(N,model@PYGbe[=]@PYGad[']@PYGad[n:1]@PYGad['])
C@PYGbe[=]IdentityConnection(group,counter,@PYGad[']@PYGad[n]@PYGad['])

i@PYGbe[=]N@PYGbe[*]@PYGaw[8]@PYGbe[/]@PYGaw[10]
trace@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[vm]@PYGad['],record@PYGbe[=]i)

duration@PYGbe[=]@PYGaw[5]@PYGbe[*]second
run(duration)
subplot(@PYGaw[211])
plot(group@PYGbe[.]I@PYGbe[/]nA,counter@PYGbe[.]n@PYGbe[/]duration)
xlabel(@PYGad[']@PYGad[I (nA)]@PYGad['])
ylabel(@PYGad[']@PYGad[Firing rate (Hz)]@PYGad['])
subplot(@PYGaw[212])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]i@rb[]@PYGbe[/]mV)
xlabel(@PYGad[']@PYGad[Time (ms)]@PYGad['])
ylabel(@PYGad[']@PYGad[Vm (mV)]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{SpikeCounter}

\hypertarget{index-24}{}\subsection{Example: I-F\_curve2}

Input-Frequency curve of a IF model
Network: 1000 unconnected integrate-and-fire neurons (Brette-Gerstner)
with an input parameter I.
The input is set differently for each neuron.
Spikes are sent to a `neuron' group with the same size and variable n,
which has the role of a spike counter.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[1000]
tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(v0-v)/tau : volt]
@PYGad[v0 : volt]
@PYGad[''']
group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,refractory@PYGbe[=]@PYGaw[5]@PYGbe[*]ms)
group@PYGbe[.]v@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
group@PYGbe[.]v0@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]mV,@PYGaw[20]@PYGbe[*]mV,N)

counter@PYGbe[=]SpikeCounter(group)

duration@PYGbe[=]@PYGaw[5]@PYGbe[*]second
run(duration)
plot(group@PYGbe[.]v0@PYGbe[/]mV,counter@PYGbe[.]count@PYGbe[/]duration)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{SpikeGeneratorGroup}\indexii{example usage}{Connection}\indexii{example usage}{Model}\indexii{example usage}{StateMonitor}

\hypertarget{index-35}{}\subsection{Example: if}

A very simple example Brian script to show how to implement
an integrate and fire model. In this example, we also
drive the single integrate and fire neuron with
regularly spaced spikes from the \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
Vr @PYGbe[=] @PYGbe[-]@PYGaw[70]@PYGbe[*]mV
Vt @PYGbe[=] @PYGbe[-]@PYGaw[55]@PYGbe[*]mV

model @PYGbe[=] Model(equations@PYGbe[=]@PYGad[''']
@PYGad[    V : volt]
@PYGad[    ]@PYGad['''], threshold@PYGbe[=]Vt, reset@PYGbe[=]Vr)
G @PYGbe[=] NeuronGroup(@PYGaw[1],model)

@PYGaX[input] @PYGbe[=] SpikeGeneratorGroup(@PYGaw[1],@lb[](@PYGaw[0],t@PYGbe[*]ms) @PYGay[for] t @PYGan[in] linspace(@PYGaw[10],@PYGaw[100],@PYGaw[25])@rb[])

C @PYGbe[=] Connection(@PYGaX[input], G)
C@lb[]@PYGaw[0],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[2]@PYGbe[*]mV

M @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[V]@PYGad['], record@PYGbe[=]@PYGaA[True])

G@PYGbe[.]V @PYGbe[=] Vr
run(@PYGaw[100]@PYGbe[*]ms)
plot(M@PYGbe[.]times@PYGbe[/]ms,M@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{MultipleSpikeGeneratorGroup}\indexii{example usage}{run}\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{Model}\indexii{example usage}{StateMonitor}

\hypertarget{index-36}{}\subsection{Example: leaky\_if}

A very simple example Brian script to show how to implement
a leaky integrate and fire model. In this example, we also
drive the single leaky integrate and fire neuron with
regularly spaced spikes from the \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
Vr @PYGbe[=] @PYGbe[-]@PYGaw[70]@PYGbe[*]mV
Vt @PYGbe[=] @PYGbe[-]@PYGaw[55]@PYGbe[*]mV

model @PYGbe[=] Model(equations@PYGbe[=]@PYGad[''']
@PYGad[    dV/dt = -(V-Vr)/tau : volt]
@PYGad[    ]@PYGad['''], threshold@PYGbe[=]Vt, reset@PYGbe[=]Vr)
G @PYGbe[=] NeuronGroup(@PYGaw[1],model)

spikes @PYGbe[=] linspace(@PYGaw[10]@PYGbe[*]ms,@PYGaw[100]@PYGbe[*]ms,@PYGaw[25])
@PYGaX[input] @PYGbe[=] MultipleSpikeGeneratorGroup(@lb[]spikes@rb[])

C @PYGbe[=] Connection(@PYGaX[input], G)
C@lb[]@PYGaw[0],@PYGaw[0]@rb[] @PYGbe[=] @PYGaw[5]@PYGbe[*]mV

M @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[V]@PYGad['], record@PYGbe[=]@PYGaA[True])

G@PYGbe[.]V @PYGbe[=] Vr
run(@PYGaw[100]@PYGbe[*]ms)
plot(M@PYGbe[.]times@PYGbe[/]ms,M@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{run}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-37}{}\subsection{Example: minimalexample}

Very short example program.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad[''']

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,
              threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,reset@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV)
P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV@PYGbe[+]@PYGaw[10]@PYGbe[*]mV@PYGbe[*]rand(@PYGaX[len](P))
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])

Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]@PYGaw[1.62]@PYGbe[*]mV)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)

M@PYGbe[=]SpikeMonitor(P)

run(@PYGaw[1]@PYGbe[*]second)
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{run}

\hypertarget{index-38}{}\subsection{Example: mirollo\_strogatz}

Mirollo-Strogatz network

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
v0@PYGbe[=]@PYGaw[11]@PYGbe[*]mV
N@PYGbe[=]@PYGaw[20]
w@PYGbe[=]@PYGbe[.]@PYGaw[1]@PYGbe[*]mV

group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]@PYGad[']@PYGad[dv/dt=(v0-v)/tau : volt]@PYGad['],threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV)

W@PYGbe[=]Connection(group,group,@PYGad[']@PYGad[v]@PYGad['])
W@PYGbe[.]connect_full(group,group,weight@PYGbe[=]w)

group@PYGbe[.]v@PYGbe[=]rand(N)@PYGbe[*]@PYGaw[10]@PYGbe[*]mV

S@PYGbe[=]SpikeMonitor(group)

run(@PYGaw[300]@PYGbe[*]ms)

raster_plot(S)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{Clock}\indexii{example usage}{network\_operation}\indexii{example usage}{Model}\indexii{example usage}{StateMonitor}

\hypertarget{index-39}{}\subsection{Example: multipleclocks}

This example demonstrates using different clocks for different objects
in the network. The clock \code{simclock} is the clock used for the
underlying simulation. The clock \code{monclock} is the clock used for
monitoring the membrane potential. This monitoring takes place less
frequently than the simulation update step to save time and memory.
Finally, the clock \code{inputclock} controls when the external `current'
\code{Iext} should be updated. In this  case, we update it infrequently
so we can see the effect on the network.

This example also demonstrates the @network\_operation decorator. A
function with this decorator will be run as part of the network
update step, in sync with the clock provided (or the default one
if none is provided).

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaD[# define the three clocks]
simclock   @PYGbe[=] Clock(dt@PYGbe[=]@PYGaw[0.1]@PYGbe[*]ms)
monclock   @PYGbe[=] Clock(dt@PYGbe[=]@PYGaw[0.3]@PYGbe[*]ms)
inputclock @PYGbe[=] Clock(dt@PYGbe[=]@PYGaw[100]@PYGbe[*]ms)
@PYGaD[# simple leaky I&F model with external 'current' Iext as a parameter]
tau @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
eqs@PYGbe[=]@PYGad[''']
@PYGad[dV/dt = (-V+Iext)/tau : volt]
@PYGad[Iext: volt]
@PYGad[''']
@PYGaD[# A single leaky I&F neuron with simclock as its clock]
model @PYGbe[=] Model(equation@PYGbe[=]eqs, reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV, threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV, clock@PYGbe[=]simclock)
G @PYGbe[=] NeuronGroup(@PYGaw[1], model@PYGbe[=]model)
G@PYGbe[.]V@PYGbe[=]@PYGaw[5]@PYGbe[*]mV
@PYGaD[# This function will be run in sync with inputclock i.e. every 100 ms]
@PYGaC[@at[]network_operation](clock@PYGbe[=]inputclock)
@PYGay[def] @PYGaK[update_Iext]():
    G@PYGbe[.]Iext @PYGbe[=] rand(@PYGaX[len](G)) @PYGbe[*] @PYGaw[20] @PYGbe[*] mV
@PYGaD[# V is monitored in sync with monclock]
MV @PYGbe[=] StateMonitor(G, @PYGad[']@PYGad[V]@PYGad['], record@PYGbe[=]@PYGaw[0], clock@PYGbe[=]monclock)
@PYGaD[# run and plot]
run(@PYGaw[1000]@PYGbe[*]ms)
plot(MV@PYGbe[.]times@PYGbe[/]ms, MV@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
show()
@PYGaD[# You should see 10 different regions, sometimes Iext will be above threshold]
@PYGaD[# in which case you will see regular spiking at different rates, and sometimes]
@PYGaD[# it will be below threshold in which case you'll see exponential decay to that]
@PYGaD[# value]
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{Threshold}\indexii{example usage}{Refractoriness}

\hypertarget{index-40}{}\subsection{Example: named\_threshold}

Example with named threshold and reset variables

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad[dx/dt = (ge+gi-(x+49*mV))/(20*ms) : volt]
@PYGad[''']
P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]Threshold(@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,state@PYGbe[=]@PYGad[']@PYGad[x]@PYGad[']),\
              reset@PYGbe[=]Refractoriness(@PYGbe[-]@PYGaw[60]@PYGbe[*]mV,@PYGaw[5]@PYGbe[*]ms,state@PYGbe[=]@PYGad[']@PYGad[x]@PYGad[']))
@PYGaD[#P=NeuronGroup(4000,model=eqs,threshold=Threshold(-50*mV,state='x'),\]
@PYGaD[#              reset=Reset(-60*mV,state='x')) # without refractoriness]
P@PYGbe[.]x@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]@PYGaw[1.62]@PYGbe[*]mV)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)
M@PYGbe[=]SpikeMonitor(P)
run(@PYGaw[1]@PYGbe[*]second)
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-41}{}\subsection{Example: noisy\_ring}

Integrate-and-fire neurons with noise

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
sigma@PYGbe[=]@PYGbe[.]@PYGaw[5]
N@PYGbe[=]@PYGaw[100]
J@PYGbe[=]@PYGbe[-]@PYGaw[1]
mu@PYGbe[=]@PYGaw[2]

eqs@PYGbe[=]@PYGad["""]
@PYGad[dv/dt=mu/tau+sigma/tau**.5*xi : 1]
@PYGad["""]

group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[1],reset@PYGbe[=]@PYGaw[0])

C@PYGbe[=]Connection(group,group,@PYGad[']@PYGad[v]@PYGad['])
@PYGay[for] i @PYGan[in] @PYGaX[range](N):
    C@lb[]i,(i@PYGbe[+]@PYGaw[1]) @PYGbe[%] N@rb[]@PYGbe[=]J

@PYGaD[#C.connect_full(group,group,weight=J)]
@PYGaD[#for i in range(N):]
@PYGaD[#    C@lb[]i,i@rb[]=0]

S@PYGbe[=]SpikeMonitor(group)
trace@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[500]@PYGbe[*]ms)
i,t@PYGbe[=]S@PYGbe[.]spikes@lb[]@PYGbe[-]@PYGaw[1]@rb[]

subplot(@PYGaw[211])
raster_plot(S)
subplot(@PYGaw[212])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[0]@rb[])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{ppfunction}

\hypertarget{index-42}{}\subsection{Example: parallelpython}

Example of using Parallel Python `pp' module for running multiple jobs

See (limited) documentation for PP at their website:
\begin{quote}

\href{http://www.parallelpython.com/}{http://www.parallelpython.com/}
\end{quote}

Each job server must have an up to date copy of Brian installed on it, and
must run the pp jobserver script as follows:
\begin{quote}

ppserver.py -a -s ``He's not the Messiah, he's a very naughty boy''
\end{quote}

This ppserver.py script is installed in the Scripts/ folder of your
Python installation when you install pp. The -a option sets it to
auto-discovery mode, so that nodes on your cluster running the ppserver
can be automatically found by a process submitting jobs to it. The -s
option is a shared secret, basically a password to prevent external
access.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[pp]

@PYGaD[# We create a pp job server in one of the following ways (see pp documentation for more info):]

@PYGaD[#js = pp.Server(ppservers=('computer1.complete.domain.name','computer2.complete.domain.name')) # For running over the internet]
@PYGaD[#js = pp.Server(ppservers=('computer1','computer2')) # For running over the local network]
@PYGaD[#js = pp.Server(ppservers=('*',)) # For running with autodiscovery mode over the local network]
js @PYGbe[=] pp@PYGbe[.]Server(ppservers@PYGbe[=]()) @PYGaD[# For running only on your own computer (but using multiple CPU cores)]

@PYGaD[# Now we write a function which defines the job to be executed. Note that]
@PYGaD[# there are some annoying features of pp: functions cannot use any global]
@PYGaD[# variables, so we have to import all the Brian functions etc. inside the]
@PYGaD[# function. However, we have a function decorator @at[]ppfunction which does]
@PYGaD[# the work for you. Unfortunately, it needs to create an external file]
@PYGaD[# which will be named modulename_functionname_parallelpythonised.py, so]
@PYGaD[# in this example it will be called:]
@PYGaD[#   parallelpython_howmanyspikes_parallelpythonised.py]
@PYGaD[# This file contains the transformed code to make it work smoothly with]
@PYGaD[# parallelpython.]

@PYGaC[@at[]ppfunction]
@PYGay[def] @PYGaK[howmanyspikes](excitatory_weight):
    eqs@PYGbe[=]@PYGad[''']
@PYGad[    dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[    dge/dt = -ge/(5*ms) : volt]
@PYGad[    dgi/dt = -gi/(10*ms) : volt]
@PYGad[    ]@PYGad[''']
    P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,reset@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV)
    P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV@PYGbe[+]@PYGaw[10]@PYGbe[*]mV@PYGbe[*]rand(@PYGaX[len](P))
    Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
    Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
    Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
    Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
    Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]excitatory_weight)
    Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)
    M@PYGbe[=]SpikeMonitor(P)
    run(@PYGaw[100]@PYGbe[*]ms)
    @PYGay[return] M@PYGbe[.]nspikes

@PYGaD[# Now we submit jobs. See the pp documentation details of what is going on here.]
@PYGaD[# In short write j = js.submit(func, args, depfuncs, modules) to submit function]
@PYGaD[# func with arguments args (which should be a tuple of values), depending on]
@PYGaD[# functions depfuncs (a tuple of functions), relying on modules (another tuple]
@PYGaD[# of strings). The job is submitted. To get the result of a job, you write]
@PYGaD[# val = j(), but executing this line will wait until the job is complete.]

@PYGaD[# Single job]

@PYGaD[#f = js.submit(howmanyspikes, (1.62*mV,), (), ('brian','numpy'))]
@PYGaD[#print f()]

@PYGaD[# Multiple jobs, and results plotted]

excitatory_weight_range @PYGbe[=] linspace(@PYGaw[0],@PYGaw[4],@PYGaw[20])
jobs @PYGbe[=] @lb[] js@PYGbe[.]submit(howmanyspikes, (ew@PYGbe[*]mV,), (), (@PYGad[']@PYGad[brian]@PYGad['],@PYGad[']@PYGad[numpy]@PYGad['])) @PYGay[for] ew @PYGan[in] excitatory_weight_range @rb[]
numspikes @PYGbe[=] @lb[] j() @PYGay[for] j @PYGan[in] jobs @rb[]

js@PYGbe[.]print_stats()

plot(excitatory_weight_range, numspikes)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-43}{}\subsection{Example: phase\_locking}

Phase locking of IF neurons to a periodic input

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
N@PYGbe[=]@PYGaw[100]
b@PYGbe[=]@PYGaw[1.2] @PYGaD[# constant current mean, the modulation varies]
f@PYGbe[=]@PYGaw[10]@PYGbe[*]Hz

eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(-v+a*sin(2*pi*f*t)+b)/tau : 1]
@PYGad[a : 1]
@PYGad[''']

neurons@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[1],reset@PYGbe[=]@PYGaw[0])
neurons@PYGbe[.]v@PYGbe[=]rand(N)
neurons@PYGbe[.]a@PYGbe[=]linspace(@PYGbe[.]@PYGaw[05],@PYGaw[0.75],N)
S@PYGbe[=]SpikeMonitor(neurons)
trace@PYGbe[=]StateMonitor(neurons,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaw[50])

run(@PYGaw[1000]@PYGbe[*]ms)
subplot(@PYGaw[211])
raster_plot(S)
subplot(@PYGaw[212])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[50]@rb[])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{run}

\hypertarget{index-44}{}\subsection{Example: pickle\_loadnet}

Pickling example, see also pickle\_savenet.py

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[pickle]

inputfile @PYGbe[=] @PYGaX[open](@PYGad[']@PYGad[data.pkl]@PYGad['],@PYGad[']@PYGad[rb]@PYGad['])
obj @PYGbe[=] pickle@PYGbe[.]load(inputfile)
inputfile@PYGbe[.]close()

clk, eqs, P, Pe, Pi, Ce, Ci, M, net @PYGbe[=] obj

net@PYGbe[.]run(@PYGaw[100]@PYGbe[*]ms)
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{Network}\indexii{example usage}{Clock}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-45}{}\subsection{Example: pickle\_savenet}

Pickling example, see also pickle\_loadnet.py

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[pickle]

clk @PYGbe[=] Clock()
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad[''']
P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,reset@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV)
P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]@PYGaw[1.62]@PYGbe[*]mV)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)
M@PYGbe[=]SpikeMonitor(P)
net @PYGbe[=] Network(P, Ce, Ci, M)
net@PYGbe[.]run(@PYGaw[100]@PYGbe[*]ms)

obj @PYGbe[=] (clk, eqs, P, Pe, Pi, Ce, Ci, M, net)

output @PYGbe[=] @PYGaX[open](@PYGad[']@PYGad[data.pkl]@PYGad['], @PYGad[']@PYGad[wb]@PYGad['])
pickle@PYGbe[.]dump(obj,output,@PYGbe[-]@PYGaw[1])
output@PYGbe[.]close()

@PYGaD[# show what we've computed so far...]
raster_plot(M)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{PoissonGroup}\indexii{example usage}{run}

\hypertarget{index-46}{}\subsection{Example: poisson}

This example demonstrates the PoissonGroup object. Here we have
used a custom function to generate different rates at different
times.

This example also demonstrates a custom SpikeMonitor.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[#import brian_no_units # uncomment to run faster]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

@PYGaD[# Rates]

r1 @PYGbe[=] arange(@PYGaw[101], @PYGaw[201])@PYGbe[*]@PYGaw[0.1]@PYGbe[*]Hz
r2 @PYGbe[=] arange(@PYGaw[1], @PYGaw[101])@PYGbe[*]@PYGaw[0.1]@PYGbe[*]Hz

@PYGay[def] @PYGaK[myrates](t):
    @PYGay[if] t@PYGbe[<]@PYGaw[10]@PYGbe[*]second:
        @PYGay[return] r1
    @PYGay[else]:
        @PYGay[return] r2
@PYGaD[# More compact: myrates=lambda t: (t<10*second and r1) or r2]

@PYGaD[# Neuron group]
P@PYGbe[=]PoissonGroup(@PYGaw[100],myrates)

@PYGaD[# Calculation of rates]

ns@PYGbe[=]zeros(@PYGaX[len](P))

@PYGay[def] @PYGaK[ratemonitor](spikes):
    ns@lb[]spikes@rb[]@PYGbe[+]@PYGbe[=]@PYGaw[1]

Mf @PYGbe[=] SpikeMonitor(P,function@PYGbe[=]ratemonitor)
M  @PYGbe[=] SpikeMonitor(P)

@PYGaD[# Simulation and plotting]

run(@PYGaw[10]@PYGbe[*]second)
@PYGay[print] @PYGad["]@PYGad[Rates after 10s:]@PYGad["]
@PYGay[print] ns@PYGbe[/](@PYGaw[10]@PYGbe[*]second)

ns@lb[]:@rb[] @PYGbe[=] @PYGaw[0]
run(@PYGaw[10]@PYGbe[*]second)
@PYGay[print] @PYGad["]@PYGad[Rates after 20s:]@PYGad["]
@PYGay[print] ns@PYGbe[/](@PYGaw[10]@PYGbe[*]second)

raster_plot()
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{Connection}\indexii{example usage}{PoissonGroup}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-47}{}\subsection{Example: poissongroup}

Poisson input to an IF model

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

PG @PYGbe[=] PoissonGroup(@PYGaw[1],@PYGay[lambda] t:@PYGaw[200]@PYGbe[*]Hz@PYGbe[*](@PYGaw[1]@PYGbe[+]cos(@PYGaw[2]@PYGbe[*]pi@PYGbe[*]t@PYGbe[*]@PYGaw[50]@PYGbe[*]Hz)))
IF @PYGbe[=] NeuronGroup(@PYGaw[1],model@PYGbe[=]@PYGad[']@PYGad[dv/dt=-v/(10*ms) : volt]@PYGad['],reset@PYGbe[=]@PYGaw[0]@PYGbe[*]volt,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)

C @PYGbe[=] Connection(PG,IF,@PYGad[']@PYGad[v]@PYGad['])
C@PYGbe[.]connect_full(PG,IF,@PYGaw[3]@PYGbe[*]mV)

MS @PYGbe[=] SpikeMonitor(PG,@PYGaA[True])
Mv @PYGbe[=] StateMonitor(IF,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True])
rates @PYGbe[=] StateMonitor(PG,@PYGad[']@PYGad[rate]@PYGad['],record@PYGbe[=]@PYGaA[True])

run(@PYGaw[100]@PYGbe[*]ms)

subplot(@PYGaw[211])
plot(rates@PYGbe[.]times@PYGbe[/]ms,rates@lb[]@PYGaw[0]@rb[]@PYGbe[/]Hz)
subplot(@PYGaw[212])
plot(Mv@PYGbe[.]times@PYGbe[/]ms,Mv@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)

show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{run}\indexii{example usage}{SpikeGeneratorGroup}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{raster\_plot}\indexii{example usage}{PulsePacket}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-48}{}\subsection{Example: pulsepacket}

This example basically replicates what the Brian PulsePacket object does,
and then compares to that object.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[random] @PYGay[import] gauss, shuffle

@PYGaD[# Generator for pulse packet]
@PYGay[def] @PYGaK[pulse_packet](t, n, sigma):
    @PYGaD[# generate a list of n times with Gaussian distribution, sort them in time, and]
    @PYGaD[# then randomly assign the neuron numbers to them]
    times @PYGbe[=] @lb[]gauss(t, sigma) @PYGay[for] i @PYGan[in] @PYGaX[range](n)@rb[]
    times@PYGbe[.]sort()
    neuron @PYGbe[=] @PYGaX[range](n)
    shuffle(neuron)
    @PYGay[return] @PYGaX[zip](neuron, times) @PYGaD[# returns a list of pairs (i,t)]

G1 @PYGbe[=] SpikeGeneratorGroup(@PYGaw[1000], pulse_packet(@PYGaw[50]@PYGbe[*]ms, @PYGaw[1000], @PYGaw[5]@PYGbe[*]ms))
M1 @PYGbe[=] SpikeMonitor(G1)
PRM1 @PYGbe[=] PopulationRateMonitor(G1,bin@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)

G2 @PYGbe[=] PulsePacket(@PYGaw[50]@PYGbe[*]ms, @PYGaw[1000], @PYGaw[5]@PYGbe[*]ms)
M2 @PYGbe[=] SpikeMonitor(G2)
PRM2 @PYGbe[=] PopulationRateMonitor(G2,bin@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)

run(@PYGaw[100]@PYGbe[*]ms)

subplot(@PYGaw[221])
raster_plot(M1)
subplot(@PYGaw[223])
plot(PRM1@PYGbe[.]rate)
subplot(@PYGaw[222])
raster_plot(M2)
subplot(@PYGaw[224])
plot(PRM2@PYGbe[.]rate)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{PoissonThreshold}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}

\hypertarget{index-49}{}\subsection{Example: rate\_model}

A rate model

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[50000]
tau@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
I@PYGbe[=]@PYGaw[10]@PYGbe[*]Hz
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(I-v)/tau : Hz # note the unit here: this is the output rate]
@PYGad[''']
group@PYGbe[=]NeuronGroup(N,eqs,threshold@PYGbe[=]PoissonThreshold())
S@PYGbe[=]PopulationRateMonitor(group,bin@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)

run(@PYGaw[100]@PYGbe[*]ms)

plot(S@PYGbe[.]rate)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{run}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-50}{}\subsection{Example: ring}

A ring of integrate-and-fire neurons.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
v0@PYGbe[=]@PYGaw[11]@PYGbe[*]mV
N@PYGbe[=]@PYGaw[20]
w@PYGbe[=]@PYGaw[1]@PYGbe[*]mV

ring@PYGbe[=]NeuronGroup(N,model@PYGbe[=]@PYGad[']@PYGad[dv/dt=(v0-v)/tau : volt]@PYGad['],threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV)

W@PYGbe[=]Connection(ring,ring,@PYGad[']@PYGad[v]@PYGad['])
@PYGay[for] i @PYGan[in] @PYGaX[range](N):
    W@lb[]i,(i@PYGbe[+]@PYGaw[1]) @PYGbe[%] N@rb[]@PYGbe[=]w

ring@PYGbe[.]v@PYGbe[=]rand(N)@PYGbe[*]@PYGaw[10]@PYGbe[*]mV

S@PYGbe[=]SpikeMonitor(ring)

run(@PYGaw[300]@PYGbe[*]ms)

raster_plot(S)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{Model}\indexii{example usage}{Network}\indexii{example usage}{Parameters}

\hypertarget{index-51}{}\subsection{Example: sfc}

Implementation of synfire chain from Diesmann et al. 1999

Dan Goodman - Dec. 2007

\begin{Verbatim}[commandchars=@\[\]]
@PYGaD[#import brian_no_units]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[time]

@PYGay[from] @PYGaV[brian.library.IF] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[brian.library.synapses] @PYGay[import] @PYGbe[*]

@PYGay[def] @PYGaK[minimal_example]():
    @PYGaD[# Neuron model parameters]
    Vr @PYGbe[=] @PYGbe[-]@PYGaw[70]@PYGbe[*]mV
    Vt @PYGbe[=] @PYGbe[-]@PYGaw[55]@PYGbe[*]mV
    taum @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
    taupsp @PYGbe[=] @PYGaw[0.325]@PYGbe[*]ms
    weight @PYGbe[=] @PYGaw[4.86] @PYGbe[*] mV
    @PYGaD[# Neuron model]
    equations @PYGbe[=] Equations(@PYGad[''']
@PYGad[        dV/dt = (-(V-Vr)+x)*(1./taum)                            : volt]
@PYGad[        dx/dt = (-x+y)*(1./taupsp)                               : volt]
@PYGad[        dy/dt = -y*(1./taupsp)+25.27*mV/ms+(39.24*mV/ms**0.5)*xi : volt]
@PYGad[        ]@PYGad['''])

    @PYGaD[# Neuron groups]
    P @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[1000], model@PYGbe[=]equations,
                  threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr,refractory@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
@PYGaD[#    P = NeuronGroup(N=1000, model=(dV,dx,dy),init=(0*volt,0*volt,0*volt),]
@PYGaD[#                  threshold=Vt,reset=Vr,refractory=1*ms)]

    Pinput @PYGbe[=] PulsePacket(t@PYGbe[=]@PYGaw[50]@PYGbe[*]ms,n@PYGbe[=]@PYGaw[85],sigma@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
    @PYGaD[# The network structure]
    Pgp @PYGbe[=] @lb[] P@PYGbe[.]subgroup(@PYGaw[100]) @PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[10])@rb[]
    C @PYGbe[=] Connection(P,P,@PYGad[']@PYGad[y]@PYGad['])
    @PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[9]):
        C@PYGbe[.]connect_full(Pgp@lb[]i@rb[],Pgp@lb[]i@PYGbe[+]@PYGaw[1]@rb[],weight)
    Cinput @PYGbe[=] Connection(Pinput,P,@PYGad[']@PYGad[y]@PYGad['])
    Cinput@PYGbe[.]connect_full(Pinput,Pgp@lb[]@PYGaw[0]@rb[],weight)
    @PYGaD[# Record the spikes]
    Mgp @PYGbe[=] @lb[]SpikeMonitor(p,record@PYGbe[=]@PYGaA[True]) @PYGay[for] p @PYGan[in] Pgp@rb[]
    Minput @PYGbe[=] SpikeMonitor(Pinput,record@PYGbe[=]@PYGaA[True])
    monitors @PYGbe[=] @lb[]Minput@rb[]@PYGbe[+]Mgp
    @PYGaD[# Setup the network, and run it]
    P@PYGbe[.]V @PYGbe[=] Vr @PYGbe[+] rand(@PYGaX[len](P)) @PYGbe[*] (Vt@PYGbe[-]Vr)
    run(@PYGaw[100]@PYGbe[*]ms)
    @PYGaD[# Plot result]
    raster_plot(showgrouplines@PYGbe[=]@PYGaA[True],@PYGbe[*]monitors)
    show()


@PYGaD[# DEFAULT PARAMATERS FOR SYNFIRE CHAIN]
@PYGaD[# Approximates those in Diesman et al. 1999]
model_params @PYGbe[=] Parameters(
    @PYGaD[# Simulation parameters]
    dt @PYGbe[=] @PYGaw[0.1]@PYGbe[*]ms,
    duration @PYGbe[=] @PYGaw[100] @PYGbe[*] ms,
    @PYGaD[# Neuron model parameters]
    taum @PYGbe[=] @PYGaw[10]@PYGbe[*]ms,
    taupsp @PYGbe[=] @PYGaw[0.325]@PYGbe[*]ms,
    Vt @PYGbe[=] @PYGbe[-]@PYGaw[55]@PYGbe[*]mV,
    Vr @PYGbe[=] @PYGbe[-]@PYGaw[70]@PYGbe[*]mV,
    abs_refrac @PYGbe[=] @PYGaw[1]@PYGbe[*]ms,
    we @PYGbe[=] @PYGaw[34.7143],
    wi @PYGbe[=] @PYGbe[-]@PYGaw[34.7143],
    psp_peak @PYGbe[=] @PYGaw[0.14] @PYGbe[*] mV,
    @PYGaD[# Noise parameters]
    noise_neurons @PYGbe[=] @PYGaw[20000],
    noise_exc @PYGbe[=] @PYGaw[0.88],
    noise_inh @PYGbe[=] @PYGaw[0.12],
    noise_exc_rate @PYGbe[=] @PYGaw[2] @PYGbe[*] Hz,
    noise_inh_rate @PYGbe[=] @PYGaw[12.5] @PYGbe[*] Hz,
    computed_model_parameters @PYGbe[=] @PYGad["""]
@PYGad[    noise_mu = noise_neurons * (noise_exc * noise_exc_rate - noise_inh * noise_inh_rate ) * psp_peak * we]
@PYGad[    noise_sigma = (noise_neurons * (noise_exc * noise_exc_rate + noise_inh * noise_inh_rate ))**.5 * psp_peak * we]
@PYGad[    ]@PYGad["""]
    )

@PYGaD[# MODEL FOR SYNFIRE CHAIN]
@PYGaD[# Excitatory PSPs only]
@PYGay[def] @PYGaK[Model](p):
    equations @PYGbe[=] Equations(@PYGad[''']
@PYGad[        dV/dt = (-(V-Vr)+x)*(1./taum)                            : volt]
@PYGad[        dx/dt = (-x+y)*(1./taupsp)                               : volt]
@PYGad[        dy/dt = -y*(1./taupsp)+25.27*mV/ms+(39.24*mV/ms**0.5)*xi : volt]
@PYGad[        ]@PYGad['''])
    @PYGay[return] Model(equations@PYGbe[=]equations,threshold@PYGbe[=]p@PYGbe[.]Vt,reset@PYGbe[=]p@PYGbe[.]Vr,refractory@PYGbe[=]p@PYGbe[.]abs_refrac,\
                  init@PYGbe[=](@PYGaw[0]@PYGbe[*]volt,@PYGaw[0]@PYGbe[*]volt,@PYGaw[0]@PYGbe[*]volt))

default_params @PYGbe[=] Parameters(
    @PYGaD[# Network parameters]
    num_layers @PYGbe[=] @PYGaw[10],
    neurons_per_layer @PYGbe[=] @PYGaw[100],
    neurons_in_input_layer @PYGbe[=] @PYGaw[100],
    @PYGaD[# Initiating burst parameters]
    initial_burst_t @PYGbe[=] @PYGaw[50] @PYGbe[*] ms,
    initial_burst_a @PYGbe[=] @PYGaw[85],
    initial_burst_sigma @PYGbe[=] @PYGaw[1] @PYGbe[*] ms,
    @PYGaD[# these values are recomputed whenever another value changes]
    computed_network_parameters @PYGbe[=] @PYGad["""]
@PYGad[    total_neurons = neurons_per_layer * num_layers]
@PYGad[    ]@PYGad["""],
    @PYGaD[# plus we also use the default model parameters]
    @PYGbe[*]@PYGbe[*]model_params
    )

@PYGaD[# DEFAULT NETWORK STRUCTURE]
@PYGaD[# Single input layer, multiple chained layers]
@PYGay[class] @PYGaN[DefaultNetwork](Network):
    @PYGay[def] @PYGaK[__init__](@PYGaA[self],p):
        @PYGaD[# define groups]
        chaingroup @PYGbe[=] NeuronGroup(N@PYGbe[=]p@PYGbe[.]total_neurons, model@PYGbe[=]Model(p))
        inputgroup @PYGbe[=] PulsePacket(p@PYGbe[.]initial_burst_t,p@PYGbe[.]neurons_in_input_layer,p@PYGbe[.]initial_burst_sigma)
        layer @PYGbe[=] @lb[] chaingroup@PYGbe[.]subgroup(p@PYGbe[.]neurons_per_layer) @PYGay[for] i @PYGan[in] @PYGaX[range](p@PYGbe[.]num_layers) @rb[]
        @PYGaD[# connections]
        chainconnect @PYGbe[=] Connection(chaingroup,chaingroup,@PYGaw[2])
        @PYGay[for] i @PYGan[in] @PYGaX[range](p@PYGbe[.]num_layers@PYGbe[-]@PYGaw[1]):
            chainconnect@PYGbe[.]connect_full(layer@lb[]i@rb[],layer@lb[]i@PYGbe[+]@PYGaw[1]@rb[],p@PYGbe[.]psp_peak@PYGbe[*]p@PYGbe[.]we)
        inputconnect @PYGbe[=] Connection(inputgroup,chaingroup,@PYGaw[2])
        inputconnect@PYGbe[.]connect_full(inputgroup,layer@lb[]@PYGaw[0]@rb[],p@PYGbe[.]psp_peak@PYGbe[*]p@PYGbe[.]we)
        @PYGaD[# monitors]
        chainmon @PYGbe[=] @lb[]SpikeMonitor(g,@PYGaA[True]) @PYGay[for] g @PYGan[in] layer@rb[]
        inputmon @PYGbe[=] SpikeMonitor(inputgroup,@PYGaA[True])
        mon @PYGbe[=] @lb[]inputmon@rb[]@PYGbe[+]chainmon
        @PYGaD[# network]
        Network@PYGbe[.]__init__(@PYGaA[self],chaingroup,inputgroup,chainconnect,inputconnect,mon)
        @PYGaD[# add additional attributes to self]
        @PYGaA[self]@PYGbe[.]mon @PYGbe[=] mon
        @PYGaA[self]@PYGbe[.]inputgroup @PYGbe[=] inputgroup
        @PYGaA[self]@PYGbe[.]chaingroup @PYGbe[=] chaingroup
        @PYGaA[self]@PYGbe[.]layer @PYGbe[=] layer
        @PYGaA[self]@PYGbe[.]params @PYGbe[=] p
    @PYGay[def] @PYGaK[prepare](@PYGaA[self]):
        Network@PYGbe[.]prepare(@PYGaA[self])
        @PYGaA[self]@PYGbe[.]reinit()
    @PYGay[def] @PYGaK[reinit](@PYGaA[self],p@PYGbe[=]@PYGaA[None]):
        Network@PYGbe[.]reinit(@PYGaA[self])
        q @PYGbe[=] @PYGaA[self]@PYGbe[.]params
        @PYGay[if] p @PYGan[is] @PYGaA[None]: p @PYGbe[=] q
        @PYGaA[self]@PYGbe[.]inputgroup@PYGbe[.]generate(p@PYGbe[.]initial_burst_t,p@PYGbe[.]initial_burst_a,p@PYGbe[.]initial_burst_sigma)
        @PYGaA[self]@PYGbe[.]chaingroup@PYGbe[.]V@PYGbe[=]q@PYGbe[.]Vr@PYGbe[+]rand(@PYGaX[len](@PYGaA[self]@PYGbe[.]chaingroup))@PYGbe[*](q@PYGbe[.]Vt@PYGbe[-]q@PYGbe[.]Vr)
    @PYGay[def] @PYGaK[run](@PYGaA[self]):
        Network@PYGbe[.]run(@PYGaA[self],@PYGaA[self]@PYGbe[.]params@PYGbe[.]duration)
    @PYGay[def] @PYGaK[plot](@PYGaA[self]):
        raster_plot(ylabel@PYGbe[=]@PYGad["]@PYGad[Layer]@PYGad["],title@PYGbe[=]@PYGad["]@PYGad[Synfire chain raster plot]@PYGad["],
                   color@PYGbe[=](@PYGaw[1],@PYGaw[0],@PYGaw[0]),markersize@PYGbe[=]@PYGaw[3],
                   showgrouplines@PYGbe[=]@PYGaA[True],spacebetweengroups@PYGbe[=]@PYGaw[0.2],grouplinecol@PYGbe[=](@PYGaw[0.5],@PYGaw[0.5],@PYGaw[0.5]),
                   @PYGbe[*]@PYGaA[self]@PYGbe[.]mon)

@PYGay[def] @PYGaK[estimate_params](mon,time_est):
    @PYGaD[# Quick and dirty algorithm for the moment, for a more decent algorithm]
    @PYGaD[# use leastsq algorithm from scipy.optimize.minpack to fit const+Gaussian]
    @PYGaD[# http://www.scipy.org/doc/api_docs/SciPy.optimize.minpack.html#leastsq]
    i, times @PYGbe[=] @PYGaX[zip](@PYGbe[*]mon@PYGbe[.]spikes)
    times @PYGbe[=] qarray(times)
    times @PYGbe[=] times@lb[]@PYGaX[abs](times@PYGbe[-]time_est)@PYGbe[<]@PYGaw[15]@PYGbe[*]ms@rb[]
    @PYGay[if] @PYGaX[len](times)@PYGbe[==]@PYGaw[0]:
        @PYGay[return] (@PYGaw[0],@PYGaw[0]@PYGbe[*]ms)
    better_time_est @PYGbe[=] times@PYGbe[.]mean()
    times @PYGbe[=] times@lb[]@PYGaX[abs](times@PYGbe[-]time_est)@PYGbe[<]@PYGaw[5]@PYGbe[*]ms@rb[]
    @PYGay[if] @PYGaX[len](times)@PYGbe[==]@PYGaw[0]:
        @PYGay[return] (@PYGaw[0],@PYGaw[0]@PYGbe[*]ms)
    @PYGay[return] (@PYGaX[len](times),times@PYGbe[.]std())

@PYGay[def] @PYGaK[single_sfc]():
    net @PYGbe[=] DefaultNetwork(default_params)
    net@PYGbe[.]run()
    net@PYGbe[.]plot()

@PYGay[def] @PYGaK[state_space](grid, neuron_multiply, verbose@PYGbe[=]@PYGaA[True]):
    amin @PYGbe[=] @PYGaw[0]
    amax @PYGbe[=] @PYGaw[100]
    sigmamin @PYGbe[=] @PYGaw[0.]@PYGbe[*]ms
    sigmamax @PYGbe[=] @PYGaw[3.]@PYGbe[*]ms

    params @PYGbe[=] default_params()
    params@PYGbe[.]num_layers @PYGbe[=] @PYGaw[1]
    params@PYGbe[.]neurons_per_layer @PYGbe[=] params@PYGbe[.]neurons_per_layer @PYGbe[*] neuron_multiply

    net @PYGbe[=] DefaultNetwork(params)

    i@PYGbe[=]@PYGaw[0]
    @PYGaD[# uncomment these 2 lines for TeX labels]
    @PYGaD[#import pylab]
    @PYGaD[#pylab.rc_params.update({'text.usetex': True})]
    @PYGay[if] verbose:
        @PYGay[print] @PYGad["]@PYGad[Completed:]@PYGad["]
    start_time @PYGbe[=] time@PYGbe[.]time()
    figure()
    @PYGay[for] ai @PYGan[in] @PYGaX[range](grid@PYGbe[+]@PYGaw[1]):
        @PYGay[for] sigmai @PYGan[in] @PYGaX[range](grid@PYGbe[+]@PYGaw[1]):
            a @PYGbe[=] @PYGaX[int](amin @PYGbe[+] (ai @PYGbe[*] (amax@PYGbe[-]amin)) @PYGbe[/] grid)
            @PYGay[if] a@PYGbe[>]amax: a@PYGbe[=]amax
            sigma @PYGbe[=] sigmamin @PYGbe[+] sigmai @PYGbe[*] (sigmamax@PYGbe[-]sigmamin) @PYGbe[/] grid
            params@PYGbe[.]initial_burst_a, params@PYGbe[.]initial_burst_sigma @PYGbe[=] a, sigma
            net@PYGbe[.]reinit(params)
            net@PYGbe[.]run()
            (newa,newsigma) @PYGbe[=] estimate_params(net@PYGbe[.]mon@lb[]@PYGbe[-]@PYGaw[1]@rb[],params@PYGbe[.]initial_burst_t)
            newa @PYGbe[=] @PYGaX[float](newa)@PYGbe[/]@PYGaX[float](neuron_multiply)
            col @PYGbe[=] (@PYGaX[float](ai)@PYGbe[/]@PYGaX[float](grid),@PYGaX[float](sigmai)@PYGbe[/]@PYGaX[float](grid),@PYGaw[0.5])
            plot(@lb[]sigma@PYGbe[/]ms,newsigma@PYGbe[/]ms@rb[],@lb[]a,newa@rb[],color@PYGbe[=]col)
            plot(@lb[]sigma@PYGbe[/]ms@rb[],@lb[]a@rb[],marker@PYGbe[=]@PYGad[']@PYGad[.]@PYGad['],color@PYGbe[=]col,markersize@PYGbe[=]@PYGaw[15])
            i@PYGbe[+]@PYGbe[=]@PYGaw[1]
            @PYGay[if] verbose:
                @PYGay[print] @PYGaX[str](@PYGaX[int](@PYGaw[100.]@PYGbe[*]@PYGaX[float](i)@PYGbe[/]@PYGaX[float]((grid@PYGbe[+]@PYGaw[1])@PYGbe[*]@PYGbe[*]@PYGaw[2])))@PYGbe[+]@PYGad["]@PYGad[%]@PYGad["],
        @PYGay[if] verbose:
            @PYGay[print]
    @PYGay[if] verbose:
        @PYGay[print] @PYGad["]@PYGad[Evaluation time:]@PYGad["], time@PYGbe[.]time()@PYGbe[-]start_time,@PYGad["]@PYGad[seconds]@PYGad["]
    xlabel(@PYGad[r']@PYGad[$]@PYGad[\]@PYGad[sigma$ (ms)]@PYGad['])
    ylabel(@PYGad[']@PYGad[a]@PYGad['])
    title(@PYGad[']@PYGad[Synfire chain state space]@PYGad['])
    axis(@lb[]sigmamin@PYGbe[/]ms,sigmamax@PYGbe[/]ms,amin,amax@rb[])


minimal_example()
@PYGaD[#print 'Computing SFC with multiple layers']
@PYGaD[#single_sfc()]
@PYGaD[#print 'Plotting SFC state space']
@PYGaD[#state_space(3,1)]
@PYGaD[#state_space(8,10)]
@PYGaD[#state_space(10,50)]
@PYGaD[#state_space(10,150)]
@PYGaD[#show())]
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-52}{}\subsection{Example: short\_term\_plasticity}

Example with Tsodyks STP model
Neurons with regular inputs and depressing synapses

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

U_SE@PYGbe[=]@PYGbe[.]@PYGaw[67]
tau_e@PYGbe[=]@PYGaw[3]@PYGbe[*]ms
taum@PYGbe[=]@PYGaw[50]@PYGbe[*]ms
tau_rec@PYGbe[=]@PYGaw[800]@PYGbe[*]ms
A_SE@PYGbe[=]@PYGaw[250]@PYGbe[*]pA
Rm@PYGbe[=]@PYGaw[100]@PYGbe[*]Mohm
N@PYGbe[=]@PYGaw[10]

eqs@PYGbe[=]@PYGad[''']
@PYGad[dx/dt=rate : 1]
@PYGad[dR/dt=(1-R)/tau_rec : 1]
@PYGad[rate : Hz]
@PYGad[''']

@PYGay[def] @PYGaK[reset_STP](P,spikes):
    P@PYGbe[.]R_@lb[]spikes@rb[]@PYGbe[-]@PYGbe[=]U_SE@PYGbe[*]P@PYGbe[.]R_@lb[]spikes@rb[]
    P@PYGbe[.]x@lb[]spikes@rb[]@PYGbe[=]@PYGaw[0]

@PYGaX[input]@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[1.],reset@PYGbe[=]reset_STP)
MR@PYGbe[=]StateMonitor(@PYGaX[input],@PYGad[']@PYGad[R]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[0],N@PYGbe[-]@PYGaw[1]@rb[])
@PYGaX[input]@PYGbe[.]R@PYGbe[=]@PYGaw[1]
@PYGaX[input]@PYGbe[.]rate@PYGbe[=]linspace(@PYGaw[5]@PYGbe[*]Hz,@PYGaw[30]@PYGbe[*]Hz,N)

eqs_neuron@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(Rm*i-v)/taum:volt]
@PYGad[di/dt=-i/tau_e:amp]
@PYGad[''']
neuron@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs_neuron)

C@PYGbe[=]Connection(@PYGaX[input],neuron,@PYGad[']@PYGad[i]@PYGad['],modulation@PYGbe[=]@PYGad[']@PYGad[R]@PYGad['])
C@PYGbe[.]connect_one_to_one(@PYGaX[input],neuron,A_SE@PYGbe[*]U_SE)
trace@PYGbe[=]StateMonitor(neuron,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[0],N@PYGbe[-]@PYGaw[1]@rb[])

run(@PYGaw[1000]@PYGbe[*]ms)
subplot(@PYGaw[221])
plot(MR@PYGbe[.]times@PYGbe[/]ms,MR@lb[]@PYGaw[0]@rb[])
title(@PYGad[']@PYGad[R]@PYGad['])
subplot(@PYGaw[223])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
title(@PYGad[']@PYGad[Vm]@PYGad['])
subplot(@PYGaw[222])
plot(MR@PYGbe[.]times@PYGbe[/]ms,MR@lb[]N@PYGbe[-]@PYGaw[1]@rb[])
title(@PYGad[']@PYGad[R]@PYGad['])
subplot(@PYGaw[224])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]N@PYGbe[-]@PYGaw[1]@rb[]@PYGbe[/]mV)
title(@PYGad[']@PYGad[Vm]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{StateMonitor}

\hypertarget{index-53}{}\subsection{Example: short\_term\_plasticity2}

Network (CUBA) with depressing synapses
Excitatory synapses are depressing, inhibitory ones are not

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

U_SE@PYGbe[=]@PYGbe[.]@PYGaw[2]
tau_rec@PYGbe[=]@PYGaw[500]@PYGbe[*]ms

eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad[dR/dt=(1-R)/tau_rec : 1 # synaptic resource (in @lb[]0,1@rb[])]
@PYGad[''']

@PYGay[def] @PYGaK[reset_STP](P,spikes):
    P@PYGbe[.]R_@lb[]spikes@rb[]@PYGbe[-]@PYGbe[=]U_SE@PYGbe[*]P@PYGbe[.]R_@lb[]spikes@rb[]
    P@PYGbe[.]v_@lb[]spikes@rb[]@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV

P@PYGbe[=]NeuronGroup(@PYGaw[4000],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV,reset@PYGbe[=]reset_STP)
P@PYGbe[.]v@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV@PYGbe[+]rand(@PYGaw[4000])@PYGbe[*]@PYGaw[10]@PYGbe[*]mV
P@PYGbe[.]R@PYGbe[=]@PYGaw[1]
Pe@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[3200])
Pi@PYGbe[=]P@PYGbe[.]subgroup(@PYGaw[800])
Ce@PYGbe[=]Connection(Pe,P,@PYGad[']@PYGad[ge]@PYGad['],modulation@PYGbe[=]@PYGad[']@PYGad[R]@PYGad['])
Ci@PYGbe[=]Connection(Pi,P,@PYGad[']@PYGad[gi]@PYGad['])
Ce@PYGbe[.]connect_random(Pe, P, @PYGaw[0.02],weight@PYGbe[=]@PYGaw[1.62]@PYGbe[*]mV)
Ci@PYGbe[.]connect_random(Pi, P, @PYGaw[0.02],weight@PYGbe[=]@PYGbe[-]@PYGaw[9]@PYGbe[*]mV)
M@PYGbe[=]SpikeMonitor(P)
trace@PYGbe[=]StateMonitor(P,@PYGad[']@PYGad[R]@PYGad['],record@PYGbe[=]@PYGaw[0])
rate@PYGbe[=]PopulationRateMonitor(P)
run(@PYGaw[1]@PYGbe[*]second)
@PYGay[print] M@PYGbe[.]nspikes,@PYGad["]@PYGad[spikes]@PYGad["]
subplot(@PYGaw[311])
raster_plot(M)
subplot(@PYGaw[312])
plot(trace@PYGbe[.]times@PYGbe[/]ms,trace@lb[]@PYGaw[0]@rb[])
subplot(@PYGaw[313])
plot(rate@PYGbe[.]times@PYGbe[/]ms,rate@PYGbe[.]smooth_rate(@PYGaw[5]@PYGbe[*]ms))
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{PoissonThreshold}\indexii{example usage}{run}\indexii{example usage}{Connection}\indexii{example usage}{PopulationRateMonitor}

\hypertarget{index-25}{}\subsection{Example: STDP1}

Spike-timing dependent plasticity
Adapted from Song, Miller and Abbott (2000)
Takes a long time!

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[from] @PYGaV[time] @PYGay[import] time
@PYGaD[#set_global_preferences(useweave=True)]
taum@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
tau_post@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
tau_pre@PYGbe[=]@PYGaw[20]@PYGbe[*]ms
Ee@PYGbe[=]@PYGaw[0]@PYGbe[*]mV
vt@PYGbe[=]@PYGbe[-]@PYGaw[54]@PYGbe[*]mV
vr@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV
El@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV
taue@PYGbe[=]@PYGaw[5]@PYGbe[*]ms
gmax@PYGbe[=]@PYGaw[0.015]
dA_pre@PYGbe[=]gmax@PYGbe[*]@PYGbe[.]@PYGaw[005]
dA_post@PYGbe[=]@PYGbe[-]dA_pre@PYGbe[*]@PYGaw[1.05]

eqs_poisson@PYGbe[=]@PYGad[''']
@PYGad[rate : Hz]
@PYGad[dA_pre/dt=-A_pre/tau_pre : 1]
@PYGad[''']

eqs_neurons@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(ge*(Ee-v)+El-v)/taum : volt]
@PYGad[dge/dt=-ge/taue : 1]
@PYGad[dA_post/dt=-A_post/tau_post : 1]
@PYGad[''']

@PYGay[def] @PYGaK[poisson_reset](P,spikes):
    @PYGay[for] i @PYGan[in] spikes:
        synapses@lb[]i,:@rb[]@PYGbe[=]clip(synapses@lb[]i,:@rb[]@PYGbe[+]neurons@PYGbe[.]A_post_,@PYGaw[0],gmax)
    P@PYGbe[.]A_pre_@lb[]spikes@rb[]@PYGbe[+]@PYGbe[=]dA_pre

@PYGay[def] @PYGaK[neurons_reset](P,spikes):
    P@PYGbe[.]v_@lb[]spikes@rb[]@PYGbe[=]vr
    @PYGay[for] i @PYGan[in] spikes:
        synapses@lb[]:,i@rb[]@PYGbe[=]clip(synapses@lb[]:,i@rb[]@PYGbe[+]@PYGaX[input]@PYGbe[.]A_pre_,@PYGaw[0],gmax)
    P@PYGbe[.]A_post_@lb[]spikes@rb[]@PYGbe[+]@PYGbe[=]dA_post

@PYGaX[input]@PYGbe[=]NeuronGroup(@PYGaw[1000],model@PYGbe[=]eqs_poisson,threshold@PYGbe[=]PoissonThreshold(),reset@PYGbe[=]poisson_reset)
neurons@PYGbe[=]NeuronGroup(@PYGaw[1],model@PYGbe[=]eqs_neurons,threshold@PYGbe[=]vt,reset@PYGbe[=]neurons_reset)
synapses@PYGbe[=]Connection(@PYGaX[input],neurons,@PYGad[']@PYGad[ge]@PYGad['],structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
synapses@PYGbe[.]connect(@PYGaX[input],neurons,rand(@PYGaX[len](@PYGaX[input]),@PYGaX[len](neurons))@PYGbe[*]gmax)
neurons@PYGbe[.]v@PYGbe[=]vr
@PYGaX[input]@PYGbe[.]rate@PYGbe[=]@PYGaw[10]@PYGbe[*]Hz

rate@PYGbe[=]PopulationRateMonitor(neurons)

start_time@PYGbe[=]time()
run(@PYGaw[100]@PYGbe[*]second)
@PYGaD[#run(2*second)]
@PYGay[print] @PYGad["]@PYGad[Simulation time:]@PYGad["],time()@PYGbe[-]start_time

subplot(@PYGaw[211])
plot(rate@PYGbe[.]times@PYGbe[/]ms,rate@PYGbe[.]smooth_rate(@PYGaw[500]@PYGbe[*]ms))
subplot(@PYGaw[212])
plot(synapses@PYGbe[.]W@PYGbe[.]squeeze(),@PYGad[']@PYGad[.]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{raster\_plot}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{PoissonGroup}\indexii{example usage}{run}

\hypertarget{index-54}{}\subsection{Example: stim2d}

Example of a 2D stimulus, see the
\href{http://neuralensemble.org/cookbook/wiki/Brian/StimulusArrayGroup}{complete description}
at the Brian Cookbook.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGay[import] @PYGaV[scipy.ndimage] @PYGay[as] @PYGaV[im]

__all__ @PYGbe[=] @lb[]@PYGad[']@PYGad[bar]@PYGad['],@PYGad[']@PYGad[StimulusArrayGroup]@PYGad[']@rb[]

@PYGay[def] @PYGaK[bar](width, height, thickness, angle):
    @PYGas[''']
@PYGas[    An array of given dimensions with a bar of given thickness and angle]
@PYGas[    ''']
    stimulus @PYGbe[=] zeros((width, height))
    stimulus@lb[]:,@PYGaX[int](height@PYGbe[/]@PYGaw[2.]@PYGbe[-]thickness@PYGbe[/]@PYGaw[2.]):@PYGaX[int](height@PYGbe[/]@PYGaw[2.]@PYGbe[+]thickness@PYGbe[/]@PYGaw[2.])@rb[] @PYGbe[=] @PYGaw[1.]
    stimulus @PYGbe[=] im@PYGbe[.]rotate(stimulus, angle, reshape@PYGbe[=]@PYGaA[False])
    @PYGay[return] stimulus

@PYGay[class] @PYGaN[StimulusArrayGroup](PoissonGroup):
    @PYGas[''']
@PYGas[    A group of neurons which fire with a given stimulus at a given rate]

@PYGas[    The argument ``stimulus`` should be a 2D array with values between 0 and 1.]
@PYGas[    The point in the stimulus array at position (y,x) will correspond to the]
@PYGas[    neuron with index i=y*width+x. This neuron will fire Poisson spikes at]
@PYGas[    ``rate*stimulus@lb[]y,x@rb[]`` Hz. The stimulus will start at time ``onset``]
@PYGas[    for ``duration``.]
@PYGas[    ''']
    @PYGay[def] @PYGaK[__init__](@PYGaA[self], stimulus, rate, onset, duration):
        height, width @PYGbe[=] stimulus@PYGbe[.]shape
        stim @PYGbe[=] stimulus@PYGbe[.]ravel()@PYGbe[*]rate
        @PYGaA[self]@PYGbe[.]stimulus @PYGbe[=] stim
        @PYGay[def] @PYGaK[stimfunc](t):
            @PYGay[if] onset@PYGbe[<]t@PYGbe[<](onset@PYGbe[+]duration):
                @PYGay[return] stim
            @PYGay[else]:
                @PYGay[return] @PYGaw[0.]@PYGbe[*]Hz
        PoissonGroup@PYGbe[.]__init__(@PYGaA[self], width@PYGbe[*]height, stimfunc)

@PYGay[if] __name__@PYGbe[==]@PYGad[']@PYGad[__main__]@PYGad[']:
    @PYGay[import] @PYGaV[pylab]
    subplot(@PYGaw[121])
    stim @PYGbe[=] bar(@PYGaw[100],@PYGaw[100],@PYGaw[10],@PYGaw[90])@PYGbe[*]@PYGaw[0.9]@PYGbe[+]@PYGaw[0.1]
    pylab@PYGbe[.]imshow(stim, origin@PYGbe[=]@PYGad[']@PYGad[lower]@PYGad['])
    pylab@PYGbe[.]gray()
    G @PYGbe[=] StimulusArrayGroup(stim, @PYGaw[50]@PYGbe[*]Hz, @PYGaw[100]@PYGbe[*]ms, @PYGaw[100]@PYGbe[*]ms)
    M @PYGbe[=] SpikeMonitor(G)
    run(@PYGaw[300]@PYGbe[*]ms)
    subplot(@PYGaw[122])
    raster_plot(M)
    axis(xmin@PYGbe[=]@PYGaw[0],xmax@PYGbe[=]@PYGaw[300])
    show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{Clock}\indexii{example usage}{network\_operation}\indexii{example usage}{Connection}\indexii{example usage}{PoissonGroup}\indexii{example usage}{Model}

\hypertarget{index-55}{}\subsection{Example: stopping}

Network to demonstrate stopping a simulation during a run

Have a fully connected network of integrate and fire neurons
with input fed by a group of Poisson neurons with a steadily
increasing rate, want to determine the point in time at which
the network of integrate and fire neurons switches from no
firing to all neurons firing, so we have a network\_operation
called stop\_condition that calls the stop() function if the
monitored network firing rate is above a minimum threshold.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

clk @PYGbe[=] Clock()

Vr @PYGbe[=] @PYGaw[0]@PYGbe[*]mV
El @PYGbe[=] @PYGaw[0]@PYGbe[*]mV
Vt @PYGbe[=] @PYGaw[10]@PYGbe[*]mV
tau @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
weight @PYGbe[=] @PYGaw[0.2]@PYGbe[*]mV
duration @PYGbe[=] @PYGaw[100]@PYGbe[*]msecond
max_input_rate @PYGbe[=] @PYGaw[10000]@PYGbe[*]Hz
num_input_neurons @PYGbe[=] @PYGaw[1000]
input_connection_p @PYGbe[=] @PYGaw[0.1]
rate_per_neuron @PYGbe[=] max_input_rate@PYGbe[/](num_input_neurons@PYGbe[*]input_connection_p)

model @PYGbe[=] Model(equations@PYGbe[=]@PYGad[''']
@PYGad[    dV/dt=-(V-El)/tau : volt]
@PYGad[    ]@PYGad['''],
    threshold@PYGbe[=]Vt,
    reset@PYGbe[=]Vr)

P @PYGbe[=] PoissonGroup(num_input_neurons, @PYGay[lambda] t: rate_per_neuron@PYGbe[*](t@PYGbe[/]duration))

G @PYGbe[=] NeuronGroup(@PYGaw[1000], model@PYGbe[=]model)
G@PYGbe[.]V @PYGbe[=] Vr@PYGbe[+](Vt@PYGbe[-]Vr)@PYGbe[*]rand(@PYGaX[len](G))

CPG @PYGbe[=] Connection(P, G)
CPG@PYGbe[.]connect_random(P, G, p@PYGbe[=]input_connection_p, weight@PYGbe[=]weight)

CGG @PYGbe[=] Connection(G, G)
CGG@PYGbe[.]connect_full(G, G, weight@PYGbe[=]weight)

MP @PYGbe[=] PopulationRateMonitor(G, bin@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)

@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[stop_condition]():
    @PYGay[if] MP@PYGbe[.]rate@lb[]@PYGbe[-]@PYGaw[1]@rb[]@PYGbe[*]Hz@PYGbe[>]@PYGaw[10]@PYGbe[*]Hz:
        stop()

run(duration)

@PYGay[print] @PYGad["]@PYGad[Reached population rate>10 Hz by time]@PYGad["], clk@PYGbe[.]t, @PYGad["]@PYGad[+/- 1 ms.]@PYGad["]
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}\indexii{example usage}{PulsePacket}\indexii{example usage}{Equations}

\hypertarget{index-56}{}\subsection{Example: synfire\_chains}

Synfire chains (from Diesmann et al, 1999)

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaD[# Neuron model parameters]
Vr @PYGbe[=] @PYGbe[-]@PYGaw[70]@PYGbe[*]mV
Vt @PYGbe[=] @PYGbe[-]@PYGaw[55]@PYGbe[*]mV
taum @PYGbe[=] @PYGaw[10]@PYGbe[*]ms
taupsp @PYGbe[=] @PYGaw[0.325]@PYGbe[*]ms
weight @PYGbe[=] @PYGaw[4.86] @PYGbe[*] mV
@PYGaD[# Neuron model]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dV/dt=(-(V-Vr)+x)*(1./taum) : volt]
@PYGad[dx/dt=(-x+y)*(1./taupsp) : volt]
@PYGad[dy/dt=-y*(1./taupsp)+25.27*mV/ms+]@PYGao[\]
@PYGad[    (39.24*mV/ms**0.5)*xi : volt]
@PYGad['''])
@PYGaD[# Neuron groups]
P @PYGbe[=] NeuronGroup(N@PYGbe[=]@PYGaw[1000], model@PYGbe[=]eqs,
    threshold@PYGbe[=]Vt,reset@PYGbe[=]Vr,refractory@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
Pinput @PYGbe[=] PulsePacket(t@PYGbe[=]@PYGaw[50]@PYGbe[*]ms,n@PYGbe[=]@PYGaw[85],sigma@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
@PYGaD[# The network structure]
Pgp @PYGbe[=] @lb[] P@PYGbe[.]subgroup(@PYGaw[100]) @PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[10])@rb[]
C @PYGbe[=] Connection(P,P,@PYGad[']@PYGad[y]@PYGad['])
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaw[9]):
    C@PYGbe[.]connect_full(Pgp@lb[]i@rb[],Pgp@lb[]i@PYGbe[+]@PYGaw[1]@rb[],weight)
Cinput @PYGbe[=] Connection(Pinput,P,@PYGad[']@PYGad[y]@PYGad['])
Cinput@PYGbe[.]connect_full(Pinput,Pgp@lb[]@PYGaw[0]@rb[],weight)
@PYGaD[# Record the spikes]
Mgp @PYGbe[=] @lb[]SpikeMonitor(p,record@PYGbe[=]@PYGaA[True]) @PYGay[for] p @PYGan[in] Pgp@rb[]
Minput @PYGbe[=] SpikeMonitor(Pinput,record@PYGbe[=]@PYGaA[True])
monitors @PYGbe[=] @lb[]Minput@rb[]@PYGbe[+]Mgp
@PYGaD[# Setup the network, and run it]
P@PYGbe[.]V @PYGbe[=] Vr @PYGbe[+] rand(@PYGaX[len](P)) @PYGbe[*] (Vt@PYGbe[-]Vr)
run(@PYGaw[100]@PYGbe[*]ms)
@PYGaD[# Plot result]
raster_plot(showgrouplines@PYGbe[=]@PYGaA[True],@PYGbe[*]monitors)
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{PoissonGroup}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-57}{}\subsection{Example: topographic\_map}

Topographic map - an example of complicated connections.
Two layers of neurons.
The first layer is connected randomly to the second one in a
topographical way.
The second layer has random lateral connections.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[100]
tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
tau_e@PYGbe[=]@PYGaw[2]@PYGbe[*]ms @PYGaD[# AMPA synapse]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(I-v)/tau : volt]
@PYGad[dI/dt=-I/tau_e : volt]
@PYGad[''']

rates@PYGbe[=]zeros(N)@PYGbe[*]Hz
rates@lb[]N@PYGbe[/]@PYGaw[2]@PYGbe[-]@PYGaw[10]:N@PYGbe[/]@PYGaw[2]@PYGbe[+]@PYGaw[10]@rb[]@PYGbe[=]ones(@PYGaw[20])@PYGbe[*]@PYGaw[30]@PYGbe[*]Hz
layer1@PYGbe[=]PoissonGroup(N,rates@PYGbe[=]rates)
layer2@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV)

topomap@PYGbe[=]@PYGay[lambda] i,j:exp(@PYGbe[-]@PYGaX[abs](i@PYGbe[-]j)@PYGbe[*]@PYGbe[.]@PYGaw[1])@PYGbe[*]@PYGaw[3]@PYGbe[*]mV
feedforward@PYGbe[=]Connection(layer1,layer2)
feedforward@PYGbe[.]connect_random(layer1,layer2,@PYGbe[.]@PYGaw[5],weight@PYGbe[=]topomap)
@PYGaD[#feedforward@lb[]2,3@rb[]=1*mV]

lateralmap@PYGbe[=]@PYGay[lambda] i,j:exp(@PYGbe[-]@PYGaX[abs](i@PYGbe[-]j)@PYGbe[*]@PYGbe[.]@PYGaw[05])@PYGbe[*]@PYGaw[0.5]@PYGbe[*]mV
recurrent@PYGbe[=]Connection(layer2,layer2)
recurrent@PYGbe[.]connect_random(layer2,layer2,@PYGbe[.]@PYGaw[5],weight@PYGbe[=]lateralmap)

spikes@PYGbe[=]SpikeMonitor(layer2)

run(@PYGaw[1]@PYGbe[*]second)
subplot(@PYGaw[211])
raster_plot(spikes)
subplot(@PYGaw[223])
imshow(array(feedforward@PYGbe[.]W@PYGbe[.]todense()), interpolation@PYGbe[=]@PYGad[']@PYGad[nearest]@PYGad['], origin@PYGbe[=]@PYGad[']@PYGad[lower]@PYGad['])
title(@PYGad[']@PYGad[Feedforward connection strengths]@PYGad['])
subplot(@PYGaw[224])
imshow(array(recurrent@PYGbe[.]W@PYGbe[.]todense()), interpolation@PYGbe[=]@PYGad[']@PYGad[nearest]@PYGad['], origin@PYGbe[=]@PYGad[']@PYGad[lower]@PYGad['])
title(@PYGad[']@PYGad[Recurrent connection strengths]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{PoissonGroup}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-58}{}\subsection{Example: topographic\_map2}

Topographic map - an example of complicated connections.
Two layers of neurons.
The first layer is connected randomly to the second one in a
topographical way.
The second layer has random lateral connections.
Each neuron has a position x{[}i{]}.

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

N@PYGbe[=]@PYGaw[100]
tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
tau_e@PYGbe[=]@PYGaw[2]@PYGbe[*]ms @PYGaD[# AMPA synapse]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(I-v)/tau : volt]
@PYGad[dI/dt=-I/tau_e : volt]
@PYGad[''']

rates@PYGbe[=]zeros(N)@PYGbe[*]Hz
rates@lb[]N@PYGbe[/]@PYGaw[2]@PYGbe[-]@PYGaw[10]:N@PYGbe[/]@PYGaw[2]@PYGbe[+]@PYGaw[10]@rb[]@PYGbe[=]ones(@PYGaw[20])@PYGbe[*]@PYGaw[30]@PYGbe[*]Hz
layer1@PYGbe[=]PoissonGroup(N,rates@PYGbe[=]rates)
layer1@PYGbe[.]x@PYGbe[=]linspace(@PYGaw[0.],@PYGaw[1.],@PYGaX[len](layer1)) @PYGaD[# abstract position between 0 and 1]
layer2@PYGbe[=]NeuronGroup(N,model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV)
layer2@PYGbe[.]x@PYGbe[=]linspace(@PYGaw[0.],@PYGaw[1.],@PYGaX[len](layer2))

@PYGaD[# Generic connectivity function]
topomap@PYGbe[=]@PYGay[lambda] i,j,x,y,sigma: exp(@PYGbe[-]@PYGaX[abs](x@lb[]i@rb[]@PYGbe[-]y@lb[]j@rb[])@PYGbe[/]sigma)

feedforward@PYGbe[=]Connection(layer1,layer2)
feedforward@PYGbe[.]connect_random(layer1,layer2,@PYGbe[.]@PYGaw[5],
                           weight@PYGbe[=]@PYGay[lambda] i,j:topomap(i,j,layer1@PYGbe[.]x,layer2@PYGbe[.]x,@PYGbe[.]@PYGaw[3])@PYGbe[*]@PYGaw[3]@PYGbe[*]mV)

recurrent@PYGbe[=]Connection(layer2,layer2)
recurrent@PYGbe[.]connect_random(layer2,layer2,@PYGbe[.]@PYGaw[5],
                         weight@PYGbe[=]@PYGay[lambda] i,j:topomap(i,j,layer1@PYGbe[.]x,layer2@PYGbe[.]x,@PYGbe[.]@PYGaw[2])@PYGbe[*]@PYGbe[.]@PYGaw[5]@PYGbe[*]mV)

spikes@PYGbe[=]SpikeMonitor(layer2)

run(@PYGaw[1]@PYGbe[*]second)
subplot(@PYGaw[211])
raster_plot(spikes)
subplot(@PYGaw[223])
imshow(feedforward@PYGbe[.]W@PYGbe[.]todense(), interpolation@PYGbe[=]@PYGad[']@PYGad[nearest]@PYGad['], origin@PYGbe[=]@PYGad[']@PYGad[lower]@PYGad['])
title(@PYGad[']@PYGad[Feedforward connection strengths]@PYGad['])
subplot(@PYGaw[224])
imshow(recurrent@PYGbe[.]W@PYGbe[.]todense(), interpolation@PYGbe[=]@PYGad[']@PYGad[nearest]@PYGad['], origin@PYGbe[=]@PYGad[']@PYGad[lower]@PYGad['])
title(@PYGad[']@PYGad[Recurrent connection strengths]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{run}\indexii{example usage}{PopulationRateMonitor}\indexii{example usage}{raster\_plot}\indexii{example usage}{Connection}\indexii{example usage}{SpikeMonitor}

\hypertarget{index-59}{}\subsection{Example: transient\_sync}

Transient synchronisation in a population of noisy IF neurons
with distance-dependent synaptic weights (organised as a ring)

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]

tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
N@PYGbe[=]@PYGaw[100]
v0@PYGbe[=]@PYGaw[5]@PYGbe[*]mV
sigma@PYGbe[=]@PYGaw[4]@PYGbe[*]mV
group@PYGbe[=]NeuronGroup(N,model@PYGbe[=]@PYGad[']@PYGad[dv/dt=(v0-v)/tau + sigma*xi/tau**.5 : volt]@PYGad['],\
                  threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV)
C@PYGbe[=]Connection(group,group,@PYGad[']@PYGad[v]@PYGad['],structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad[']) @PYGaD[# use a dense matrix]
@PYGaD[#f=lambda i,j:.5*mV*exp(-abs(i-j)*.1)]
@PYGaD[#C.connect_full(group,group,weight=lambda i,j:f(i,j)+f(i+N,j)+f(i,j+N))]
C@PYGbe[.]connect_full(group,group,weight@PYGbe[=]@PYGay[lambda] i,j:@PYGbe[.]@PYGaw[4]@PYGbe[*]mV@PYGbe[*]cos(@PYGaw[2.]@PYGbe[*]pi@PYGbe[*](i@PYGbe[-]j)@PYGbe[*]@PYGaw[1.]@PYGbe[/]N))
S@PYGbe[=]SpikeMonitor(group)
R@PYGbe[=]PopulationRateMonitor(group)
group@PYGbe[.]v@PYGbe[=]rand(N)@PYGbe[*]@PYGaw[10]@PYGbe[*]mV

run(@PYGaw[5000]@PYGbe[*]ms)
subplot(@PYGaw[211])
raster_plot(S)
subplot(@PYGaw[223])
imshow(C@PYGbe[.]W, interpolation@PYGbe[=]@PYGad[']@PYGad[nearest]@PYGad['])
title(@PYGad[']@PYGad[Synaptic connections]@PYGad['])
subplot(@PYGaw[224])
plot(R@PYGbe[.]times@PYGbe[/]ms,R@PYGbe[.]smooth_rate(@PYGaw[2]@PYGbe[*]ms,@PYGaX[filter]@PYGbe[=]@PYGad[']@PYGad[flat]@PYGad[']))
title(@PYGad[']@PYGad[Firing rate]@PYGad['])
show()
\end{Verbatim}

\resetcurrentobjects
\indexii{example usage}{NeuronGroup}\indexii{example usage}{Connection}\indexii{example usage}{PopulationSpikeCounter}\indexii{example usage}{run}\indexii{example usage}{StateMonitor}

\hypertarget{index-60}{}\subsection{Example: two\_neurons}

Two connected neurons with delays

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms
w@PYGbe[=]@PYGbe[-]@PYGaw[1]@PYGbe[*]mV
v0@PYGbe[=]@PYGaw[11]@PYGbe[*]mV
neurons@PYGbe[=]NeuronGroup(@PYGaw[2],model@PYGbe[=]@PYGad[']@PYGad[dv/dt=(v0-v)/tau : volt]@PYGad['],threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,\
                    max_delay@PYGbe[=]@PYGaw[5]@PYGbe[*]ms)
neurons@PYGbe[.]v@PYGbe[=]rand(@PYGaw[2])@PYGbe[*]@PYGaw[10]@PYGbe[*]mV
W@PYGbe[=]Connection(neurons,neurons,@PYGad[']@PYGad[v]@PYGad['],delay@PYGbe[=]@PYGaw[2]@PYGbe[*]ms)
W@lb[]@PYGaw[0],@PYGaw[1]@rb[]@PYGbe[=]w
W@lb[]@PYGaw[1],@PYGaw[0]@rb[]@PYGbe[=]w
S@PYGbe[=]StateMonitor(neurons,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True])
@PYGaD[#mymonitor=SpikeMonitor(neurons@lb[]0@rb[])]
mymonitor@PYGbe[=]PopulationSpikeCounter(neurons)

run(@PYGaw[500]@PYGbe[*]ms)
plot(S@PYGbe[.]times@PYGbe[/]ms,S@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV)
plot(S@PYGbe[.]times@PYGbe[/]ms,S@lb[]@PYGaw[1]@rb[]@PYGbe[/]mV)
save(@PYGad[']@PYGad[trace.txt]@PYGad['],(S@PYGbe[.]times@PYGbe[/]ms,S@lb[]@PYGaw[0]@rb[]@PYGbe[/]mV))
@PYGay[print] mymonitor@PYGbe[.]nspikes
show()
\end{Verbatim}

\resetcurrentobjects


\hypertarget{user-manual}{}\chapter{User manual}
\indexii{scipy}{analysis}\indexii{numpy}{numerical computation}\indexii{numpy}{analysis}\indexii{pylab}{plotting}
The SciPy, NumPy and PyLab packages are documented on the following web sites:
\begin{itemize}
\item {} 
\href{http://www.scipy.org/Getting\_Started}{http://www.scipy.org/Getting\_Started}

\item {} 
\href{http://www.scipy.org/Documentation}{http://www.scipy.org/Documentation}

\item {} 
\href{http://matplotlib.sourceforge.net/matplotlib.pylab.html}{http://matplotlib.sourceforge.net/matplotlib.pylab.html}

\end{itemize}

Brian itself is documented in the following sections:

\resetcurrentobjects


\section{Units}


\subsection{Basics}

Brian has a system for physical quantities with units built in, and most of the
library functions require that variables have the right units. This restriction
is useful in catching hard to find errors based on using incorrect units, and
ensures that simulated models are physically meaningful. For example, running
the following code causes an error:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaO[>>> ]@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaO[>>> ]c @PYGbe[=] Clock(t@PYGbe[=]@PYGaw[0])

@PYGaB[Traceback (most recent call last):]
  File @PYGaX["<pyshell#1>"], line @PYGaQ[1], in <module>
    c @PYGbe[=] Clock(t@PYGbe[=]@PYGaw[0])
  File @PYGaX["C:\Documents and Settings\goodman\Mes documents\Programming\Python simulator\Brian\units.py"], line @PYGaQ[1126], in new_f
    @PYGay[raise] DimensionMismatchError(@PYGad["]@PYGad[Function ]@PYGad["] @PYGbe[+] f@PYGbe[.]__name__ @PYGbe[+] @PYGad["]@PYGad[ variable ]@PYGad["] @PYGbe[+] k @PYGbe[+] @PYGad["]@PYGad[ should have dimensions of ]@PYGad["] @PYGbe[+] @PYGaX[str](au@lb[]k@rb[]), getDimensions(newkeyset@lb[]k@rb[]))
@PYGaN[DimensionMismatchError]: Function __init__ variable t should have dimensions of s, dimensions were (1)
\end{Verbatim}

You can see that Brian raises a \code{DimensionMismatchError} exception, because the
\hyperlink{brian.Clock}{\code{Clock}} object expects \code{t} to have units of time. The correct thing to write is:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaO[>>> ]@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaO[>>> ]c @PYGbe[=] Clock(t@PYGbe[=]@PYGaw[0]@PYGbe[*]second)
\end{Verbatim}

Similarly, attempting to do numerical operations with inconsistent units will
raise an error:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaO[>>> ]@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaO[>>> ]@PYGaw[3]@PYGbe[*]second@PYGbe[+]@PYGaw[2]@PYGbe[*]metre

@PYGaB[Traceback (most recent call last):]
  File @PYGaX["<pyshell#38>"], line @PYGaQ[1], in <module>
    @PYGaw[3]@PYGbe[*]second@PYGbe[+]@PYGaw[2]@PYGbe[*]metre
  File @PYGaX["C:\Documents and Settings\goodman\Mes documents\Programming\Python simulator\Brian\units.py"], line @PYGaQ[600], in __add__
    @PYGay[if] dim@PYGbe[==]@PYGaA[self]@PYGbe[.]dim:
@PYGaN[DimensionMismatchError]: Addition, dimensions were (s) (m)
\end{Verbatim}


\subsection{Units defined in Brian}

The following fundamental SI unit names are defined:
\begin{quote}

\code{metre}, \code{meter} (US spelling), \code{kilogram}, \code{second}, \code{amp}, \code{kelvin}, \code{mole}, \code{candle}
\end{quote}

These derived SI unit names are also defined:
\begin{quote}

\code{radian}, \code{steradian}, \code{hertz}, \code{newton}, \code{pascal}, \code{joule}, \code{watt},
\code{coulomb}, \code{volt}, \code{farad}, \code{ohm}, \code{siemens}, \code{weber}, \code{tesla},
\code{henry}, \code{celsius}, \code{lumen}, \code{lux}, \code{becquerel}, \code{gray}, \code{sievert}, \code{katal}
\end{quote}

In addition, you can form scaled versions of these units with any of the standard SI prefixes:

\begin{tabulary}{\textwidth}{|L|L|L|L|L|L|}
\hline
\textbf{
Factor
} & \textbf{
Name
} & \textbf{
Symbol
} & \textbf{
Factor
} & \textbf{
Name
} & \textbf{
Symbol
}\\
\hline

10\textasciicircum{}24
 & 
yotta
 & 
Y
 & 
10\textasciicircum{}-24
 & 
yocto
 & 
y
\\

10\textasciicircum{}21
 & 
zetta
 & 
Z
 & 
10\textasciicircum{}-21
 & 
zepto
 & 
z
\\

10\textasciicircum{}18
 & 
exa
 & 
E
 & 
10\textasciicircum{}-21
 & 
zepto
 & 
z
\\

10\textasciicircum{}15
 & 
peta
 & 
P
 & 
10\textasciicircum{}-15
 & 
femto
 & 
f
\\

10\textasciicircum{}12
 & 
tera
 & 
T
 & 
10\textasciicircum{}-12
 & 
pico
 & 
p
\\

10\textasciicircum{}9
 & 
giga
 & 
G
 & 
10\textasciicircum{}-9
 & 
nano
 & 
n
\\

10\textasciicircum{}6
 & 
mega
 & 
M
 & 
10\textasciicircum{}-6
 & 
micro
 & 
u (mu in SI)
\\

10\textasciicircum{}3
 & 
kilo
 & 
k
 & 
10\textasciicircum{}-3
 & 
milli
 & 
m
\\

10\textasciicircum{}2
 & 
hecto
 & 
h
 & 
10\textasciicircum{}-2
 & 
centi
 & 
c
\\

10\textasciicircum{}1
 & 
deka
 & 
da
 & 
10\textasciicircum{}-1
 & 
deci
 & 
d
\\
\hline
\end{tabulary}


So for example, you could write \code{fnewton} for femto-newtons, \code{Mwatt} for megawatt, etc.

There are also units for 2nd and 3rd powers of each of the above units, for example
\code{metre3 = metre**3}, \code{watt2 = watt*watt}, etc.

You can optionally use short names for some units derived from volts, amps,
farads, siemens, seconds, hertz and metres:
\code{mV, mA, uA, nA, pA, mF, uF, nF, mS, uS, ms, Hz, kHz, MHz, cm, cm2, cm3,}
\code{mm, mm2, mm3, um, um2, um3}.
Since these names are so short, there is a danger that they might clash with your
own variables names, so watch out for that.


\subsection{Arrays and units}

Versions of Brian before 1.0 had a system for allowing arrays to have units, this has
been removed for the 1.0 release because of stability problems - as new releases of
NumPy, SciPy and PyLab came out it required changes to the units code. Now all arrays
used by Brian are standard NumPy arrays and have no units.


\subsection{Checking units}

Units are automatically checked when arithmetic operations are performed, and when
a neuron group is initialised (the consistency of the differential equations is checked).
They can also be checked explictly when a user-defined function is called by using the
decorator \code{@check\_units}, which can be used as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]check_units](I@PYGbe[=]amp,R@PYGbe[=]ohm,wibble@PYGbe[=]metre,result@PYGbe[=]volt)
@PYGay[def] @PYGaK[getvoltage](I,R,@PYGbe[*]@PYGbe[*]k):
    @PYGay[return] I@PYGbe[*]R
\end{Verbatim}

Remarks:
\begin{itemize}
\item {} 
not all arguments need to be checked

\item {} 
keyword arguments may be checked

\item {} 
the result can optionnally be checked

\item {} 
no error is raised if the values are strings.

\end{itemize}


\subsection{Disabling units}

Unit checking can slow down the simulations. The units system can be disabled by inserting
\code{import brian\_no\_units} as the \emph{first line} of the script, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[brian_no_units]
@PYGay[from] @PYGaV[brian] @PYGay[import] @PYGbe[*]
@PYGaD[# etc]
\end{Verbatim}

Internally, physical quantities are floats with an additional units information. The float
value is the value in the SI system. For example, \code{float(mV)} returns \code{0.001}.
After importing \code{brian\_no\_units}, all units are converted to their float values. For example,
\code{mV} is simply the number \code{0.001}.
This may also be a solution when using external libraries which are not compatible with units
(but see next section).

A good practice is to develop the script with units on, then switch them off once the script
runs correctly.


\subsection{Converting quantities}

In many situations, physical quantities need to be expressed with given units. For example,
one might want to plot a graph of the membrane potential in mV as a function of time in ms.
The following code:

\begin{Verbatim}[commandchars=@\[\]]
plot(t,V)
\end{Verbatim}

displays the trace with time in seconds and potential in volts. The simplest solution to have
time in ms and potential in mV is to use units operations:

\begin{Verbatim}[commandchars=@\[\]]
plot(t@PYGbe[/]ms,V@PYGbe[/]mV)
\end{Verbatim}

Here, t/ms is a unitless array containing the values of t in ms.
The same trick may be applied to use external functions which do not work with units
(convert the arguments to unitless quantities as above).

\resetcurrentobjects


\section{Models and neuron groups}


\subsection{\texttt{Equations}}

\hyperlink{brian.Equations}{\code{Equations}} objects are initialised with a string as follows:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dx/dt=(y-x)/tau + a : volt   # differential equation]
@PYGad[y=2*x : volt                 # equation]
@PYGad[z=x                          # alias]
@PYGad[a : volt/second              # parameter]
@PYGad['''])
\end{Verbatim}
\indexii{equations}{differential}\indexii{equations}{equation}\index{equation}\indexii{equations}{alias}\indexii{equations}{parameter}
It is possible to pass a string instead of an \hyperlink{brian.Equations}{\code{Equations}} object when initialising
a neuron group. In that case, the string is implicitly converted to an \hyperlink{brian.Equations}{\code{Equations}} object.
There are 4 different types of equations:
\begin{itemize}
\item {} 
Differential equations: a differential equation, also defining the variable as a state
variable in neuron groups.

\item {} 
Equations: a non-differential equation, which is useful for defining complicated models.
The variables are also accessible for reading in neuron groups, which is useful for
monitoring. The graph of dependencies of all equations must have no cycle.

\item {} 
Aliases: the two variables are equivalent. This is implemented as an equation,
with write access in neuron groups.

\item {} 
Parameters: these are constant variables, but their values can differ from one neuron
to the next. They are implemented internally as differential equations with zero
derivative.

\end{itemize}

Right hand sides must be valid Python expressions, possibly including comments and
multiline characters (\code{\textbackslash{}}).

The units of all variables except aliases must be specified. Note that in first line,
the units \emph{volt} are meant for x, not dx/dt. The consistency of all units is checked
with the method \code{check\_units()}, which is automatically called
when initialising a neuron group (through the method \code{prepare()}).

When an \hyperlink{brian.Equations}{\code{Equations}} object is finalised (through the method \code{prepare()},
automatically called the \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} initialiser), the names of variables defined by
non-differential equations are replaced by their (string) values, so that differential equations
are self-consistent. In the process, names of external variables are also modified to avoid
conflicts (by adding a prefix).


\subsection{Neuron groups}

The key idea for efficient simulations is to update synchronously the state variables
of all identical neuron models. A neuron group is defined by the model equations, and
optionnally a threshold condition and a reset. For example for 100 neurons:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dv/dt=-v/tau : volt]@PYGad['])
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)
\end{Verbatim}

The \code{model} keyword also accepts strings (in that case it is converted to an \hyperlink{brian.Equations}{\code{Equations}}
object), e.g.:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]@PYGad[']@PYGad[dv/dt=-v/tau : volt]@PYGad['],reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)
\end{Verbatim}

The units of both the reset and threshold are checked for consistency with the equations.
The code above defines a group of 100 integrate-and-fire neurons with threshold 10 mV and
reset 0 mV. The second line defines an object named \code{group} which contains all the state
variables, which can be accessed with the dot notation, i.e. \code{group.v} is a vector with
the values of variable \code{v} for all of the 100 neurons. It is an array with units as defined
in the equations (here, volt). By default, all state variables are initialised at value 0.
It can be initialised by the user as in the following example:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[.]v@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]mV,@PYGaw[10]@PYGbe[*]mV,@PYGaw[100])
\end{Verbatim}

Here the values of \code{v} for all the neurons are evenly spaced between 0 mV and 10 mV
(\code{linspace} is a NumPy function). The method \code{group.rest()} may also be used to set the
resting point of the equations, but convergence is not always guaranteed.


\subsubsection{Important options}
\begin{itemize}
\item {} 
\code{refractory}: a refractory period (default 0 ms), to be used in combination with the \code{reset} value.

\item {} 
\code{implicit} (default \code{False}): if True, then an implicit method is used. This is useful
for Hodgkin-Huxley equations, which are stiff.

\end{itemize}


\subsubsection{Subgroups}

Subgroups can be created with the slice operator:

\begin{Verbatim}[commandchars=@\[\]]
subgroup1@PYGbe[=]group@lb[]@PYGaw[0]:@PYGaw[50]@rb[]
subgroup2@PYGbe[=]group@lb[]@PYGaw[50]:@PYGaw[100]@rb[]
\end{Verbatim}

Then \code{subgroup2.v{[}i{]}} equals \code{group.v{[}50+i{]}}.
An alternative equivalent method is the following:

\begin{Verbatim}[commandchars=@\[\]]
subgroup1@PYGbe[=]group@PYGbe[.]subgroup(@PYGaw[50])
subgroup2@PYGbe[=]group@PYGbe[.]subgroup(@PYGaw[50])
\end{Verbatim}

The parent group keeps track of the allocated subgroups. But note that the two methods are
mutually exclusive, e.g. in the following example:

\begin{Verbatim}[commandchars=@\[\]]
subgroup1@PYGbe[=]group@lb[]@PYGaw[0]:@PYGaw[50]@rb[]
subgroup2@PYGbe[=]group@PYGbe[.]subgroup(@PYGaw[50])
\end{Verbatim}

both subgroups are actually identical.

Subgroups are useful when creating connections or monitoring the state variables or spikes.
The best practice is to define groups as large as possible, then divide them in subgroups if necessary.
Indeed, the larger the groups are, the faster the simulation runs. For example, for a network with a feedforward
architecture, one should first define one group holding all the neurons in the network, then define the layers as
subgroups of this big group.


\subsection{Reset}

More complex resets can be defined. The value of the \code{reset} keyword can be:
\begin{itemize}
\item {} 
a quantity (\code{0*mV})

\item {} 
a function

\item {} 
a \hyperlink{brian.Reset}{\code{Reset}} object, which can be used for resetting a specific state variable or
for resetting a state variable to the value of another variable.

\end{itemize}


\subsubsection{Functional reset}

To define a specific reset, the generic method is define a function as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[myreset](P,spikes):
  P@PYGbe[.]v@lb[]spikes@rb[]@PYGbe[=]rand(@PYGaX[len](spikes))@PYGbe[*]@PYGaw[5]@PYGbe[*]mV
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]myreset,threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)
\end{Verbatim}

or faster:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[myreset](P,spikes):
  P@PYGbe[.]v_@lb[]spikes@rb[]@PYGbe[=]rand(@PYGaX[len](spikes))@PYGbe[*]@PYGaw[5]@PYGbe[*]mV
\end{Verbatim}

Every time step, the user-defined function is called with arguments
\code{P}, the neuron group, and \code{spikes}, the list of indexes of the neurons that just spiked.
The function above resets the neurons that just spiked to a random value.


\subsubsection{Resetting another variable}

It is possible to specify the reset variable explicitly:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]Reset(@PYGaw[0]@PYGbe[*]mV,state@PYGbe[=]@PYGad[']@PYGad[w]@PYGad[']),threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)
\end{Verbatim}

Here the variable \code{w} is reset.


\subsubsection{Resetting to the value of another variable}

The value of the reset can be given by another state variable:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]VariableReset(@PYGaw[0]@PYGbe[*]mV,state@PYGbe[=]@PYGad[']@PYGad[v]@PYGad['],resetvaluestate@PYGbe[=]@PYGad[']@PYGad[w]@PYGad[']),threshold@PYGbe[=]@PYGaw[10]@PYGbe[*]mV)
\end{Verbatim}

Here the value of the variable \code{w} is used to reset the variable \code{v}.


\subsection{Threshold}

As for the reset, the threshold can be customised.


\subsubsection{Functional threshold}

The generic method to define a custom threshold condition is to pass a function of the
state variables which returns a boolean (true if the threshold condition is met), for example:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=-v/tau : volt]
@PYGad[dw/dt=(v-w)/tau : volt]
@PYGad[''']
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]@PYGay[lambda] v,w:v@PYGbe[>]@PYGbe[=]w)
\end{Verbatim}

Here we used an anonymous function (\code{lambda} keyword) but of course a named function can also
be used. In this example, spikes are generated when v is greater than w.
Note that the arguments of the function must be the state variables with the same order as
in the \hyperlink{brian.Equations}{\code{Equations}} string.


\subsubsection{Thresholding another variable}

It is possible to specify the threshold variable explicitly:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]Threshold(@PYGaw[0]@PYGbe[*]mV,state@PYGbe[=]@PYGad[']@PYGad[w]@PYGad[']))
\end{Verbatim}

Here the variable \code{w} is checked.


\subsubsection{Using another variable as the threshold value}

The same model as in the functional threshold example can be defined as follows:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]\
      VariableThreshold(state@PYGbe[=]@PYGad[']@PYGad[v]@PYGad['],threshold_state@PYGbe[=]@PYGad[']@PYGad[w]@PYGad[']))
\end{Verbatim}


\subsubsection{Empirical threshold}

For Hodgkin-Huxley models, one needs to determine the threshold empirically. Here the
\emph{threshold} should really be understood rather as the onset of the spikes (used to propagate
the spikes to the other neurons), since there is no explicit reset. There is a
\hyperlink{brian.Threshold}{\code{Threshold}} subclass for this purpose:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,threshold@PYGbe[=]EmpiricalThreshold(threshold@PYGbe[=]@PYGbe[-]@PYGaw[20]@PYGbe[*]mV,refractory@PYGbe[=]@PYGaw[3]@PYGbe[*]ms))
\end{Verbatim}

Spikes are triggered when the membrane potential reaches the value -20 mV, but only if it
has not spiked in the last 3 ms (otherwise there would be spikes every time step during the action
potential). The \code{state} keyword may be used to specify the state variable which should be checked
for the threshold condition.


\subsubsection{Poisson threshold}

It is possible to generate spikes with a given probability rather than when a threshold condition
is met, by using the class \code{PoissonThreshold}, as in the following example:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]@PYGad[']@PYGad[x : Hz]@PYGad['],threshold@PYGbe[=]PoissonThreshold(state@PYGbe[=]@PYGad[']@PYGad[x]@PYGad[']))
x@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]Hz,@PYGaw[10]@PYGbe[*]Hz,@PYGaw[100])
\end{Verbatim}

Here spikes are generated as Poisson processes with rates given by the variable x
(the \code{state} keyword is optional: default = first variable defined). Note that x can
change over time (inhomogeneous Poisson processes). The units of variable x must be Hertz.

\resetcurrentobjects


\section{Connections}


\subsection{Building connections}

First, one must define which neuron groups are connected and which state variable receives the spikes.
The following instruction:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['])
\end{Verbatim}

defines a connection from group \code{group1} to \code{group2}, acting on variable \code{ge}. When
neurons from group \code{group1} spike, the variable \code{ge} of the target neurons in group
\code{group2} are incremented. When the connection object is initialised, the list of connections
is empty. It can be created in several ways. First, explicitly:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@lb[]@PYGaw[2],@PYGaw[5]@rb[]@PYGbe[=]@PYGaw[3]@PYGbe[*]nS
\end{Verbatim}

This instruction connects neuron 2 from \code{group1} to neuron 5 from \code{group2} with synaptic weight
3 nS. Units should match the units of the variable defined at initialisation time (\code{ge}).

The matrix of synaptic weights can be defined directly with the method \code{Connection.connect()}:

\begin{Verbatim}[commandchars=@\[\]]
W@PYGbe[=]rand(@PYGaX[len](group1),@PYGaX[len](group2))@PYGbe[*]nS
myconnection@PYGbe[.]connect(group1,group2,W)
\end{Verbatim}

Here a matrix with random elements is used to define the synaptic weights from \code{group1}
to \code{group2}. It is possible to build the matrix by block by using subgroups, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
W@PYGbe[=]rand(@PYGaw[20],@PYGaw[30])@PYGbe[*]nS
myconnection@PYGbe[.]connect(group1@lb[]@PYGaw[0]:@PYGaw[20]@rb[],group2@lb[]@PYGaw[10]:@PYGaw[40]@rb[],W)
\end{Verbatim}

There are several handy functions available to set the synaptic weights:
\code{connect\_full()}, \code{connect\_random()} and
\code{connect\_one\_to\_one()}. The first one
is used to set uniform weights for all pairs of neurons in the (sub)groups:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[.]connect_full(group1@lb[]@PYGaw[0]:@PYGaw[20]@rb[],group2@lb[]@PYGaw[10]:@PYGaw[40]@rb[],weight@PYGbe[=]@PYGaw[5]@PYGbe[*]nS)
\end{Verbatim}

The second one is used to set uniform weights for random pairs of neurons in the (sub)groups:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[.]connect_random(group1@lb[]@PYGaw[0]:@PYGaw[20]@rb[],group2@lb[]@PYGaw[10]:@PYGaw[40]@rb[],@PYGaw[0.02],weight@PYGbe[=]@PYGaw[5]@PYGbe[*]nS)
\end{Verbatim}

Here the third argument (0.02) is the probability that a synaptic connection exists between two neurons.
The number of presynaptic neurons can be made constant by setting the keyword \code{fixed=True}
(probability * number of neurons in \code{group1}).
Finally, the method \code{connect\_one\_to\_one()} connects neuron i from the first
group to neuron i from the second group:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[.]connect_one_to_one(group1,group2,weight@PYGbe[=]@PYGaw[3]@PYGbe[*]nS)
\end{Verbatim}

Both groups must have the same number of neurons.


\subsubsection{Building connections with connectivity functions}

There is a simple and efficient way to build heterogeneous connections, by passing functions
instead of constants to the methods \code{connect\_full()} and \code{connect\_random()}.
The function must return the synaptic weight for a given pair of neuron (i,j).
For example:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[.]connect_full(group1,group2,weight@PYGbe[=]@PYGay[lambda] i,j:(@PYGaw[1]@PYGbe[+]cos(i@PYGbe[-]j))@PYGbe[*]@PYGaw[2]@PYGbe[*]nS)
\end{Verbatim}

where i (j) indexes neurons in \code{group1} (\code{group2}). This is the same as doing by hand:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaX[len](group1)):
  @PYGay[for] j @PYGan[in] @PYGaX[range](@PYGaX[len](group2)):
    myconnection@lb[]i,j@rb[]@PYGbe[=](@PYGaw[1]@PYGbe[+]cos(i@PYGbe[-]j))@PYGbe[*]@PYGaw[2]@PYGbe[*]nS
\end{Verbatim}

but it is much faster because the construction is vectorised, i.e., the function is called for every i
with j being the entire row of target indexes. Thus, the implementation is closer to:

\begin{Verbatim}[commandchars=@\[\]]
for i in range(len(group1)):
    myconnection@lb[]i,j@rb[]=(1+cos(i-arange(len(group2)))*2*nS
\end{Verbatim}

The method \code{connect\_random()} also accepts functional arguments for the
weights (not the connection probability yet). For that method, it is possible to pass a function
with no argument, as in the following example:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[.]connect_random(group1,group2,@PYGaw[0.1],weight@PYGbe[=]@PYGay[lambda]:rand()@PYGbe[*]nS)
\end{Verbatim}

Here each synaptic weight is random (between 0 and 1 nS).


\subsection{Delays}

Transmission delays can be introduced with the keyword \code{delay}, passed at initialisation time:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],delay@PYGbe[=]@PYGaw[3]@PYGbe[*]ms)
\end{Verbatim}

Note that all synaptic connections have the same delay. To define connections with different delays,
several Connection objects must be introduced, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
myconnection_fast@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],delay@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
myconnection_slow@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],delay@PYGbe[=]@PYGaw[5]@PYGbe[*]ms)
\end{Verbatim}


\subsection{Connection structure}

The underlying data structure used to store the synaptic connections is by default a sparse
matrix. If the connections are dense, it is more efficient to use a dense matrix, which can be
set at initialisation time:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
\end{Verbatim}

Currently, long-term plasticity (STDP) can only be implemented with dense matrices.
The \code{structure} keyword can take the following values: sparse (default), dense and
computed. The last one correspond to synaptic connections which are calculated on the fly,
but this feature is not implemented yet.


\subsection{Modulation}

The synaptic weights can be modulated by a state variable of the presynaptic neurons with
the keyword \code{modulation}:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[=]Connection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],modulation@PYGbe[=]@PYGad[']@PYGad[u]@PYGad['])
\end{Verbatim}

When a spike is produced by a presynaptic neuron (\code{group1}), the variable ge of each postsynaptic
neuron (\code{group2}) is incremented by the synaptic weight multiplied by the value of the variable u
of the presynaptic neuron. This is useful to implement short-term plasticity.


\subsection{Direct connection}

In some cases, it is useful to connect a group directly to another one, in a one-to-one fashion.
The most efficient way to implement it is with the class \code{IdentityConnection}:

\begin{Verbatim}[commandchars=@\[\]]
myconnection@PYGbe[=]IdentityConnection(group1,group2,@PYGad[']@PYGad[ge]@PYGad['],weight@PYGbe[=]@PYGaw[1]@PYGbe[*]nS)
\end{Verbatim}

With this structure, the synaptic weights are homogeneous (it is not possible to define them
independently). When neuron i from \code{group1} spikes, the variable ge of neuron i from \code{group2}
is increased by 1 nS. A typical application is when defining inputs to a network.

\resetcurrentobjects


\section{Recording}

The activity of the network can be recorded by defining \emph{monitors}.


\subsection{Recording spikes}

To record the spikes from a given group, define a \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} object:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]SpikeMonitor(group)
\end{Verbatim}

At the end of the simulation, the spike times are stored in the variable \code{spikes} as
a list of pairs (i,t) where neuron i fired at time t. For example, the following code extracts
the list of spike times for neuron 3:

\begin{Verbatim}[commandchars=@\[\]]
spikes3@PYGbe[=]@lb[]t @PYGay[for] i,t @PYGan[in] M@PYGbe[.]spikes @PYGay[if] i@PYGbe[==]@PYGaw[3]@rb[]
\end{Verbatim}

but this operation can be done directly as follows:

\begin{Verbatim}[commandchars=@\[\]]
spikes3@PYGbe[=]M@lb[]@PYGaw[3]@rb[]
\end{Verbatim}

The total number of spikes is \code{M.nspikes}.


\subsubsection{Custom monitoring}

To process the spikes in a specific way, one can pass a function at initialisation of the
\hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} object:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f](spikes):
  @PYGay[print] spikes

M@PYGbe[=]SpikeMonitor(group,function@PYGbe[=]f)
\end{Verbatim}

The function \code{f} is called every time step with the argument \code{spikes} being the list of
indexes of neurons that just spiked.


\subsection{Recording state variables}

State variables can be recorded continuously by defining a \hyperlink{brian.StateMonitor}{\code{StateMonitor}} object, as follows:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['])
\end{Verbatim}

Here the state variables \code{v} of the defined group are monitored. By default, only the statistics
are recorded. The list of time averages for all neurons is \code{M.mean}; the standard deviations are stored
in \code{M.std} and the variances in \code{M.var}. Note that these are averages over time, not over the neurons.

To record the values of the state variables over the whole simulation, use the keyword \code{record}:

\begin{Verbatim}[commandchars=@\[\]]
M1@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True])
M2@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@lb[]@PYGaw[3],@PYGaw[5],@PYGaw[9]@rb[])
\end{Verbatim}

The first monitor records the value of \code{v} for all neurons while the second one records \code{v} for
neurons 3, 5 and 9 only. The list of times is stored in \code{M1.times} and the lists of values are stored in
\code{M1{[}i{]}}, where i the index of the neuron.
By default, the values of the state variables are recorded every timestep, but one may record every n timesteps
by setting the keyword \code{timestep}:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[v]@PYGad['],record@PYGbe[=]@PYGaA[True],timestep@PYGbe[=]n)
\end{Verbatim}


\subsection{Counting spikes}

To count the total number of spikes produced by a group, use a \hyperlink{brian.PopulationSpikeCounter}{\code{PopulationSpikeCounter}} object:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]PopulationSpikeCounter(group)
\end{Verbatim}

Then the number of spikes after the simulation is \code{M.nspikes}. If you need to count the spikes
separately for each neuron, use a \hyperlink{brian.SpikeCounter}{\code{SpikeCounter}} object:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]SpikeCounter(group)
\end{Verbatim}

Then \code{M{[}i{]}} is the number of spikes produced by neuron i.


\subsection{Recording population rates}

The population rate can be monitored with a \hyperlink{brian.PopulationRateMonitor}{\code{PopulationRateMonitor}} object:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]PopulationRateMonitor(group)
\end{Verbatim}

After the simulation, \code{M.times} contains the list of recording times and
\code{M.rate} is the list of rate values (where the rate is meant in the spatial sense: average rate over
the whole group at some given time). The bin size is set with the \code{bin} keyword (in seconds):

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]PopulationRateMonitor(group,bin@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
\end{Verbatim}

Here the averages are calculated over 1 ms time windows. Alternatively, one can use the
\code{smooth\_rate()} method to smooth the rates:

\begin{Verbatim}[commandchars=@\[\]]
rates@PYGbe[=]M@PYGbe[.]smooth_rate(width@PYGbe[=]@PYGaw[1]@PYGbe[*]ms,@PYGaX[filter]@PYGbe[=]@PYGad[']@PYGad[gaussian]@PYGad['])
\end{Verbatim}

The rates are convolved with a linear filter, which is either a Gaussian function
(\code{gaussian}, default) or a box function (`flat').

\resetcurrentobjects


\section{Inputs}

Some specific types of neuron groups are available to provide inputs to a network.


\subsection{Poisson inputs}

Poisson spike trains can be generated as follows:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]PoissonGroup(@PYGaw[100],rates@PYGbe[=]@PYGaw[10]@PYGbe[*]Hz)
\end{Verbatim}

Here 100 neurons are defined, which emit spikes independently according to Poisson
processes with rates 10 Hz. To have different rates across the group,
initialise with an array of rates:
\begin{quote}

group=PoissonGroup(100,rates=linspace(0*Hz,10*Hz,100))
\end{quote}

Inhomogeneous Poisson processes can be defined by passing a function of time that returns the
rates:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]PoissonGroup(@PYGaw[100],rates@PYGbe[=]@PYGay[lambda] t:(@PYGaw[1]@PYGbe[+]cos(t))@PYGbe[*]@PYGaw[10]@PYGbe[*]Hz)
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=@\[\]]
r0@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]Hz,@PYGaw[10]@PYGbe[*]Hz,@PYGaw[100])
group@PYGbe[=]PoissonGroup(@PYGaw[100],rates@PYGbe[=]@PYGay[lambda] t:(@PYGaw[1]@PYGbe[+]cos(t))@PYGbe[*]r0)
\end{Verbatim}


\subsection{Correlated inputs}

Generation of correlated spike trains is partially implemented, using algorithms from the
the following paper: Brette, R. (2008) \href{http://www.di.ens.fr/\textasciitilde{}brette/papers/Brette2008NC.html}{Generation of correlated spike trains}, Neural Computation.

To generate correlated spike trains with identical rates and homogeneous exponential correlations,
use the class \code{HomogeneousCorrelatedSpikeTrains}:

\begin{Verbatim}[commandchars=@\[\]]
group@PYGbe[=]HomogeneousCorrelatedSpikeTrains(@PYGaw[100],r@PYGbe[=]@PYGaw[10]@PYGbe[*]Hz,c@PYGbe[=]@PYGaw[0.1],tauc@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

where \code{r} is the rate, \code{c} is the total correlation strength and \code{tauc} is the correlation time constant.
The implementation uses Cox processes (or doubly stochastic processes) to generate the spike trains.

Heterogeneous spike trains have not been implemented yet (but will be).


\subsection{Input spike trains}

A set of spike trains can be explicitly defined as list of pairs (i,t)
(meaning neuron i fires at time t), which used to initialise a
\hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}:

\begin{Verbatim}[commandchars=@\[\]]
spiketimes@PYGbe[=]@lb[](@PYGaw[0],@PYGaw[1]@PYGbe[*]ms), (@PYGaw[1],@PYGaw[2]@PYGbe[*]ms)@rb[]
@PYGaX[input]@PYGbe[=]SpikeGeneratorGroup(@PYGaw[5],spiketimes)
\end{Verbatim}

The neuron 0 fires at time 1 ms and neuron 1 fires at time 2 ms (there are 5 neurons,
but 3 of them never spike).
One may also pass a generator instead of a list (in that case the pairs should be
ordered in time).

Spike times may also be provided separately for each neuron, using the
\hyperlink{brian.MultipleSpikeGeneratorGroup}{\code{MultipleSpikeGeneratorGroup}} class:

\begin{Verbatim}[commandchars=@\[\]]
S0@PYGbe[=]@lb[]@PYGaw[1]@PYGbe[*]ms, @PYGaw[2]@PYGbe[*]ms@rb[]
S1@PYGbe[=]@lb[]@PYGaw[3]@PYGbe[*]ms@rb[]
S2@PYGbe[=]@lb[]@PYGaw[1]@PYGbe[*]ms, @PYGaw[3]@PYGbe[*]ms, @PYGaw[5]@PYGbe[*]ms@rb[]
@PYGaX[input]@PYGbe[=]MultipleSpikeGeneratorGroup(@lb[]S0,S1,S2@rb[])
\end{Verbatim}

The object is initialised with a list of spike containers, one for each neuron.
Each container can be a sorted list of spike times or any iterable object returning
the spike times (ordered in time).


\subsubsection{Gaussian spike packets}

There is a subclass of \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} for generating spikes with a Gaussian
distribution:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaX[input]@PYGbe[=]PulsePacket(t@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,n@PYGbe[=]@PYGaw[10],sigma@PYGbe[=]@PYGaw[3]@PYGbe[*]ms)
\end{Verbatim}

Here 10 spikes are produced, with spike times distributed according a Gaussian distribution with
mean 10 ms and standard deviation 3 ms.


\subsection{Direct input}

Inputs may also be defined by accessing directly the state variables of a neuron group. The standard way
to do this is to insert parameters in the equations:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]@PYGad[''']
@PYGad[dv/dt=(I-x)/tau : volt]
@PYGad[I : volt]
@PYGad[''']
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]@PYGaw[15]@PYGbe[*]mV)
group@PYGbe[.]I@PYGbe[=]linspace(@PYGaw[0]@PYGbe[*]mV,@PYGaw[20]@PYGbe[*]mV,@PYGaw[100])
\end{Verbatim}

Here the value of the parameter I for each neuron is provided at initialisation time
(evenly distributed between 0 mV and 20 mV).
It is possible to change the value of I every timestep by using a user-defined operation (see next
section).

\resetcurrentobjects


\section{User-defined operations}

In addition to neuron models, the user can provide functions that are to be called every timestep
during the simulation, using the decorator \hyperlink{brian.network_operation}{\code{network\_operation()}}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[myoperation]():
    do_something_every_timestep()
\end{Verbatim}

The operation may be called at regular intervals by defining a clock:

\begin{Verbatim}[commandchars=@\[\]]
myclock@PYGbe[=]Clock(dt@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)

@PYGaC[@at[]network_operation](myclock)
@PYGay[def] @PYGaK[myoperation]():
    do_something_every_ms()
\end{Verbatim}

\resetcurrentobjects
\index{plotting}

\hypertarget{index-0}{}\section{Analysis and plotting}
\indexii{plotting}{pylab}
Most plotting should be done with the PyLab commands, all of
which are loaded when you import Brian. See:
\begin{quote}

\href{http://matplotlib.sourceforge.net/matplotlib.pylab.html}{http://matplotlib.sourceforge.net/matplotlib.pylab.html}
\end{quote}

for help on PyLab. The scientific library \href{http://www.scipy.org}{Scipy} is also automatically
imported by the instruction \code{from brian import *}.

The most useful plotting instruction is the Pylab function \code{plot}. A typical use with Brian is:

\begin{Verbatim}[commandchars=@\[\]]
plot(t@PYGbe[/]ms,vm@PYGbe[/]mV)
\end{Verbatim}

where t is a vector of times with units ms and vm is a vector of voltage values with units mV.
To display the figures on the screen, the function \code{show()} must be called once (this should be the
last line of your script), except when using IPython with the Pylab mode (\code{ipython -pylab}).

Brian currently defines just two plotting functions of its own,
\hyperlink{brian.raster_plot}{\code{raster\_plot()}} and \hyperlink{brian.hist_plot}{\code{hist\_plot()}}.


\subsection{Raster plots}

Spike trains recorded by a \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} can be displayed as raster plots:

\begin{Verbatim}[commandchars=@\[\]]
S@PYGbe[=]SpikeMonitor(group)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
raster_plot(S)
\end{Verbatim}

Usual options of the \code{plot} command can also be passed to \hyperlink{brian.raster_plot}{\code{raster\_plot()}}. One may also pass
several spike monitors as arguments.

\resetcurrentobjects
\index{clock}

\hypertarget{index-2}{}\section{Clocks}

Brian is a clock-based simulator: operations are done synchronously at each tick of a clock.

Many Brian objects store a clock object, passed in the initialiser with the optional keyword \code{clock}.
For example, to simulate a neuron group with time step dt=1 ms:

\begin{Verbatim}[commandchars=@\[\]]
myclock@PYGbe[=]Clock(dt@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]@PYGad[']@PYGad[dx/dt=1*mV/ms : volt]@PYGad['],clock@PYGbe[=]myclock)
\end{Verbatim}

If no clock is specified, the program uses the global default clock. When Brian is initially
imported, this is the object \hyperlink{brian.defaultclock}{\code{defaultclock}}, and it has a default
time step of 0.1 ms. In a simple script, you can override this by writing (for example):

\begin{Verbatim}[commandchars=@\[\]]
defaultclock@PYGbe[.]dt @PYGbe[=] @PYGaw[1]@PYGbe[*]ms
\end{Verbatim}

You may wish to use multiple clocks in your program. In this case,
for each object which requires one, you have to pass a copy of its
\hyperlink{brian.Clock}{\code{Clock}} object. The network run function automatically handles objects
with different clocks, updating them all at the appropriate time
according to their time steps (value of \hyperlink{brian.Clock.dt}{\code{dt}}).

Multiple clocks can be useful, for example, for defining a simulation
that runs with a very small \code{dt}, but with some computationally
expensive operation running at a lower frequency. In the following example, the model
is simulated with dt=0.01 ms and the variable x is recorded every ms:

\begin{Verbatim}[commandchars=@\[\]]
simulation_clock@PYGbe[=]Clock(dt@PYGbe[=]@PYGaw[0.01]@PYGbe[*]ms)
record_clock@PYGbe[=]Clock(dt@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]@PYGad[']@PYGad[dx/dt=-x/tau : volt]@PYGad['],clock@PYGbe[=]simulation_clock)
M@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[x]@PYGad['],record@PYGbe[=]@PYGad[']@PYGad[True]@PYGad['],clock@PYGbe[=]record_clock)
\end{Verbatim}

The current time of a clock is stored in the attribute \code{t} (\code{simulation\_clock.t}) and
the timestep is stored in the attribute \code{dt}.

\resetcurrentobjects
\indexii{simulation}{control}

\hypertarget{index-98}{}\section{Simulation control}
\index{simulation!update schedule}

\hypertarget{index-99}{}\subsection{The update schedule}

When a simulation is run, the operations are done in the following order by default:
\begin{enumerate}
\item {} 
Update every \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, this typically performs an integration time step for the differential equations defining the neuron model.

\item {} 
Check the threshold condition and propagate the spikes to the target neurons.

\item {} 
Reset all neurons that spiked.

\item {} 
Call all user-defined operations and state monitors.

\end{enumerate}

The user-defined operations and state monitors can be placed at other places in this schedule, by
using the keyword \code{when}. The values can be \code{start}, \code{before\_groups}, \code{after\_groups},
\code{middle}, \code{before\_connections}, \code{after\_connections}, \code{before\_resets}, \code{after\_resets} or
\code{end} (default: end). For example, to call a function \code{f} at the beginning of every timestep:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[start]@PYGad['])
@PYGay[def] @PYGaK[f]():
  do_something()
\end{Verbatim}

or to record the value of a state variable just before the resets:

\begin{Verbatim}[commandchars=@\[\]]
M@PYGbe[=]StateMonitor(group,@PYGad[']@PYGad[x]@PYGad['],record@PYGbe[=]@PYGaA[True],when@PYGbe[=]@PYGad[']@PYGad[before_resets]@PYGad['])
\end{Verbatim}


\subsection{Basic simulation control}

The simulation is run simply as follows:

\begin{Verbatim}[commandchars=@\[\]]
run(@PYGaw[1000]@PYGbe[*]ms)
\end{Verbatim}

where 1000 ms is the duration of the run. It can be stopped during the simulation with the instruction
\code{stop()}, and the network can be reinitialised with the instruction \code{reinit()}.

When the \hyperlink{brian.run}{\code{run()}} function is called, Brian looks for all relevant
objects in the namespace (groups, connections, monitors, user operations), and runs them.
In complex scripts, the user might want to run only selected objects. In that case, a \hyperlink{brian.Network}{\code{Network}} object
needs to be created.


\subsection{The Network class}

A \hyperlink{brian.Network}{\code{Network}} object holds a collection of objets that can be run, i.e., objects with class \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}},
\hyperlink{brian.Connection}{\code{Connection}}, \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}}, \hyperlink{brian.StateMonitor}{\code{StateMonitor}} (or subclasses) or any user-defined operation with the decorator
\hyperlink{brian.network_operation}{\code{network\_operation()}}. Thoses objects can then be simulated. Example:

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] NeuronGroup(@PYGbe[.]@PYGbe[.]@PYGbe[.])
C @PYGbe[=] Connection(@PYGbe[.]@PYGbe[.]@PYGbe[.])
net @PYGbe[=] Network(G,C)
net@PYGbe[.]run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

You can also pass lists of objects. The simulation can be controlled with the methods
\code{stop} and \code{reinit}.

\resetcurrentobjects
\index{equations}

\hypertarget{index-5}{}\section{More on equations}

The \hyperlink{brian.Equations}{\code{Equations}} class is a central part of Brian, since
models are generally specified with an \hyperlink{brian.Equations}{\code{Equations}} object.
Here we explain advanced aspects of this class.
\indexii{equations}{external variables}\indexii{equations}{namespaces}

\hypertarget{index-6}{}\subsection{External variables}

Equations may contain external variables. When an \hyperlink{brian.Equations}{\code{Equations}} object is initialised,
a dictionary is built with the values of all external variables. These values are taken
from the namespace where the \hyperlink{brian.Equations}{\code{Equations}} object was defined. It is possible to go one or
several levels up in the namespaces by specifying the keyword \code{level} (default=0).
The value of these parameters can in general be changed during the simulation and the
modifications are taken into account, except in two situations: when the equations are
frozen (see below) or when the integration is exact (linear equations). In those cases,
the values of the parameters are the ones at initialisation time.

Alternatively, the string defining the equations can be evaluated within a given namespace
by providing keywords at initialisation time, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dx/dt=-x/tau : volt]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

In that case, the values of all external variables are taken from the specified
dictionary (given by the keyword arguments), even if variables with the same name
exist in the namespace where the string was defined. The two methods for passing the
values of external variables are mutually exclusive, that is, either all external variables
are explicitly specified with keywords (if not, they are left unspecified even if there
are variables with the same names in the namespace where the string was defined), or all
values are taken from the calling namespace.

More can be done with keyword arguments. If the value is a string, then the name of the
variable is replaced, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dx/dt=-x/tau : volt]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,x@PYGbe[=]@PYGad[']@PYGad[Vm]@PYGad['])
\end{Verbatim}

changes the variable name x to Vm. This is useful for writing functions which return
equations where the variable name is provided by the user.

Finally, if the value is \code{None} then the name of the variable is replaced by a unique
name, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dx/dt=-x/tau : volt]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,x@PYGbe[=]@PYGaA[None])
\end{Verbatim}

This is useful to avoid conflicts in the names of hidden variables.


\subsubsection{Issues}
\begin{itemize}
\item {} 
There can be problems if a variable with the same name as the variable of a
differential equation exists in the namespace where the \hyperlink{brian.Equations}{\code{Equations}} object was defined.

\end{itemize}
\indexii{equations}{combining}

\subsection{Combining equations}

\hyperlink{brian.Equations}{\code{Equations}} can be combined using the sum operator. For example:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dx/dt=(y-x)/tau : volt]@PYGad['])
eqs@PYGbe[+]@PYGbe[=]Equations(@PYGad[']@PYGad[dy/dt=-y/tau: volt]@PYGad['])
\end{Verbatim}

Note that some variables may be undefined when defining the first equation. No error is
raised when variables are undefined and absent from the calling namespace.
When two \hyperlink{brian.Equations}{\code{Equations}} objects are added, the consistency is checked. For example it is not
possible to add two \hyperlink{brian.Equations}{\code{Equations}} objects which define the same variable.
\indexii{equations}{membrane potential}

\subsection{Which variable is the membrane potential?}

Several objects, such as \hyperlink{brian.Threshold}{\code{Threshold}} or \hyperlink{brian.Reset}{\code{Reset}} objects
can be initialised without specifying which variable is the membrane potential, in which
case it is assumed that it is the first variable.
Internally, the variables of an \hyperlink{brian.Equations}{\code{Equations}} object are reorderered so that the first one
is most likely to be the membrane potential (using \code{Equations.get\_Vm()}).
The first variable is, with decreasing priority :
\begin{itemize}
\item {} 
v

\item {} 
V

\item {} 
vm

\item {} 
Vm

\item {} 
the first defined variable.

\end{itemize}
\indexii{equations}{numerical integration}\hypertarget{numerical-integration}{}

\subsection{Numerical integration}

The currently available integration methods are:
\begin{itemize}
\item {} 
Exact integration when the equations are linear.

\item {} 
Euler integration (explicit, first order).

\item {} 
Runge-Kutta integration (explicit, second order).

\item {} 
Exponential Euler integration (implicit, first order).

\end{itemize}

The method is selected when a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} is initialized.
If the equations are linear, exact integration is automatically selected.
Otherwise, Euler integration is selected by default, unless the keyword
\code{implicit=True} is passed, which selects the exponential Euler method. A second-order method
can be selected using the keyword \code{order=2} (explicit Runge-Kutta method, midpoint estimation).
It is possible to override this behaviour with the \code{method} keyword when initialising
a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}. Possible values are \code{linear}, \code{nonlinear},
\code{Euler}, \code{RK}, \code{exponential\_Euler}.
\indexii{equations}{linear}\indexii{numerical integration}{exact}\indexii{numerical integration}{semi-exact}

\hypertarget{index-10}{}\subsubsection{Exact integration}

If the differential equations are linear, then the update phase
X(t)-\textgreater{}X(t+dt) can be calculated exactly with a matrix product.
First, the equations are examined to determine whether they are linear
with the method \code{islinear()} and the function
\code{is\_affine()} (this is currently done using dynamic typing).
Second, the matrix M and the vector B such that dX/dt=M(X-B) are calculated with
the function \code{get\_linear\_equations()} \footnotemark[1].
Third, the matrix A such that X(t+dt)=A*(X(t)-B)+B is calculated at initialisation
of a specific state updater object, \hyperlink{brian.LinearStateUpdater}{\code{LinearStateUpdater}},
as A=expm(M*dt), where expm is the matrix exponential.

\textbf{Important remark}: since the update matrix and vector are precalculated,
the values of all external variables in the equations are frozen at
initialisation. If external variables are modified after initialisation,
those modifications are \emph{not} taken into account during the simulation.

\textbf{Inexact exact integration}: If the equation cannot be put into the form dX/dt=M(X-B),
for example if the equation is dX/dt=MX+A where M is not invertible, then the equations
are not integrated exactly, but using a system equivalent to Euler integration but with
dt 100 times smaller than specified. Updates are of the form X(t+dt)=A*X(t)+C where the
matrix A and vector C are computed by applying Euler integration 100 times to the
differential equations.
\indexii{numerical integration}{Euler}

\subsubsection{Euler integration}

The Euler is a first order explicit integration method. It is the default one for
nonlinear equations. It is simply implemented as X(t+dt)=X(t)+f(X)*dt.
\indexii{numerical integration}{exponential Euler}\indexii{numerical integration}{Hodgin-Huxley type equations}

\subsubsection{Exponential Euler integration}

The exponential Euler method is used for Hodgkin-Huxley type
equations, are which stiff.
Equations of that type are conditionally linear, that is, the differential equation
for each variable is linear in that variable (i.e., linear if all other variables
are considered constant).
The idea is thus to solve the differential equation for each variable over one time step,
assuming that all other variables are constant over that time step. The numerical scheme
is still first order, but it is more stable than the forward Euler method.
Each equation can be written as dx/dt=a*x+b, where a and b depend on the other variables
and thus change after each time step.
The values of a and b are obtained during the update phase by calculating a*x+b for x=0 and x=1
(note that these values are different for every neuron, thus we calculate vectors A and B).
Then x(t+dt) is calculated in the same way as for the exact integration method above.
\index{equations!stochastic}\indexii{differential equations}{stochastic}

\subsection{Stochastic differential equations}

Noise is introduced in differential equations with the keyword
\code{xi}, which means normalised gaussian noise (the derivative of the Brownian term).
Currently, this is implemented simply by adding a normal random number to the variable
at the end of the integration step (independently for each neuron).
The unit of white noise is non-trivial, it is \code{second**(-.5)}. Thus, a typical stochastic
equation reads:

\begin{Verbatim}[commandchars=@\[\]]
dx@PYGbe[/]dt@PYGbe[=]@PYGbe[-]x@PYGbe[/]tau@PYGbe[+]sigma@PYGbe[*]xi@PYGbe[/]tau@PYGbe[*]@PYGbe[*]@PYGbe[.]@PYGaw[5]
\end{Verbatim}

where \code{sigma} is in the same units as \code{x}. We note the following two facts:
\begin{itemize}
\item {} 
The noise term is independent between neurons. Thus, one cannot use this method to analyse
the response to frozen noise (where all neurons receive the same input noise). One would need
to use an external variable representing the input, updated by a user-defined operation.

\item {} 
The noise term is independent between equations. This can however be solved by the following
trick:

\begin{Verbatim}[commandchars=@\[\]]
dx/dt=-x/tau+sigmax*u/tau**.5 : volt
dy/dt=-y/tau+sigmay*u/tau**.5 : volt
u=xi : second**(-.5)
\end{Verbatim}

\end{itemize}
\indexii{differential equations}{non-autonomous}\indexii{differential equations}{time-dependent}\indexii{equations}{time-dependent}\indexii{equations}{non-autonomous}

\subsection{Non-autonomous equations}

The time variable \code{t} can be directly inserted into an equation string.
It is replaced at run time by the current value of the time variable for the relevant
neuron group, and also appears as a state variable of the neuron group.
\indexii{equations}{freezing}\indexii{differential equations}{freezing}

\subsection{Freezing}

External variables can be frozen by passing the keyword \code{freeze=True}
(default = \code{False}) at initialization of a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} object.
Then when the string defining the equations are compiled into Python functions
(method \code{compile\_functions()}),
the external variables are replaced by their float values (units are discarded).
This can result in a significant speed-up.

TODO: more on the implementation.
\indexii{equations}{compilation}\indexii{differential equations}{compilation}

\subsection{Compilation}

State updates can be compiled into Python code objects by passing the keyword
\code{compile=True} at initialization of a a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}.
Note that this is different from the method \code{compile\_functions()},
which compiles the equation for every variable into a Python function
(not the whole state update process).

When the \code{compile} keyword is set, the method \code{forward\_euler\_code()}
or \code{exponential\_euler\_code()} is called. It generates
a string containing the Python code for the update of all state variables (one time step),
then compiles it into Python code object. That compiled object is then called at every time step.
All external variables are frozen in the process (regardless of the value of the \code{freeze} keyword).
This results in a significant speed-up (although the exponential Euler code is not
quite optimised yet). Note that only Python code is generated, thus a
C compiler is not required.


\subsection{Working with equations}

\hyperlink{brian.Equations}{\code{Equations}} object can also be used outside simulations.
In the following, we suppose that an \hyperlink{brian.Equations}{\code{Equations}} object is defined as follows:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dx/dt=(y-x)/(10*ms) : volt]
@PYGad[dy/dt=-z/(5*ms) : volt]
@PYGad[z=2*(x+y) : volt]
@PYGad['''])
\end{Verbatim}
\indexii{equations}{applying}

\hypertarget{index-17}{}\subsubsection{Applying an equation}

The value of z can be calculated using the \code{apply()} method:

\begin{Verbatim}[commandchars=@\[\]]
z@PYGbe[=]eqs@PYGbe[.]apply(@PYGad[']@PYGad[z]@PYGad['],@PYGaX[dict](x@PYGbe[=]@PYGaw[3]@PYGbe[*]mV,y@PYGbe[=]@PYGaw[5]@PYGbe[*]mV))
\end{Verbatim}

The second argument is a dictionary containing the values of all dependent variables
(here the result is \code{8*mV}).
The right-hand side of differential equations can also be calculated in the same way:

\begin{Verbatim}[commandchars=@\[\]]
x@PYGbe[=]eqs@PYGbe[.]apply(@PYGad[']@PYGad[x]@PYGad['],@PYGaX[dict](x@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,y@PYGbe[=]@PYGaw[3]@PYGbe[*]mV))
y@PYGbe[=]eqs@PYGbe[.]apply(@PYGad[']@PYGad[y]@PYGad['],@PYGaX[dict](x@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,y@PYGbe[=]@PYGaw[3]@PYGbe[*]mV))
\end{Verbatim}

Note in the second case that only the values of the dynamic variables should be passed.
\indexii{equations}{fixed points}

\subsubsection{Calculating a fixed point}

A fixed point of the equations can be calculated as follows:

\begin{Verbatim}[commandchars=@\[\]]
fp@PYGbe[=]eqs@PYGbe[.]fixedpoint(x@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,y@PYGbe[=]@PYGaw[3]@PYGbe[*]mV)
\end{Verbatim}

where the optional keywords give the initial point (zero if not provided).
Internally, the function \code{optimize.fsolve} from the Scipy package is used to
find a zero of the set of differential equations (thus, convergence is not
guaranteed; in that case, the initial values are returned).
A dictionary with the values of the dynamic variables at the fixed point is returned.


\subsubsection{Issues}
\begin{itemize}
\item {} 
If the equations were previously frozen, then the units disappear from the equations
and unit consistency problems may arise.

\item {} 
\hyperlink{brian.Equations}{\code{Equations}} objects need to be ``prepared'' before use, as follows:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[.]prepare()
\end{Verbatim}

This is automatically called by the NeuronGroup initialiser.

\end{itemize}
\footnotetext[1]{
Note that this approach raises an issue when dX/dt=B. We currently (temporarily)
solve this problem by adding a small diagonal matrix to M to make it invertible.
}
For more detailed information, see the reference chapter.

\resetcurrentobjects


\chapter{The library}

A number of standard models is defined in the library folder. To use library elements, use the following syntax:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.module_name] @PYGay[import] @PYGbe[*]
\end{Verbatim}

For example, to import electrophysiology models:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.electrophysiology] @PYGay[import] @PYGbe[*]
\end{Verbatim}

\resetcurrentobjects


\section{Library models}


\subsection{Membrane equations}

Library models are defined using the \code{MembraneEquation} class. This is a subclass of
\hyperlink{brian.Equations}{\code{Equations}} which is defined by a capacitance C and a sum of currents. The following instruction:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(@PYGaw[200]@PYGbe[*]pF)
\end{Verbatim}

defines the equation C*dvm/dt=0*amp, with the membrane capacitance C=200 pF. The name of the membrane potential
variable can be changed as follows:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(@PYGaw[200]@PYGbe[*]pF,vm@PYGbe[=]@PYGad[']@PYGad[V]@PYGad['])
\end{Verbatim}

The main interest of this class is that one can use it to build models by adding currents to a membrane
equation. The \code{Current} class is a subclass of \hyperlink{brian.Equations}{\code{Equations}} which defines a current to be added
to a membrane equation. For example:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(@PYGaw[200]@PYGbe[*]pF)@PYGbe[+]Current(I@PYGbe[=]@PYGad[']@PYGad[(V0-vm)/R : amp]@PYGad['],current_name@PYGbe[=]@PYGad[']@PYGad[I]@PYGad['])
\end{Verbatim}

defines the same equation as:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dvm/dt=I/(200*pF) : volt]
@PYGad[I=(V0-vm)/R : amp]
@PYGad['''])
\end{Verbatim}

The keyword \code{current\_name} is optional if there is no ambiguity, i.e., if there is only one variable
or only one variable with amp units. As for standard equations, \code{Current} objects can be initialised with
a multiline string (several equations). By default, the convention for the current direction is the one for injected
current. For the ionic current convention, use the \code{IonicCurrent} class:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(@PYGaw[200]@PYGbe[*]pF)@PYGbe[+]IonicCurrent(I@PYGbe[=]@PYGad[']@PYGad[(vm-V0)/R : amp]@PYGad['])
\end{Verbatim}


\subsection{Integrate-and-Fire models}

A few standard Integrate-and-Fire models are implemented in the \code{IF} library module:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.IF] @PYGay[import] @PYGbe[*]
\end{Verbatim}

All these functions return \hyperlink{brian.Equations}{\code{Equations}} objects (more precisely, \code{MembraneEquation} objects).
\begin{itemize}
\item {} 
Leaky integrate-and-fire model (\code{dvm/dt=(El-vm)/tau : volt}):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]leaky_IF(tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,El@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV)
\end{Verbatim}

\item {} 
Perfect integrator (\code{dvm/dt=Im/tau : volt}):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]perfect_IF(tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

\item {} 
Quadratic integrate-and-fire model (\code{C*dvm/dt=a*(vm-El)*(vm-VT) : volt}):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]quadratic_IF(C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF,a@PYGbe[=]@PYGaw[10]@PYGbe[*]nS@PYGbe[/]mV,EL@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV,VT@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV)
\end{Verbatim}

\item {} 
Exponential integrate-and-fire model (\code{C*dvm/dt=gL*(EL-vm)+gL*DeltaT*exp((vm-VT)/DeltaT) :volt}):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]exp_IF(C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF,gL@PYGbe[=]@PYGaw[10]@PYGbe[*]nS,EL@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV,VT@PYGbe[=]@PYGbe[-]@PYGaw[55]@PYGbe[*]mV,DeltaT@PYGbe[=]@PYGaw[3]@PYGbe[*]mV)
\end{Verbatim}

\end{itemize}

In general, it is possible to define a neuron group with different parameter values for each neuron, by
passing strings at initialisation. For example, the following code defines leaky integrate-and-fire models
with heterogeneous resting potential values:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]leaky_IF(tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,El@PYGbe[=]@PYGad[']@PYGad[V0]@PYGad['])@PYGbe[+]Equations(@PYGad[']@PYGad[V0:volt]@PYGad['])
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,reset@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,threshold@PYGbe[=]@PYGaw[15]@PYGbe[*]mV)
\end{Verbatim}


\subsection{Two-dimensional IF models}

Integrate-and-fire models with two variables can display a very rich set of electrophysiological behaviours.
In Brian, two such models have been implemented: Izhikevich model and Brette-Gerstner adaptive exponential
integrate-and-fire model (also included in the \code{IF} module).
The equations are obtained in the same way as for one-dimensional models:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Izhikevich(a@PYGbe[=]@PYGaw[0.02]@PYGbe[/]ms,b@PYGbe[=]@PYGaw[0.2]@PYGbe[/]ms)
eqs@PYGbe[=]Brette_Gerstner(C@PYGbe[=]@PYGaw[281]@PYGbe[*]pF,gL@PYGbe[=]@PYGaw[30]@PYGbe[*]nS,EL@PYGbe[=]@PYGbe[-]@PYGaw[70.6]@PYGbe[*]mV,VT@PYGbe[=]@PYGbe[-]@PYGaw[50.4]@PYGbe[*]mV,DeltaT@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,tauw@PYGbe[=]@PYGaw[144]@PYGbe[*]ms,a@PYGbe[=]@PYGaw[4]@PYGbe[*]nS)
eqs@PYGbe[=]aEIF(C@PYGbe[=]@PYGaw[281]@PYGbe[*]pF,gL@PYGbe[=]@PYGaw[30]@PYGbe[*]nS,EL@PYGbe[=]@PYGbe[-]@PYGaw[70.6]@PYGbe[*]mV,VT@PYGbe[=]@PYGbe[-]@PYGaw[50.4]@PYGbe[*]mV,DeltaT@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,tauw@PYGbe[=]@PYGaw[144]@PYGbe[*]ms,a@PYGbe[=]@PYGaw[4]@PYGbe[*]nS) @PYGaD[# equivalent]
\end{Verbatim}

and two state variables are defined: \code{vm} (membrane potential) and \code{w} (adaptation variable).
The equivalent equations for Izhikevich model are:

\begin{Verbatim}[commandchars=@\[\]]
dvm/dt=(0.04/ms/mV)*vm**2+(5/ms)*vm+140*mV/ms-w : volt/second
dw/dt=a*(b*vm-w)                            : volt/second
\end{Verbatim}

and for Brette-Gerstner model:

\begin{Verbatim}[commandchars=@\[\]]
C*dvm/dt=gL*(EL-vm)+gL*DeltaT*exp((vm-VT)/DeltaT)-w :volt
dw/dt=(a*(vm-EL)-w)/tauw : amp
\end{Verbatim}

To simulate these models, one needs to specify a threshold value, and a good choice is
\code{VT+4*DeltaT}. The reset is particular in these models since it is bidimensional:
vm-\textgreater{}Vr and w-\textgreater{}w+b. A specific reset class has been implemented for this purpose:
\code{AdaptiveReset}, initialised with Vr and b. Thus, a typical construction of a group of
such models is:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Brette_Gerstner(C@PYGbe[=]@PYGaw[281]@PYGbe[*]pF,gL@PYGbe[=]@PYGaw[30]@PYGbe[*]nS,EL@PYGbe[=]@PYGbe[-]@PYGaw[70.6]@PYGbe[*]mV,VT@PYGbe[=]@PYGbe[-]@PYGaw[50.4]@PYGbe[*]mV,DeltaT@PYGbe[=]@PYGaw[2]@PYGbe[*]mV,tauw@PYGbe[=]@PYGaw[144]@PYGbe[*]ms,a@PYGbe[=]@PYGaw[4]@PYGbe[*]nS)
group@PYGbe[=]NeuronGroup(@PYGaw[100],model@PYGbe[=]eqs,threshold@PYGbe[=]@PYGbe[-]@PYGaw[43]@PYGbe[*]mV,reset@PYGbe[=]AdaptiveReset(Vr@PYGbe[=]@PYGbe[-]@PYGaw[70.6]@PYGbe[*]mvolt,b@PYGbe[=]@PYGaw[0.0805]@PYGbe[*]nA))
\end{Verbatim}


\subsection{Synapses}

A few simple synaptic models are implemented in the module \code{synapses}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.synapses] @PYGay[import] @PYGbe[*]
\end{Verbatim}

All the following functions need to be passed the name of the variable upon which the received spikes
will act, and the name of the variable representing the current or conductance.
The simplest one is the exponential synapse:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]exp_synapse(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[x]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,unit@PYGbe[=]amp,output@PYGbe[=]@PYGad[']@PYGad[x_current]@PYGad['])
\end{Verbatim}

It is equivalent to:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dx/dt=-x/tau : amp]
@PYGad[x_out=x]
@PYGad['''])
\end{Verbatim}

Here, \code{x} is the variable which receives the spikes and \code{x\_current} is the variable to be inserted in
the membrane equation (since it is a one-dimensional synaptic model, the variables are the same).
If the output variable name is not defined, then it will be automatically generated by adding the
suffix \code{\_out} to the input name.

Two other types of synapses are implemented. The alpha synapse (\code{x(t)=alpha*(t/tau)*exp(1-t/tau)}, where
\code{alpha} is a normalising factor) is defined with the same syntax by:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]alpha_synapse(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[x]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,unit@PYGbe[=]amp)
\end{Verbatim}

and the bi-exponential synapse is defined by (\code{x(t)=(tau2/(tau2-tau1))*(exp(-t/tau1)-exp(-t/tau2))},
up to a normalising factor):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]biexp_synapse(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[x]@PYGad['],tau1@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,tau2@PYGbe[=]@PYGaw[5]@PYGbe[*]ms,unit@PYGbe[=]amp)
\end{Verbatim}

For all types of synapses, the normalising factor is such that the maximum of x(t) is 1.
These functions can be used as in the following example:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF)@PYGbe[+]Current(@PYGad[']@PYGad[I=gl*(El-vm)+ge*(Ee-vm):amp]@PYGad['])
eqs@PYGbe[+]@PYGbe[=]alpha_synapse(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[ge_in]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms,unit@PYGbe[=]siemens,output@PYGbe[=]@PYGad[']@PYGad[ge]@PYGad['])
\end{Verbatim}

where alpha conductances have been inserted in the membrane equation.

One can directly insert synaptic currents with the functions \code{exp\_current}, \code{alpha\_current}
and \code{biexp\_current}:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF)@PYGbe[+]Current(@PYGad[']@PYGad[I=gl*(El-vm):amp]@PYGad['])@PYGbe[+]\
    alpha_current(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[ge]@PYGad['],tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

(the units is amp by default), or synaptic conductances with the functions \code{exp\_conductance}, \code{alpha\_conductance}
and \code{biexp\_conductance}:

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]MembraneEquation(C@PYGbe[=]@PYGaw[200]@PYGbe[*]pF)@PYGbe[+]Current(@PYGad[']@PYGad[I=gl*(El-vm):amp]@PYGad['])@PYGbe[+]\
    alpha_conductance(@PYGaX[input]@PYGbe[=]@PYGad[']@PYGad[ge]@PYGad['],E@PYGbe[=]@PYGaw[0]@PYGbe[*]mV,tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

where \code{E} is the reversal potential.


\subsection{Ionic currents}

A few standard ionic currents have implemented in the module \code{ionic\_currents}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.ionic_currents] @PYGay[import] @PYGbe[*]
\end{Verbatim}

When the current name is not specified,
a unique name is generated automatically. Models can be constructed by adding currents to a
\code{MembraneEquation}.
\begin{itemize}
\item {} 
Leak current (\code{gl*(El-vm)}):

\begin{Verbatim}[commandchars=@\[\]]
current@PYGbe[=]leak_current(gl@PYGbe[=]@PYGaw[10]@PYGbe[*]nS,El@PYGbe[=]@PYGbe[-]@PYGaw[70]@PYGbe[*]mV,current_name@PYGbe[=]@PYGad[']@PYGad[I]@PYGad['])
\end{Verbatim}

\item {} 
Hodgkin-Huxley K+ current:

\begin{Verbatim}[commandchars=@\[\]]
current=K_current_HH(gmax,EK,current_name='IK'):
\end{Verbatim}

\item {} 
Hodgkin-Huxley Na+ current:

\begin{Verbatim}[commandchars=@\[\]]
current=Na_current_HH(gmax,ENa,current_name='INa'):
\end{Verbatim}

\end{itemize}

\resetcurrentobjects


\section{Random processes}

To import the random processes library:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[brian.library.random_processes] @PYGay[import] @PYGbe[*]
\end{Verbatim}

For the moment, only the Ornstein-Uhlenbeck process has been included.
The function \code{OrnsteinUhlenbeck()} returns an \hyperlink{brian.Equations}{\code{Equations}} object. The following example
defines a membrane equation with an Ornstein-Uhlenbeck current \code{I} (= coloured noise):

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[']@PYGad[dv/dt=-v/tau+I/C : volt]@PYGad['])
eqs@PYGbe[+]@PYGbe[=]OrnsteinUhlenbeck(@PYGad[']@PYGad[I]@PYGad['],mu@PYGbe[=]@PYGaw[1]@PYGbe[*]nA,sigma@PYGbe[=]@PYGaw[2]@PYGbe[*]nA,tau@PYGbe[=]@PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

where \code{mu} is the mean of the current, \code{sigma} is the standard deviation and
\code{tau} is autocorrelation time constant.

\resetcurrentobjects


\section{Electrophysiology}

\resetcurrentobjects


\section{Extending the library}

For names, we try to follow the standard Python convention, that is, \code{function\_and\_variable\_names}
and \code{ClassNames}.

\resetcurrentobjects


\chapter{Advanced concepts}

\resetcurrentobjects
\index{parallel python}\index{clusters}

\hypertarget{index-62}{}\section{Parallel computing}


\hypertarget{brian.ppfunction}{}\begin{funcdesc}{ppfunction}{f}
Convenience wrapper for writing functions to use with parallelpython

The parallel python module \code{pp} allows you to write code that runs simultaneously
on multiple cores on a single machine, or multiple machines on a cluster. You can
download the module at \href{http://www.parallelpython.com/}{http://www.parallelpython.com/}

One annoying feature of \code{pp} is that you cannot use data values that are in the
global namespace as part of your code, only modules and functions. This means that
you could not execute a function with the code \code{3*mV} for example, because \code{mV}
is a data value in the \code{brian} namespace. Instead you would have to import
the \code{brian} module and write \code{3*brian.mV} which is annoying in long chunks
of code. This decorator simply generates a new version of your code with every
name \code{x} from the \code{brian} namespace replaced by \code{brian.x}. As part of this
process, the rewritten code has to be saved to a file (because of how \code{pp} works)
and this file is named according to the scheme
\code{basename\_funcname\_parallelpythonised.py}, where \code{basename} is the current
module name and \code{funcname} is the name of the function being rewritten.

\textbf{Example}

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]ppfunction]
@PYGay[def] @PYGaK[testf]():
    @PYGay[return] @PYGaw[3]@PYGbe[*]mV
\end{Verbatim}
\end{funcdesc}

\resetcurrentobjects
\index{efficient code}

\hypertarget{index-3}{}\section{How to write efficient Brian code}

There are a few keys to writing fast and efficient Brian code. The
first is to use Brian itself efficiently. The second is to write
good vectorised code, which is using Python and NumPy efficiently.


\subsection{Brian specifics}

You can switch off Brian's entire unit checking module
by including the line:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[brian_no_units]
\end{Verbatim}

before importing Brian itself. Good practice is to leave unit checking
on most of the time when developing and debugging a model, but
switching it off for long runs once the basic model is stable.

Another way to speed up code is to store references to arrays rather
than extracting them from Brian objects each time you need them. For
example, if you know the custom reset object in the code above is
only ever applied to a group \code{custom\_group} say, then you could
do something like this:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[myreset](P, spikes):
        custom_group_V_@lb[]spikes@rb[] @PYGbe[=] @PYGaw[0]@PYGbe[*]mV
        custom_group_Vt_@lb[]spikes@rb[] @PYGbe[=] @PYGaw[2]@PYGbe[*]mV

custom_group @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
custom_group_V_ @PYGbe[=] custom_group@PYGbe[.]V_
custom_group_Vt_ @PYGbe[=] custom_group@PYGbe[.]Vt_
\end{Verbatim}

In this case, the speed increase will be quite small, and probably
not worth doing because it makes it less readable, but in more
complicated examples where you repeatedly refer to \code{custom\_group.V\_}
it could add up.
\indexii{efficient code}{vectorisation}\index{vectorisation}\index{speed!vectorisation}

\subsection{Vectorisation}

Python is a fast language, but each line of Python code has an
associated overhead attached to it. Sometimes you can get considerable
increases in speed by writing a vectorised version of it. A good guide
to this in general is the \href{http://www.scipy.org/PerformancePython}{Performance Python}
page. Here we will do a single worked example in Brian.

Suppose you wanted to multiplicatively depress the connection
strengths every time step by some amount, you might do something like
this:

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(G1, G2, @PYGad[']@PYGad[V]@PYGad['], structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
@PYGbe[.]@PYGbe[.]@PYGbe[.]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[end]@PYGad['])
@PYGay[def] @PYGaK[depress_C]():
        @PYGay[for] i @PYGan[in] @PYGaX[range](@PYGaX[len](G1)):
                @PYGay[for] j @PYGan[in] @PYGaX[range](@PYGaX[len](G2)):
                        C@lb[]i,j@rb[] @PYGbe[=] C@lb[]i,j@rb[]@PYGbe[*]depression_factor
\end{Verbatim}

This will work, but it will be very, very slow.

The first thing to note is that the Python expression \code{range(N)}
actually constructs a list \code{{[}0,1,2,...,N-1{]}} each time it is called,
which is not really necessary if you are only iterating over the list.
Instead, use the \code{xrange} iterator which doesn't construct the list
explicitly:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[for] i @PYGan[in] @PYGaX[xrange](@PYGaX[len](G1)):
        @PYGay[for] j @PYGan[in] @PYGaX[xrange](@PYGaX[len](G2)):
                C@lb[]i,j@rb[] @PYGbe[=] C@lb[]i,j@rb[]@PYGbe[*]depression_factor
\end{Verbatim}

The next thing to note is that when you call C{[}i,j{]} you are doing an
operation on the \hyperlink{brian.Connection}{\code{Connection}} object, not directly on the underlying
matrix. Instead, do something like this:

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(G1, G2, @PYGad[']@PYGad[V]@PYGad['], structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
C_matrix @PYGbe[=] asarray(C@PYGbe[.]W)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[end]@PYGad['])
@PYGay[def] @PYGaK[depress_C]():
        @PYGay[for] i @PYGan[in] @PYGaX[xrange](@PYGaX[len](G1)):
                @PYGay[for] j @PYGan[in] @PYGaX[xrange](@PYGaX[len](G2)):
                        C_matrix@lb[]i,j@rb[] @PYGbe[*]@PYGbe[=] depression_factor
\end{Verbatim}

What's going on here? First of all, \code{C.W} refers to the \code{ConnectionMatrix}
object, which is a 2D NumPy array with some extra stuff - we don't need the extra
stuff so we convert it to a straight NumPy array \code{asarray(C.W)}. We also store
a copy of this as the variable \code{C\_matrix} so we don't need to do this every
time step. The other thing we do is to use the \code{*=} operator instead of the \code{*}
operator.

The most important step of all though is to vectorise the entire operation. You
don't need to loop over \code{i} and \code{j} at all, you can manipulate the array
object with a single NumPy expression:

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(G1, G2, @PYGad[']@PYGad[V]@PYGad['], structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
C_matrix @PYGbe[=] asarray(C@PYGbe[.]W)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[end]@PYGad['])
@PYGay[def] @PYGaK[depress_C]():
        C_matrix @PYGbe[*]@PYGbe[=] depression_factor
\end{Verbatim}

This final version will probably be hundreds if not thousands of times faster
than the original. It's usually possible to work out a way using NumPy
expressions only to do whatever you want in a vectorised way, but in some
very rare instances it might be necessary to have a loop. In this case, if
this loop is slowing your code down, you might want to try writing that
loop in inline C++ using the \href{http://www.scipy.org/Weave}{SciPy Weave}
package. See the documentation at that link for more details, but as an
example we could rewrite the code above using inline C++ as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[from] @PYGaV[scipy] @PYGay[import] weave
@PYGbe[.]@PYGbe[.]@PYGbe[.]
C @PYGbe[=] Connection(G1, G2, @PYGad[']@PYGad[V]@PYGad['], structure@PYGbe[=]@PYGad[']@PYGad[dense]@PYGad['])
C_matrix @PYGbe[=] asarray(C@PYGbe[.]W)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[end]@PYGad['])
@PYGay[def] @PYGaK[depress_C]():
        n @PYGbe[=] @PYGaX[len](G1)
        m @PYGbe[=] @PYGaX[len](G2)
        code @PYGbe[=] @PYGad[''']
@PYGad[                for(int i=0;i<n;i++)]
@PYGad[                        for(int j=0;j<m;j++)]
@PYGad[                                C_matrix(i,j) *= depression_factor]
@PYGad[                ]@PYGad[''']
        weave@PYGbe[.]inline(code,
                @lb[]@PYGad[']@PYGad[C_matrix]@PYGad['], @PYGad[']@PYGad[n]@PYGad['], @PYGad[']@PYGad[m]@PYGad['], @PYGad[']@PYGad[depression_factor]@PYGad[']@rb[],
                type_converters@PYGbe[=]weave@PYGbe[.]converters@PYGbe[.]blitz,
                compiler@PYGbe[=]@PYGad[']@PYGad[gcc]@PYGad['],
                extra_compile_args@PYGbe[=]@lb[]@PYGad[']@PYGad[-O3]@PYGad[']@rb[])
\end{Verbatim}

The first time you run this it will be slower because it compiles the
C++ code and stores a copy, but the second time will be much faster as
it just loads the saved copy. The way it works is that Weave converts
the listed Python and NumPy variables (\code{C\_matrix}, \code{n}, \code{m}
and \code{depression\_factor}) into C++ compatible data types. \code{n} and
\code{m} are turned into \code{int``s, ``depression\_factor} is turned into
a \code{double}, and \code{C\_matrix} is turned into a Weave
\code{Array} class. The only thing you need to know about this is that
elements of a Weave array are referenced with parentheses rather than
brackets, i.e. \code{C\_matrix(i,j)} rather than \code{C\_matrix{[}i,j{]}}. In
this example, I have used the \code{gcc} compiler and added the optimisation
flag \code{-O3} for maximum optimisations. Again, in this case it's much
simpler to just use the \code{C\_matrix *= depression\_factor} NumPy expression,
but in some cases using inline C++ might be necessary, and as you can see
above, it's very easy to do this with Weave, and the C++ code for a
snippet like this is often almost as simple as the Python code would be.

\resetcurrentobjects
\index{multiple files}\indexii{multiple files}{magic functions}

\hypertarget{projects-with-multiple-files}{}\section{Projects with multiple files or functions}

Brian works with the minimal hassle if the whole of your code is in a
single Python module (\code{.py} file). This is fine when learning Brian
or for quick projects, but for larger, more realistic projects with
the source code separated into multiple files, there are some small
issues you need to be aware of. These issues essentially revolve
around the use of the `'magic'' functions \hyperlink{brian.run}{\code{run()}}, etc. The way
these functions work is to look for objects of the required type that
have been instantiated (created) in the same `'execution frame'' as
the \hyperlink{brian.run}{\code{run()}} function. In a small script, that is normally just
any objects that have been defined in that script. However, if you
define objects in a different module, or in a function, then the
magic functions won't be able to find them.

There are three main approaches then to splitting code over multiple
files (or functions).
\indexii{multiple files}{network}

\hypertarget{index-101}{}\subsection{Use the \texttt{Network} object explicitly}

The magic \hyperlink{brian.run}{\code{run()}} function works by creating a \hyperlink{brian.Network}{\code{Network}}
object automatically, and then running that network. Instead of doing
this automatically, you can create your own \hyperlink{brian.Network}{\code{Network}} object.
Rather than writing something like:

\begin{Verbatim}[commandchars=@\[\]]
group1 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
group2 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
C @PYGbe[=] Connection(group1,group2)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

You do this:

\begin{Verbatim}[commandchars=@\[\]]
group1 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
group2 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
C @PYGbe[=] Connection(group1, group2)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
net @PYGbe[=] Network(group1, group2, C)
net@PYGbe[.]run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

In other words, you explicitly say which objects are in your network.
Note that any \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, \hyperlink{brian.Connection}{\code{Connection}}, \code{Monitor} or
function decorated with \hyperlink{brian.network_operation}{\code{network\_operation()}} should be included in the
\hyperlink{brian.Network}{\code{Network}}. See the documentation for \hyperlink{brian.Network}{\code{Network}} for more details.

This is the preferred solution for almost all cases. You may want to use either
of the following two solutions if you think your code may be used by someone
else, or if you want to make it into an extension to Brian.
\indexii{extending brian}{magic functions}\indexii{extending brian}{magic\_return}\indexii{extending brian}{magic\_register}\indexii{multiple files}{magic\_return}\indexii{multiple files}{magic\_register}

\subsection{Use the \texttt{magic\_return()} decorator or \texttt{magic\_register()} function}

The \hyperlink{brian.magic_return}{\code{magic\_return()}} decorator is used as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[f]():
        @PYGbe[.]@PYGbe[.]@PYGbe[.]
        @PYGay[return] obj
\end{Verbatim}

Any object returned by a function decorated by \hyperlink{brian.magic_return}{\code{magic\_return()}} will be
considered to have been instantiated in the execution frame that called the
function. In other words, the magic functions will find that object even
though it was really instantiated in a different execution frame.

In more complicated scenarios, you may want to use the \hyperlink{brian.magic_register}{\code{magic\_register()}}
function. For example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f]():
        @PYGbe[.]@PYGbe[.]@PYGbe[.]
        magic_register(obj1, obj2)
        @PYGay[return] (obj1, obj2)
\end{Verbatim}

This does the same thing as \hyperlink{brian.magic_return}{\code{magic\_return()}} but can be used with
multiple objects. Also, you can specify a \code{level} (see documentation on
\hyperlink{brian.magic_register}{\code{magic\_register()}} for more details).
\indexii{extending brian}{derived classes}\indexii{multiple files}{derived classes}

\subsection{Use derived classes}

Rather than writing a function which returns an object, you could instead
write a derived class of the object type. So, suppose you wanted to have an
object that emitted N equally spaced spikes, with an interval dt between
them, you could use the \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} class as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[equally_spaced_spike_group](N, dt):
        spikes @PYGbe[=] @lb[](@PYGaw[0],i@PYGbe[*]dt) @PYGay[for] i @PYGan[in] @PYGaX[range](N)@rb[]
        @PYGay[return] SpikeGeneratorGroup(spikes)
\end{Verbatim}

Or alternatively, you could derive a class from \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}
as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[class] @PYGaN[EquallySpacedSpikeGroup](SpikeGeneratorGroup):
        @PYGay[def] @PYGaK[__init__](@PYGaA[self], N, t):
                spikes @PYGbe[=] @lb[](@PYGaw[0],i@PYGbe[*]dt) @PYGay[for] i @PYGan[in] @PYGaX[range](N)@rb[]
                SpikeGeneratorGroup@PYGbe[.]__init__(@PYGaA[self], spikes)
\end{Verbatim}

You would use these objects in the following ways:

\begin{Verbatim}[commandchars=@\[\]]
obj1 @PYGbe[=] equally_spaced_spike_group(@PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
obj2 @PYGbe[=] EquallySpacedSpikeGroup(@PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

For simple examples like the one above, there's no particular benefit to
using derived classes, but using derived classes allows you to add
methods to your derived class for example, which might be useful. For
more experienced Python programmers, or those who are thinking about
making their code into an extension for Brian, this is probably the
preferred approach.
\indexii{extending brian}{contained objects protocol}
Finally, it may be useful to note that there is a protocol for one object
to `contain' other objects. That is, suppose you want to have an object
that can be treated as a simple \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} by the person using it,
but actually instantiates several objects (perhaps internal \hyperlink{brian.Connection}{\code{Connection}}
objects). These objects need to be added to the \hyperlink{brian.Network}{\code{Network}} object
in order for them to be run with the simulation, but the user shouldn't need
to have to know about them. To this end, for any object added to a
\hyperlink{brian.Network}{\code{Network}}, if it has an attribute \code{contained\_objects}, then any
objects in that container will also be added to the network.

\resetcurrentobjects


\section{Parameters}

Brian includes a simple tool for keeping track of parameters. If you only need
something simple, then a dict or an empty class could be used. The point of the
parameters class is that allows you to define a cascade of computed parameters
that depend on the values of other parameters, so that changing one will
automatically update the others. See the synfire chain example
\code{examples/sfc.py} for a demonstration of how it can be used.


\hypertarget{brian.Parameters}{}\begin{classdesc}{Parameters}{**kwds}
A storage class for keeping track of parameters

Example usage:

\begin{Verbatim}[commandchars=@\[\]]
p @PYGbe[=] Parameters(
    a @PYGbe[=] @PYGaw[5],
    b @PYGbe[=] @PYGaw[6],
    computed_parameters @PYGbe[=] @PYGad[''']
@PYGad[    c = a + b]
@PYGad[    ]@PYGad['''])
@PYGay[print] p@PYGbe[.]c
p@PYGbe[.]a @PYGbe[=] @PYGaw[1]
@PYGay[print] p@PYGbe[.]c
\end{Verbatim}

The first \code{print} statement will give 11, the second gives 7.

Details:

Call as:

\begin{Verbatim}[commandchars=@\[\]]
p @PYGbe[=] Parameters(@PYGbe[.]@PYGbe[.]@PYGbe[.])
\end{Verbatim}

Where the \code{...} consists of a list of keyword / value pairs (like a \code{dict}).
Keywords must not start with the underscore \code{\_} character. Any
keyword that starts with \code{computed\_} should be a string of valid Python statements
that compute new values based on the given ones. Whenever a non-computed value is
changed, the computed parameters are recomputed, in alphabetical order of their
keyword names (so \code{computed\_a} is computed before \code{computed\_b} for example).
Non-computed values can be accessed and set via \code{p.x}, \code{p.x=1} for example, whereas
computed values can only be accessed and not set. New parameters can be added
after the \hyperlink{brian.Parameters}{\code{Parameters}} object is created, including new \code{computed\_*} parameters. You
can `derive' a new parameters object from a given one as follows:

\begin{Verbatim}[commandchars=@\[\]]
p1 @PYGbe[=] Parameters(x@PYGbe[=]@PYGaw[1])
p2 @PYGbe[=] Parameters(y@PYGbe[=]@PYGaw[2],@PYGbe[*]@PYGbe[*]p1)
@PYGay[print] p2@PYGbe[.]x
\end{Verbatim}

Note that changing the value of \code{x} in \code{p2} will not change the value of \code{x} in \code{p1} (this
is a copy operation).
\end{classdesc}

\resetcurrentobjects
\index{preferences}

\hypertarget{index-89}{}\section{Preferences}


\subsection{Functions}

Setting and getting global preferences is done with the following
functions:


\hypertarget{brian.set_global_preferences}{}\begin{funcdesc}{set\_global\_preferences}{**kwds}
Set global preferences for Brian

Usage:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaJ[``]set_global_preferences(@PYGbe[.]@PYGbe[.]@PYGbe[.])@PYGaJ[``]
\end{Verbatim}

where ... is a list of keyword assignments.
\end{funcdesc}


\hypertarget{brian.get_global_preference}{}\begin{funcdesc}{get\_global\_preference}{k}
Get the value of the named global preference
\end{funcdesc}

The currently known global preferences are:


\subsection{Global preferences for Brian}

The following global preferences have been defined:
\begin{description}
\item[\code{defaultclock = Clock(dt=0.1*msecond)}]
The default clock to use if none is provided or defined
in any enclosing scope.

\item[\code{useweave\_linear\_diffeq = False}]
Whether to use weave C++ acceleration for the solution
of linear differential equations. Note that on some
platforms, typically older ones, this is faster and on
some platforms, typically new ones, this is actually
slower.

\item[\code{useweave = False}]
Defines whether or not functions should use inlined compiled
C code where defined. Requires a compatible C++ compiler.
The \code{gcc} and \code{g++} compilers are probably the easiest
option (use Cygwin on Windows machines). See also the
\code{weavecompiler} global preference.

\item[\code{weavecompiler = gcc}]
Defines the compiler to use for weave compilation. On Windows machines, installing
Cygwin is the easiest way to get access to the gcc compiler.

\item[\code{magic\_useframes = True}]
Defines whether or not the magic functions should search
for objects defined only in the calling frame or if they
should find all objects defined in any frame. This should
be set to \code{False} if you are using Brian from an interactive
shell like IDLE or IPython where each command has its own
frame, otherwise set it to \code{True}.

\end{description}

\resetcurrentobjects
\index{log}\index{logging}

\hypertarget{index-71}{}\section{Logging}

Brian uses the standard Python \code{logging} package to generate information
and warnings. All messages are sent to the logger named \code{brian} or loggers
derived from this one, and you can use the standard logging functions to
set options, write the logs to files, etc. Alternatively, Brian has four
simple functions to set the level of the displayed log (see below). There
are four different levels for log messages, in decreasing order of severity
they are ERROR, WARN, INFO and DEBUG. By default, Brian displays only the
WARN and ERROR level messages. Some useful information is at the INFO level,
so if you are having problems with your program, setting the level to INFO
may help.


\hypertarget{brian.log_level_error}{}\begin{funcdesc}{log\_level\_error}{}
Shows log messages only of level ERROR or higher.
\end{funcdesc}


\hypertarget{brian.log_level_warn}{}\begin{funcdesc}{log\_level\_warn}{}
Shows log messages only of level WARNING or higher (including ERROR level).
\end{funcdesc}


\hypertarget{brian.log_level_info}{}\begin{funcdesc}{log\_level\_info}{}
Shows log messages only of level INFO or higher (including WARNING and ERROR levels).
\end{funcdesc}


\hypertarget{brian.log_level_debug}{}\begin{funcdesc}{log\_level\_debug}{}
Shows log messages only of level DEBUG or higher (including INFO, WARNING and ERROR levels).
\end{funcdesc}

\resetcurrentobjects


\chapter{Extending Brian}

TODO: Description of how to extend Brian, add new model types, and maybe at
some point how to upload them to a database, share with others, etc.

For the moment, see the documentation on \hyperlink{projects-with-multiple-files}{\emph{Projects with multiple files or functions}}.

\resetcurrentobjects


\chapter{Reference}

For an overview of Brian, see the \hyperlink{user-manual}{\emph{User manual}} section.

\resetcurrentobjects
\index{units}\index{quantity}\index{dimensions!units}

\hypertarget{index-95}{}\section{Units system}


\hypertarget{brian.have_same_dimensions}{}\begin{funcdesc}{have\_same\_dimensions}{obj1, obj2}
Tests if two scalar values have the same dimensions, returns a \code{bool}.

Note that the syntax may change in later releases of Brian, with tighter
integration of scalar and array valued quantities.
\end{funcdesc}


\hypertarget{brian.is_dimensionless}{}\begin{funcdesc}{is\_dimensionless}{obj}
Tests if a scalar value is dimensionless or not, returns a \code{bool}.

Note that the syntax may change in later releases of Brian, with tighter
integration of scalar and array valued quantities.
\end{funcdesc}
\index{dimensions!inconsistent}\index{units!inconsistent}

\hypertarget{brian.DimensionMismatchError}{}\begin{excdesc}{DimensionMismatchError}
Exception class for attempted operations with inconsistent dimensions

For example, \code{3*mvolt + 2*amp} raises this exception. The purpose of this
class is to help catch errors based on incorrect units. The exception will
print a representation of the dimensions of the two inconsistent objects
that were operated on. If you want to check for inconsistent units in your
code, do something like:

\begin{Verbatim}[commandchars=@\[\]]
try:
    ...
    your code here
    ...
except DimensionMismatchError, inst:
    ...
    cleanup code here, e.g.
    print "Found dimension mismatch, details:", inst
    ...
\end{Verbatim}
\end{excdesc}


\hypertarget{brian.check_units}{}\begin{funcdesc}{check\_units}{**au}
Decorator to check units of arguments passed to a function

\textbf{Sample usage:}

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]check_units](I@PYGbe[=]amp,R@PYGbe[=]ohm,wibble@PYGbe[=]metre,result@PYGbe[=]volt)
@PYGay[def] @PYGaK[getvoltage](I,R,@PYGbe[*]@PYGbe[*]k):
    @PYGay[return] I@PYGbe[*]R
\end{Verbatim}

You don't have to check the units of every variable in the function, and
you can define what the units should be for variables that aren't
explicitly named in the definition of the function. For example, the code
above checks that the variable wibble should be a length, so writing:

\begin{Verbatim}[commandchars=@\[\]]
getvoltage(@PYGaw[1]@PYGbe[*]amp,@PYGaw[1]@PYGbe[*]ohm,wibble@PYGbe[=]@PYGaw[1])
\end{Verbatim}

would fail, but:

\begin{Verbatim}[commandchars=@\[\]]
getvoltage(@PYGaw[1]@PYGbe[*]amp,@PYGaw[1]@PYGbe[*]ohm,wibble@PYGbe[=]@PYGaw[1]@PYGbe[*]metre)
\end{Verbatim}

would pass.
String arguments are not checked (e.g. \code{getvoltage(wibble='hello')} would pass).

The special name \code{result} is for the return value of the function.

An error in the input value raises a \hyperlink{brian.DimensionMismatchError}{\code{DimensionMismatchError}}, and an error
in the return value raises an \code{AssertionError} (because it is a code
problem rather than a value problem).

\textbf{Notes}

This decorator will destroy the signature of the original function, and
replace it with the signature \code{(*args, **kwds)}. Other decorators will
do the same thing, and this decorator critically needs to know the signature
of the function it is acting on, so it is important that it is the first
decorator to act on a function. It cannot be used in combination with another
decorator that also needs to know the signature of the function.
\end{funcdesc}

Typically, you shouldn't need to use any details about the following
two classes, and their implementations are subject to change in
future releases of Brian.


\hypertarget{brian.Quantity}{}\begin{classdesc}{Quantity}{value}
A number with an associated physical dimension.

In most cases, it is not necessary to create a \hyperlink{brian.Quantity}{\code{Quantity}} object
by hand, instead use the constant unit names \code{second}, \code{kilogram},
etc. The details of how \hyperlink{brian.Quantity}{\code{Quantity}} objects work is subject to
change in future releases of Brian, as we plan to reimplement it
in a more efficient manner, more tightly integrated with numpy. The
following can be safely used:
\begin{itemize}
\item {} 
\hyperlink{brian.Quantity}{\code{Quantity}}, this name will not change, and the usage
\code{isinstance(x,Quantity)} should be safe.

\item {} 
The standard unit objects, \code{second}, \code{kilogram}, etc.
documented in the main documentation will not be subject
to change (as they are based on SI standardisation).

\item {} 
Scalar arithmetic will work with future implementations.

\end{itemize}
\end{classdesc}


\hypertarget{brian.Unit}{}\begin{classdesc}{Unit}{value}
A physical unit

Normally, you do not need to worry about the implementation of
units. They are derived from the \hyperlink{brian.Quantity}{\code{Quantity}} object with
some additional information (name and string representation).
You can define new units which will be used when generating
string representations of quantities simply by doing an
arithmetical operation with only units, for example:

\begin{Verbatim}[commandchars=@\[\]]
Nm @PYGbe[=] newton @PYGbe[*] metre
\end{Verbatim}

Note that operations with units are slower than operations with
\hyperlink{brian.Quantity}{\code{Quantity}} objects, so for efficiency if you do not need the
extra information that a \hyperlink{brian.Unit}{\code{Unit}} object carries around, write
\code{1*second} in preference to \code{second}.
\end{classdesc}
\indexii{array}{units}\indexii{array}{quantity}
\resetcurrentobjects
\index{clock}

\hypertarget{index-63}{}\section{Clocks}
\index{clock!default clock}\index{default clock}
Many Brian objects store a clock object (always passed in the
initialiser with the keyword \code{clock=}...). If no clock is specified,
the program uses the global default clock. When Brian is initially
imported, this is the object \hyperlink{brian.defaultclock}{\code{defaultclock}}, and it has a default
time step of 0.1ms. In a simple script, you can override this by
writing (for example):

\begin{Verbatim}[commandchars=@\[\]]
defaultclock@PYGbe[.]dt @PYGbe[=] @PYGaw[1]@PYGbe[*]ms
\end{Verbatim}

However, there are other ways to access or redefine the default
clock (see functions below).
\index{clock!multiple clocks}\index{multiple clocks}
You may wish to use multiple clocks in your program. In this case,
for each object which requires one, you have to pass a copy of its
\hyperlink{brian.Clock}{\code{Clock}} object. The network run function automatically handles objects
with different clocks, updating them all at the appropriate time
according to their time steps (value of \hyperlink{brian.Clock.dt}{\code{dt}}).

Multiple clocks can be useful, for example, for defining a simulation
that runs with a very small \code{dt}, but with some computationally
expensive operation running at a lower frequency.


\subsection{The \texttt{Clock} class}


\hypertarget{brian.Clock}{}\begin{classdesc}{Clock}{dt=0.1 ms, t=0.0 s, makedefaultclock=False}
An object that holds the simulation time and the time step.

Initialisation arguments:
\begin{description}
\item[\code{dt}]
The time step of the simulation.

\item[\code{t}]
The current time of the clock.

\item[\code{makedefaultclock}]
Set to \code{True} to make this clock the default clock.

\end{description}

\textbf{Methods}


\hypertarget{brian.Clock.reinit}{}\begin{methoddesc}{reinit}{{[}t=0*second{]}}
Reinitialises the clock time to zero (or to your
specified time).
\end{methoddesc}

\textbf{Attributes}


\hypertarget{brian.Clock.t}{}\begin{memberdesc}{t}
\hypertarget{brian.Clock.dt}{}\memberline{dt}
Current time and time step with units.
\end{memberdesc}

\textbf{Advanced}

\emph{Attributes}


\hypertarget{brian.Clock.end}{}\begin{memberdesc}{end}
The time at which the current simulation will end,
set by the \code{Network.run()} method.
\end{memberdesc}

\emph{Methods}


\hypertarget{brian.Clock.tick}{}\begin{methoddesc}{tick}{}
Advances the clock by one time step.
\end{methoddesc}


\hypertarget{brian.Clock.set_t}{}\begin{methoddesc}{set\_t}{t}
\hypertarget{brian.Clock.set_dt}{}\methodline{set\_dt}{dt}
\hypertarget{brian.Clock.set_end}{}\methodline{set\_end}{end}
Set the various parameters.
\end{methoddesc}


\hypertarget{brian.Clock.get_duration}{}\begin{methoddesc}{get\_duration}{}
The time until the current simulation ends.
\end{methoddesc}


\hypertarget{brian.Clock.set_duration}{}\begin{methoddesc}{set\_duration}{duration}
Set the time until the current simulation ends.
\end{methoddesc}


\hypertarget{brian.Clock.still_running}{}\begin{methoddesc}{still\_running}{}
Returns a \code{bool} to indicate whether the current
simulation is still running.
\end{methoddesc}

For reasons of efficiency, we recommend using the methods
\hyperlink{brian.Clock.tick}{\code{tick()}}, \hyperlink{brian.Clock.set_duration}{\code{set\_duration()}} and \hyperlink{brian.Clock.still_running}{\code{still\_running()}}
(which bypass unit checking internally).
\end{classdesc}
\index{clock!default clock}\index{default clock}

\subsection{The default clock}


\hypertarget{brian.defaultclock}{}\begin{datadesc}{defaultclock}
The default clock object

Note that this is only the default clock object if you haven't
redefined it with the \hyperlink{brian.define_default_clock}{\code{define\_default\_clock()}} function or the
\code{makedefaultclock=True} option of a \hyperlink{brian.Clock}{\code{Clock}} object. A safe way to
get hold of the default clock is to use the functions:
\begin{itemize}
\item {} 
\hyperlink{brian.get_default_clock}{\code{get\_default\_clock()}}

\item {} 
\hyperlink{brian.reinit_default_clock}{\code{reinit\_default\_clock()}}

\end{itemize}

However, it is suitable for short scripts, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
defaultclock@PYGbe[.]dt @PYGbe[=] @PYGaw[1]@PYGbe[*]ms
@PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}
\end{datadesc}


\hypertarget{brian.define_default_clock}{}\begin{funcdesc}{define\_default\_clock}{**kwds}
Create a new default clock

Uses the keywords of the \hyperlink{brian.Clock}{\code{Clock}} initialiser.

Sample usage:

\begin{Verbatim}[commandchars=@\[\]]
define_default_clock(dt@PYGbe[=]@PYGaw[1]@PYGbe[*]ms)
\end{Verbatim}
\end{funcdesc}


\hypertarget{brian.reinit_default_clock}{}\begin{funcdesc}{reinit\_default\_clock}{t=0.0 s}
Reinitialise the default clock (to zero or a specified time)
\end{funcdesc}


\hypertarget{brian.get_default_clock}{}\begin{funcdesc}{get\_default\_clock}{}
Returns the default clock object.
\end{funcdesc}

\resetcurrentobjects
\indexii{neuron}{model}\indexii{neuron}{equations}\indexii{model}{equations}\indexii{neuron}{group}

\hypertarget{index-73}{}\section{Neuron models and groups}
\index{equations}

\hypertarget{index-74}{}\subsection{The \texttt{Equations} object}


\hypertarget{brian.Equations}{}\begin{classdesc}{Equations}{expr='', level=0, **kwds}
Container that stores equations from which models can be created

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
Equations(expr@lb[],level=0@lb[],keywords...@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{expr}]
An expression, which can each be a string representing equations,
an \hyperlink{brian.Equations}{\code{Equations}} objects, or a list of strings and \hyperlink{brian.Equations}{\code{Equations}} objects.
See below for details of the string format.

\item[\code{level}]
Indicates how many levels back in the stack the namespace for string
equations is found, so that e.g. \code{level=0} looks in the
namespace of the function where the \hyperlink{brian.Equations}{\code{Equations}} object was created,
\code{level=1} would look in the namespace of the function that called the
function where the \hyperlink{brian.Equations}{\code{Equations}} object was created, etc.
Normally you can just leave this out.

\item[\code{keywords}]
Any sequence of keyword pairs \code{key=value} where the string \code{key}
in the string equations will be replaced with \code{value} which can
be either a string, value or \code{None}, in the latter case a unique
name will be generated automatically (but it won't be pretty).

\end{description}

Systems of equations can be defined by passing lists of \hyperlink{brian.Equations}{\code{Equations}} to a
new \hyperlink{brian.Equations}{\code{Equations}} object, or by adding \hyperlink{brian.Equations}{\code{Equations}} objects together (the usage
is similar to that of a Python \code{list}).

\textbf{String equations}

String equations can be of any of the following forms:
\begin{enumerate}
\item {} 
\code{dx/dt = f : unit} (differential equation)

\item {} 
\code{x = f : unit} (equation)

\item {} 
\code{x = y} (alias)

\item {} 
\code{x : unit} (parameter)

\end{enumerate}

Here each of \code{x} and \code{y} can be any valid Python variable name,
\code{f} can be any valid Python expression, and \code{unit} should be the
unit of the corresponding \code{x}. You can also include multi-line
expressions by appending a \code{\textbackslash{}} character at the end of each line
which is continued on the next line (following the Python standard),
or comments by including a \code{\#} symbol.

These forms mean:
\begin{description}
\item[\emph{Differential equation}]
A differential equation with variable \code{x} which has physical
units \code{unit}. The variable \code{x} will become one of the state
variables of the model.

\item[\emph{Equation}]
An equation defining the meaning of \code{x} can be used for building
systems of complicated differential equations.

\item[\emph{Alias}]
The variable \code{x} becomes equivalent to the variable \code{y}, useful
for connecting two separate systems of equations together.

\item[\emph{Parameter}]
The variable \code{x} will have physical units \code{unit} and will be
one of the state variables of the model (but will not evolve
dynamically, instead it should be set by the user).

\end{description}
\index{xi}\indexii{xi}{noise}\index{white noise}\index{gaussian noise}\index{noise}\index{noise!gaussian}\index{noise!white}
\textbf{Noise}

String equations can also use the reserved term \code{xi} for a
Gaussian white noise with mean 0 and variance 1.

\textbf{Example usage}

\begin{Verbatim}[commandchars=@\[\]]
eqs@PYGbe[=]Equations(@PYGad[''']
@PYGad[dv/dt=(u-v)/tau : volt]
@PYGad[u=3*v : volt]
@PYGad[w=v]
@PYGad['''])
\end{Verbatim}
\end{classdesc}

For information on integration methods, and the \code{StateUpdater}
class, see \hyperlink{integration}{\emph{Integration}}.
\index{model}

\subsection{The \texttt{Model} object}


\hypertarget{brian.Model}{}\begin{classdesc}{Model}{**kwds}
Stores properties that define a model neuron

The purpose of this class is to store the parameters that define
a model neuron, but not actually create any neurons themselves. That is
done by the \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} object. The parameters for initialising
this object are the same as for \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} less \code{N} and
with the addition of \code{equation} and \code{equations} as
alternative keywords for \code{model} (for readability of code).

At the moment, this object simply stores a copy of these keyword
assignments and passes them on to a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} when you
instantiate it with this model, so the definitive reference point is
the \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}. For convenience, we include a copy of these
arguments to initiate a \hyperlink{brian.Model}{\code{Model}} here:
\begin{description}
\item[\code{model}, \code{equation} or \code{equations}]
An object defining the neuron model. It can be
an \hyperlink{brian.Equations}{\code{Equations}} object, a string defining an \hyperlink{brian.Equations}{\code{Equations}} object,
a \code{StateUpdater} object, or a list or tuple of \hyperlink{brian.Equations}{\code{Equations}} and
strings.

\item[\code{threshold=None}]
A \hyperlink{brian.Threshold}{\code{Threshold}} object, a function or a scalar quantity.
If \code{threshold} is a function with one argument, it will be
converted to a \hyperlink{brian.SimpleFunThreshold}{\code{SimpleFunThreshold}}, otherwise it will be a
\hyperlink{brian.FunThreshold}{\code{FunThreshold}}. If \code{threshold} is a scalar, then a constant
single valued threshold with that value will be used. In this case,
the variable to apply the threshold to will be guessed. If there is
only one variable, or if you have a variable named one of
\code{V}, \code{Vm}, \code{v} or \code{vm} it will be used.

\item[\code{reset=None}]
A \hyperlink{brian.Reset}{\code{Reset}} object, a function or a scalar quantity. If it's a
function, it will be converted to a \hyperlink{brian.FunReset}{\code{FunReset}} object. If it's
a scalar, then a constant single valued reset with that value will
be used. In this case,
the variable to apply the reset to will be guessed. If there is
only one variable, or if you have a variable named one of
\code{V}, \code{Vm}, \code{v} or \code{vm} it will be used.

\item[\code{refractory=0*ms}]
A refractory period, used in combination with the \code{reset} value
if it is a scalar.

\item[\code{order=1}]
The order to use for nonlinear differential equation solvers.
TODO: more details.

\item[\code{implicit=False}]
Whether to use an implicit method for solving the differential
equations. TODO: more details.

\item[\code{max\_delay=0*ms}]
The maximum allowable delay (larger values use more memory).
TODO: more details.

\item[\code{compile=False}]
Whether or not to attempt to compile the differential equation
solvers into \code{C++} code.

\item[\code{freeze=False}]
If True, parameters are replaced by their values at the time
of initialization.

\end{description}

\textbf{Usage}

You can either pass a \hyperlink{brian.Model}{\code{Model}} as an argument to initialise a
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} or initialise a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} by writing:

\begin{Verbatim}[commandchars=@\[\]]
group @PYGbe[=] model @PYGbe[*] N
\end{Verbatim}

to create a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} of \code{N} neurons based on that model.

\textbf{Example}

Starting with a model defined like this:

\begin{Verbatim}[commandchars=@\[\]]
model @PYGbe[=] Model(equations@PYGbe[=]@PYGad[''']
@PYGad[dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt]
@PYGad[dge/dt = -ge/(5*ms) : volt]
@PYGad[dgi/dt = -gi/(10*ms) : volt]
@PYGad['''], threshold@PYGbe[=]@PYGbe[-]@PYGaw[50]@PYGbe[*]mV, reset@PYGbe[=]@PYGbe[-]@PYGaw[60]@PYGbe[*]mV)
\end{Verbatim}

The following two lines are equivalent:

\begin{Verbatim}[commandchars=@\[\]]
P @PYGbe[=] NeuronGroup(@PYGaw[4000], model@PYGbe[=]model)
P @PYGbe[=] @PYGaw[4000]@PYGbe[*]model
\end{Verbatim}
\end{classdesc}


\subsection{The \texttt{NeuronGroup} object}


\hypertarget{brian.NeuronGroup}{}\begin{classdesc}{NeuronGroup}{N, model=None, threshold=None, reset=No reset, init=None, refractory=0.0 s, clock=None, order=1, implicit=False, max\_delay=0.0 s, compile=False, freeze=False, method=None, **args}
Group of neurons

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
NeuronGroup(N,model@lb[],threshold@lb[],reset@lb[],refractory@lb[],clock@lb[],
        order@lb[],implicit@lb[],max_delay@lb[],compile@lb[],freeze@lb[],method@rb[]@rb[]@rb[]@rb[]@rb[]@rb[]@rb[]@rb[]@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{N}]
The number of neurons in the group.

\item[\code{model}]
An object defining the neuron model. It can be a \code{Model} object,
an \hyperlink{brian.Equations}{\code{Equations}} object, a string defining an \hyperlink{brian.Equations}{\code{Equations}} object,
a \code{StateUpdater} object, or a list or tuple of \hyperlink{brian.Equations}{\code{Equations}} and
strings.

\item[\code{threshold=None}]
A \hyperlink{brian.Threshold}{\code{Threshold}} object, a function or a scalar quantity.
If \code{threshold} is a function with one argument, it will be
converted to a \hyperlink{brian.SimpleFunThreshold}{\code{SimpleFunThreshold}}, otherwise it will be a
\hyperlink{brian.FunThreshold}{\code{FunThreshold}}. If \code{threshold} is a scalar, then a constant
single valued threshold with that value will be used. In this case,
the variable to apply the threshold to will be guessed. If there is
only one variable, or if you have a variable named one of
\code{V}, \code{Vm}, \code{v} or \code{vm} it will be used.

\item[\code{reset=None}]
A \hyperlink{brian.Reset}{\code{Reset}} object, a function or a scalar quantity. If it's a
function, it will be converted to a \hyperlink{brian.FunReset}{\code{FunReset}} object. If it's
a scalar, then a constant single valued reset with that value will
be used. In this case,
the variable to apply the reset to will be guessed. If there is
only one variable, or if you have a variable named one of
\code{V}, \code{Vm}, \code{v} or \code{vm} it will be used.

\item[\code{refractory=0*ms}]
A refractory period, used in combination with the \code{reset} value
if it is a scalar.

\item[\code{clock}]
A clock to use for scheduling this \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, if omitted the
default clock will be used.

\item[\code{order=1}]
The order to use for nonlinear differential equation solvers.
TODO: more details.

\item[\code{implicit=False}]
Whether to use an implicit method for solving the differential
equations. TODO: more details.

\item[\code{max\_delay=0*ms}]
The maximum allowable delay (larger values use more memory).
TODO: more details.

\item[\code{compile=False}]
Whether or not to attempt to compile the differential equation
solvers into \code{C++} code.

\item[\code{freeze=False}]
If True, parameters are replaced by their values at the time
of initialization.

\item[\code{`method=None}]
If not None, the integration method is forced. Possible values are
linear, nonlinear, Euler, exponential\_Euler (overrides implicit and order
keywords).

\end{description}

\textbf{Methods}


\hypertarget{brian.NeuronGroup.subgroup}{}\begin{methoddesc}{subgroup}{N}
Returns the next sequential subgroup of \code{N} neurons. See
the section on subgroups below.
\end{methoddesc}


\hypertarget{brian.NeuronGroup.state}{}\begin{methoddesc}{state}{var}
\hypertarget{brian.NeuronGroup.state_}{}\methodline{state\_}{var}
Returns the \code{qarray} or \code{array} respectively for state
variable \code{var}. This is the array of values for that
state variable, with length the number of neurons in the
group. The \code{qarray} form has units and checks for unit
consistency, the \code{array} form doesn't. Normally, you
should use the unit checking form, but it is slower
so if speed is a serious problem, you can use the other
form.
\end{methoddesc}

The following usages are also possible for a group \code{G}:
\begin{description}
\item[\code{G{[}i:j{]}}]
Returns the subgroup of neurons from \code{i} to \code{j}.

\item[\code{len(G)}]
Returns the number of neurons in \code{G}.

\item[\code{G.x}, \code{G.x\_}]
For any valid Python variable name \code{x} corresponding to
a state variable of the the \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, this
returns the \code{qarray} or \code{array} of values for the state
variable \code{x}, as for the \hyperlink{brian.NeuronGroup.state}{\code{state()}} and \hyperlink{brian.NeuronGroup.state_}{\code{state\_()}} methods
above.

\end{description}

\textbf{Subgroups}

A subgroup is a view on a group. It isn't a new group, it's just
a convenient way of referring to a subset of the neurons in an
already defined group. The subset has to be a continguous set of
neurons. They can be overlapping if defined with the slice
notation, or consecutive if defined with the \hyperlink{brian.NeuronGroup.subgroup}{\code{subgroup()}} method.
Subgroups can themselves be subgrouped. Subgroups can be used in
almost all situations exactly as if they were groups, except that
they cannot be passed to the \hyperlink{brian.Network}{\code{Network}} object.

\textbf{Details}

TODO: details of other methods and properties for people
wanting to write extensions?
\end{classdesc}
\index{reset}

\subsection{Resets}

Reset objects are called each network update step to reset
specified state variables of neurons that have fired.


\hypertarget{brian.Reset}{}\begin{classdesc}{Reset}{resetvalue=0.0 V, state=0}
Resets specified state variable to a fixed value

\textbf{Initialise as:}

\begin{Verbatim}[commandchars=@\[\]]
R = Reset(@lb[]resetvalue=0*mvolt@lb[], state=0@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{resetvalue}]
The value to reset to.

\item[\code{state}]
The name or number of the state variable to reset.

\end{description}

This will reset all of the neurons that have just spiked. The
given state variable of the neuron group will be set to value
\code{resetvalue}.
\end{classdesc}
\indexii{variable}{reset}

\hypertarget{brian.VariableReset}{}\begin{classdesc}{VariableReset}{resetvaluestate=1, state=0}
Resets specified state variable to the value of another state variable

Initialised with arguments:
\begin{description}
\item[\code{resetvaluestate}]
The state variable which contains the value to reset to.

\item[\code{state}]
The name or number of the state variable to reset.

\end{description}

This will reset all of the neurons that have just spiked. The
given state variable of the neuron group will be set to
the value of the state variable \code{resetvaluestate}.
\end{classdesc}
\index{refractory}

\hypertarget{brian.Refractoriness}{}\begin{classdesc}{Refractoriness}{resetvalue=0.0 V, period=5.0 ms, state=0}
Holds the state variable at the reset value for a fixed time after a spike.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
Refractoriness(@lb[]resetvalue=0*mV@lb[],period=5*ms@lb[],state=0@rb[]@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{resetvalue}]
The value to reset and hold to.

\item[\code{period}]
The length of time to hold at the reset value.

\item[\code{state}]
The name or number of the state variable to reset and hold.

\end{description}
\end{classdesc}


\hypertarget{brian.SimpleCustomRefractoriness}{}\begin{classdesc}{SimpleCustomRefractoriness}{resetfun, period=5.0 ms, state=0}
Holds the state variable at the custom reset value for a fixed time after a spike.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
SimpleCustomRefractoriness(resetfunc@lb[],period=5*ms@lb[],state=0@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{resetfun}]
The custom reset function \code{resetfun(P, spikes)} for \code{P} a
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} and \code{spikes} a list of neurons that
fired spikes.

\item[\code{period}]
The length of time to hold at the reset value.

\item[\code{state}]
The name or number of the state variable to reset and hold,
it is your responsibility to check that this corresponds to
the custom reset function.

\end{description}

The assumption is that \code{resetfun(P, spikes)} will reset the state
variable \code{state} on the group \code{P} for the spikes with indices
\code{spikes}. The values assigned by the custom reset function are
stored by this object, and they are clamped at these values for
\code{period}. This object does not introduce refractoriness for more
than the one specified variable \code{state} or for spike indices
other than those in the variable \code{spikes} passed to the custom
reset function.
\end{classdesc}


\hypertarget{brian.CustomRefractoriness}{}\begin{classdesc}{CustomRefractoriness}{resetfun, period=5.0 ms, refracfunc=None}
Holds the state variable at the custom reset value for a fixed time after a spike.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
CustomRefractoriness(resetfunc@lb[],period=5*ms@lb[],refracfunc=resetfunc@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{resetfunc}]
The custom reset function \code{resetfunc(P, spikes)} for \code{P} a
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} and \code{spikes} a list of neurons that
fired spikes.

\item[\code{refracfunc}]
The custom refractoriness function \code{refracfunc(P, indices)} for \code{P} a
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} and \code{indices} a list of neurons that are in
their refractory periods. In some cases, you can choose not to specify this,
and it will use the reset function.

\item[\code{period}]
The length of time to hold at the reset value.

\end{description}
\end{classdesc}


\hypertarget{brian.FunReset}{}\begin{classdesc}{FunReset}{resetfun}
A reset with a user-defined function.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
FunReset(resetfun)
\end{Verbatim}

with argument:
\begin{description}
\item[\code{resetfun}]
A function \code{f(G,spikes)} where \code{G} is the
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} and \code{spikes} is an array of
the indexes of the neurons to be reset.

\end{description}
\end{classdesc}


\hypertarget{brian.NoReset}{}\begin{classdesc}{NoReset}{}
Absence of reset mechanism.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
NoReset()
\end{Verbatim}
\end{classdesc}
\index{threshold}

\subsection{Thresholds}

A threshold mechanism checks which neurons have fired a
spike.
\indexii{threshold}{linear}

\hypertarget{brian.Threshold}{}\begin{classdesc}{Threshold}{threshold=1.0 mV, state=0}
All neurons with a specified state variable above a fixed value fire a spike.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
Threshold(@lb[]threshold=1*mV@lb[],state=0@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{threshold}]
The value above which a neuron will fire.

\item[\code{state}]
The state variable which is checked.

\end{description}

\textbf{Compilation}

Note that if the global variable \code{useweave} is set to \code{True}
then this function will use a \code{C++} accelerated version which
runs approximately 3x faster.
\end{classdesc}
\indexii{threshold}{variable}

\hypertarget{brian.VariableThreshold}{}\begin{classdesc}{VariableThreshold}{threshold\_state=1, state=0}
Threshold mechanism where one state variable is compared to another.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
VariableThreshold(@lb[]threshold_state=1@lb[],state=0@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{threshold\_state}]
The state holding the lower bound for spiking.

\item[\code{state}]
The state that is checked.

\end{description}

If \code{x} is the value of state variable \code{threshold\_state} on neuron
\code{i} and \code{y} is the value of state variable \code{state} on neuron
\code{i} then neuron \code{i} will fire if \code{y\textgreater{}x}.

Typically, using this class is more time efficient than writing
a custom thresholding operation.

\textbf{Compilation}

Note that if the global variable \code{useweave} is set to \code{True}
then this function will use a \code{C++} accelerated version.
\end{classdesc}
\indexii{threshold}{empirical}\indexii{threshold}{hodgkin-huxley}

\hypertarget{brian.EmpiricalThreshold}{}\begin{classdesc}{EmpiricalThreshold}{threshold=1.0 mV, refractory=1.0 ms, state=0, clock=None}
Empirical threshold, e.g. for Hodgkin-Huxley models.

In empirical models such as the Hodgkin-Huxley method, after a spike
neurons are not instantaneously reset, but reset themselves
as part of the dynamical equations defining their behaviour. This class
can be used to model that. It is a simple threshold mechanism that
checks e.g. \code{V\textgreater{}=Vt} but it only does so for neurons that haven't
recently fired (giving the dynamical equations time to reset
the values naturally). It should be used in conjunction with the
\hyperlink{brian.NoReset}{\code{NoReset}} object.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
EmpiricalThreshold(@lb[]threshold=1*mV@lb[],refractory=1*ms@lb[],state=0@lb[],clock@rb[]@rb[]@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{threshold}]
The lower bound for the state variable to induce a spike.

\item[\code{refractory}]
The time to wait after a spike before checking for spikes again.

\item[\code{state}]
The name or number of the state variable to check.

\item[\code{clock}]
If this object is being used for a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} which doesn't
use the default clock, you need to specify its clock here.

\end{description}
\end{classdesc}
\index{threshold!functional}

\hypertarget{brian.SimpleFunThreshold}{}\begin{classdesc}{SimpleFunThreshold}{thresholdfun, state=0}
Threshold mechanism with a user-specified function.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
FunThreshold(thresholdfun@lb[],state=0@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{thresholdfun}]
A function with one argument, the array of values for
the specified state variable. For efficiency, this is
a numpy array, and there is no unit checking.

\item[\code{state}]
The name or number of the state variable to pass to
the threshold function.

\end{description}

\textbf{Sample usage:}

\begin{Verbatim}[commandchars=@\[\]]
FunThreshold(@PYGay[lambda] V:V@PYGbe[>]@PYGbe[=]Vt,state@PYGbe[=]@PYGad[']@PYGad[V]@PYGad['])
\end{Verbatim}
\end{classdesc}


\hypertarget{brian.FunThreshold}{}\begin{classdesc}{FunThreshold}{thresholdfun}
Threshold mechanism with a user-specified function.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
FunThreshold(thresholdfun)
\end{Verbatim}

where \code{thresholdfun} is a function with one argument,
the 2d state value array, where each row is an array of
values for one state, of length N for N the number of
neurons in the group. For efficiency, data are numpy
arrays and there is no unit checking.

Note: if you only need to consider one state variable,
use the \hyperlink{brian.SimpleFunThreshold}{\code{SimpleFunThreshold}} object instead.
\end{classdesc}


\hypertarget{brian.NoThreshold}{}\begin{classdesc}{NoThreshold}{}
No thresholding mechanism.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
NoThreshold()
\end{Verbatim}
\end{classdesc}

\resetcurrentobjects
\indexii{integration}{methods}

\hypertarget{integration}{}\section{Integration}

See \hyperlink{numerical-integration}{\emph{Numerical integration}} for an overview.


\subsection{StateUpdaters}

Typically you don't need to worry about \code{StateUpdater} objects
because they are automatically created from the differential
equations defining your model. TODO: more details about this.
\indexii{integration}{linear}

\hypertarget{brian.LinearStateUpdater}{}\begin{classdesc}{LinearStateUpdater}{M, B=None, clock=None}
A linear model with dynamics dX/dt = M(X-B) or dX/dt = MX.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
LinearStateUpdater(M@lb[],B@lb[],clock@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{M}]
Matrix defining the differential equation.

\item[\code{B}]
Optional linear term in the differential equation.

\item[\code{clock}]
Optional clock.

\end{description}

Computes an update matrix A=exp(M dt) for the linear system,
and performs the update step.

TODO: more mathematical details?
\end{classdesc}


\hypertarget{brian.LazyStateUpdater}{}\begin{classdesc}{LazyStateUpdater}{numstatevariables=1, clock=None}
A StateUpdater that does nothing.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
LazyStateUpdater(@lb[]numstatevariables=1@lb[],clock@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{numstatevariables}]
The number of state variables to create.

\item[\code{clock}]
An optional clock to determine when it updates,
although the update function does nothing so...

\end{description}
\end{classdesc}

TODO: write docs for these StateUpdaters:
\begin{itemize}
\item {} 
StateUpdater, LinearStateUpdater more details, NonlinearStateUpdater,
NonlinearStateUpdater2, ExponentialEulerStateUpdater,
NonlinearStateUpdaterRK2, NonlinearStateUpdaterBE,
SynapticNoise

\end{itemize}

\resetcurrentobjects


\section{Standard Groups}

Some standard types of \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} have already been defined.
\hyperlink{brian.PoissonGroup}{\code{PoissonGroup}} to generate spikes with Poisson statistics,
\hyperlink{brian.PulsePacket}{\code{PulsePacket}} to generate pulse packets with specified parameters,
\hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} and \hyperlink{brian.MultipleSpikeGeneratorGroup}{\code{MultipleSpikeGeneratorGroup}} to
generate spikes which fire at prespecified times.
\indexii{poisson}{group}\indexii{poisson}{input}

\hypertarget{brian.PoissonGroup}{}\begin{classdesc}{PoissonGroup}{N, rates=0.0 Hz, clock=None}
A group that generates independent Poisson spike trains.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
PoissonGroup(N,rates@lb[],clock@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{N}]
The number of neurons in the group

\item[\code{rates}]
A scalar, array or function returning a scalar or array.
The array should have the same length as the number of
neurons in the group. The function should take one
argument \code{t} the current simulation time.

\item[\code{clock}]
The clock which the group will update with, do not
specify to use the default clock.

\end{description}
\end{classdesc}
\index{input!pulse packet}\index{pulse packet}

\hypertarget{brian.PulsePacket}{}\begin{classdesc}{PulsePacket}{t, n, sigma, clock=None}
Fires a Gaussian distributed packet of n spikes with given spread

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
PulsePacket(t,n,sigma@lb[],clock@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{t}]
The mean firing time

\item[\code{n}]
The number of spikes in the packet

\item[\code{sigma}]
The standard deviation of the firing times.

\item[\code{clock}]
The clock to use (omit to use default or local clock)

\end{description}

\textbf{Methods}

This class is derived from \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} and has all its
methods as well as one additional method:


\hypertarget{brian.PulsePacket.generate}{}\begin{methoddesc}{generate}{t, n, sigma}
Change the parameters and/or generate a new pulse packet.
\end{methoddesc}
\end{classdesc}
\indexii{direct control}{spikes}

\hypertarget{brian.SpikeGeneratorGroup}{}\begin{classdesc}{SpikeGeneratorGroup}{N, spiketimes, clock=None, period=None}
Emits spikes at given times

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
SpikeGeneratorGroup(N,spiketimes@lb[],clock@lb[],period@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{N}]
The number of neurons in the group.

\item[\code{spiketimes}]
An object specifying which neurons should fire and when. It can be a container
such as a \code{list}, containing tuples \code{(i,t)} meaning neuron \code{i} fires at
time \code{t}, or a callable object which returns such a container (which
allows you to use generator objects, see below). If \code{spiketimes} is not
a list or tuple, the pairs \code{(i,t)} need to be sorted in time. You can
also pass a numpy array \code{spiketimes} where the first column of the
array is the neuron indices, and the second column is the times in
seconds. WARNING: units are not checked in this case, and you need to
ensure that the spikes are sorted.

\item[\code{clock}]
An optional clock to update with (omit to use the default clock).

\item[\code{period}]
Optionally makes the spikes recur periodically with the given
period. Note that iterator objects cannot be used as the \code{spikelist}
with a period as they cannot be reinitialised.

\end{description}

\textbf{Sample usages}

The simplest usage would be a list of pairs \code{(i,t)}:

\begin{Verbatim}[commandchars=@\[\]]
spiketimes @PYGbe[=] @lb[](@PYGaw[0],@PYGaw[1]@PYGbe[*]ms), (@PYGaw[1],@PYGaw[2]@PYGbe[*]ms)@rb[]
SpikeGeneratorGroup(N,spiketimes)
\end{Verbatim}

A more complicated example would be to pass a generator:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[import] @PYGaV[random]
@PYGay[def] @PYGaK[nextspike]():
    nexttime @PYGbe[=] random@PYGbe[.]uniform(@PYGaw[0]@PYGbe[*]ms,@PYGaw[10]@PYGbe[*]ms)
    @PYGay[while] @PYGaA[True]:
        @PYGay[yield] (random@PYGbe[.]randint(@PYGaw[0],@PYGaw[9]),nexttime)
        nexttime @PYGbe[=] nexttime @PYGbe[+] random@PYGbe[.]uniform(@PYGaw[0]@PYGbe[*]ms,@PYGaw[10]@PYGbe[*]ms)
P @PYGbe[=] SpikeGeneratorGroup(@PYGaw[10],nextspike())
\end{Verbatim}

This would give a neuron group \code{P} with 10 neurons, where a random one
of the neurons fires at an average rate of one every 5ms.

\textbf{Notes}

Note that if a neuron fires more than one spike in a given interval \code{dt}, additional
spikes will be discarded. If you want them to stack, consider using the less efficient
\hyperlink{brian.MultipleSpikeGeneratorGroup}{\code{MultipleSpikeGeneratorGroup}} object instead. A warning will be issued if this
is detected.

Also note that if you pass a generator, then reinitialising the group will not have the
expected effect because a generator object cannot be reinitialised. Instead, you should
pass a callable object which returns a generator. In the example above, that would be
done by calling:

\begin{Verbatim}[commandchars=@\[\]]
P @PYGbe[=] SpikeGeneratorGroup(@PYGaw[10],nextspike)
\end{Verbatim}

Whenever P is reinitialised, it will call \code{nextspike()} to create the required spike
container.
\end{classdesc}


\hypertarget{brian.MultipleSpikeGeneratorGroup}{}\begin{classdesc}{MultipleSpikeGeneratorGroup}{spiketimes, clock=None, period=None}
Emits spikes at given times

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
MultipleSpikeGeneratorGroup(spiketimes@lb[],clock@lb[],period@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{spiketimes}]
a list of spike time containers, one for each neuron in the group,
although note that elements of \code{spiketimes} can also be callable objects which
return spike time containers if you want to be able to reinitialise (see below).
At it's simplest, \code{spiketimes} could be a list of lists, where \code{spiketimes{[}0{]}} contains
the firing times for neuron 0, \code{spiketimes{[}1{]}} for neuron 1, etc. But, any iterable
object can be passed, so \code{spiketimes{[}0{]}} could be a generator for example. Each
spike time container should be sorted in time. If the containers are numpy arrays units
will not be checked (times should be in seconds).

\item[\code{clock}]
A clock, if omitted the default clock will be used.

\item[\code{period}]
Optionally makes the spikes recur periodically with the given
period. Note that iterator objects cannot be used as the \code{spikelist}
with a period as they cannot be reinitialised.

\end{description}

Note that if two or more spike times fall within the same \code{dt}, spikes will stack up
and come out one per dt until the stack is exhausted. A warning will be generated
if this happens.

Also note that if you pass a generator, then reinitialising the group will not have the
expected effect because a generator object cannot be reinitialised. Instead, you should
pass a callable object which returns a generator, this will be called each time the
object is reinitialised by calling the \code{reinit()} method.

\textbf{Sample usage:}

\begin{Verbatim}[commandchars=@\[\]]
spiketimes @PYGbe[=] @lb[]@lb[]@PYGaw[1]@PYGbe[*]msecond, @PYGaw[2]@PYGbe[*]msecond@rb[]@rb[]
P @PYGbe[=] MultipleSpikeGeneratorGroup(spiketimes)
\end{Verbatim}
\end{classdesc}

\resetcurrentobjects


\section{Connections}

The best way to understand the concept of a \hyperlink{brian.Connection}{\code{Connection}} in
Brian is to work through Tutorial 2: Connections.


\hypertarget{brian.Connection}{}\begin{classdesc}{Connection}{source, target, state=0, delay=0.0 s, modulation=None, structure='sparse', **kwds}
Mechanism for propagating spikes from one group to another

A Connection object declares that when spikes in a source
group are generated, certain neurons in the target group
should have a value added to specific states. See
Tutorial 2: Connections to understand this better.

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
Connection(source, target@lb[], state=0@lb[], delay=0*ms@lb[], modulation=None@rb[]@rb[]@rb[])
\end{Verbatim}

With arguments:
\begin{description}
\item[\code{source}]
The group from which spikes will be propagated.

\item[\code{target}]
The group to which spikes will be propagated.

\item[\code{state}]
The state variable name or number that spikes will be
propagated to in the target group.

\item[\code{delay}]
The delay between a spike being generated at the source
and received at the target. At the moment, the mechanism
for delays only works for relatively short delays (an
error will be generated for delays that are too long).

\item[\code{modulation}]
The state variable name from the source group that scales
the synaptic weights (for short-term synaptic plasticity).

\item[\code{structure}]
Data structure: sparse (default), dense or computed (no storing).

\end{description}

\textbf{Methods}
\begin{description}
\item[\code{connect\_random(P,Q,p{[},weight=1{[},fixed=False{[},seed=None{]}{]}{]})}]
Connects each neuron in \code{P} to each neuron in \code{Q} with independent
probability \code{p} and weight \code{weight} (this is the amount that
gets added to the target state variable). If \code{fixed} is True, then
the number of presynaptic neurons per neuron is constant. If \code{seed}
is given, it is used as the seed to the random number generators, for
exactly repeatable results.

\item[\code{connect\_full(P,Q{[},weight=1{]})}]
Connect every neuron in \code{P} to every neuron in \code{Q} with the given
weight.

\item[\code{connect\_one\_to\_one(P,Q)}]
If \code{P} and \code{Q} have the same number of neurons then neuron \code{i}
in \code{P} will be connected to neuron \code{i} in \code{Q} with weight 1.

\item[\code{connect(P,Q,W)}]
You can specify a matrix of weights directly (can be in any format
recognised by NumPy). Note that due to internal implementation details,
passing a full matrix rather than a sparse one may slow down your code
(because zeros will be propagated as well as nonzero values).
\textbf{WARNING:} No unit checking is done at the moment.

\end{description}

Additionally, you can directly access the matrix of weights by writing:

\begin{Verbatim}[commandchars=@\[\]]
C @PYGbe[=] Connection(P,Q)
@PYGay[print] C@lb[]i,j@rb[]
C@lb[]i,j@rb[] @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}

Where here \code{i} is the source neuron and \code{j} is the target neuron.
Note: if \code{C{[}i,j{]}} should be zero, it is more efficient not to write
\code{C{[}i,j{]}=0}, if you write this then when neuron \code{i} fires all the
targets will have the value 0 added to them rather than just the
nonzero ones.
\textbf{WARNING:} No unit checking is currently done if you use this method.
Take care to set the right units.

\textbf{Advanced information}

The following methods are also defined and used internally, if you are
writing your own derived connection class you need to understand what
these do.
\begin{description}
\item[\code{propagate(spikes)}]
Action to take when source neurons with indices in \code{spikes}
fired.

\item[\code{do\_propagate()}]
The method called by the \hyperlink{brian.Network}{\code{Network}} \code{update()} step,
typically just propagates the spikes obtained by calling
the \code{get\_spikes} method of the \code{source} \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}.

\end{description}
\end{classdesc}
\indexii{connection}{matrix}\index{connection matrix}

\hypertarget{index-67}{}\subsection{Connection matrix types}
\indexii{computed}{connection}

\hypertarget{index-68}{}\subsubsection{Computed connections}

The following two connection matrix types can be given for a
\hyperlink{brian.Connection}{\code{Connection}} object.


\hypertarget{brian.UserComputedConnectionMatrix}{}\begin{classdesc}{UserComputedConnectionMatrix}{dims, row\_func}
A computed connection matrix defined by a user-specified function

Normally this matrix will be initialised by passing the class
object to the \hyperlink{brian.Connection}{\code{Connection}} object. In the initialisation
of the \hyperlink{brian.Connection}{\code{Connection}} specify \code{structure=UserComputedConnectionMatrix}
and add the keyword \code{row\_func=...}, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f](i):
    @PYGay[return] max_weight@PYGbe[*]ones(N)@PYGbe[/](@PYGaw[1]@PYGbe[+](arange(N)@PYGbe[-]i)@PYGbe[*]@PYGbe[*]@PYGaw[2])
C @PYGbe[=] Connection(G1, G2, structure@PYGbe[=]UserComputedConnectionMatrix, row_func@PYGbe[=]f)
\end{Verbatim}

Initialisation arguments:
\begin{description}
\item[\code{dims}]
The pair \code{(N,M)} specifying the dimensions of the matrix.

\item[\code{row\_func}]
The function \code{f(i)} which returns an array of length \code{M},
the weight matrix for row \code{i}. Note that you are responsible
for making sure the function returns consistent results (so
random functions should be initialised with a seed based on
the row \code{i}).

\end{description}

\textbf{Limitations}

This type of connection matrix cannot be changed during a run, and
cannot be used with methods like \code{Connection.connect\_random}.

\textbf{Efficiency considerations}

This connection matrix is for dense connectivity, if the connectivity
is sparse you might get better performance with \hyperlink{brian.UserComputedSparseConnectionMatrix}{\code{UserComputedSparseConnectionMatrix}}.
\end{classdesc}


\hypertarget{brian.UserComputedSparseConnectionMatrix}{}\begin{classdesc}{UserComputedSparseConnectionMatrix}{dims, row\_func}
A computed sparse connection matrix defined by a user-specified function

Normally this matrix will be initialised by passing the class
object to the \hyperlink{brian.Connection}{\code{Connection}} object. In the initialisation
of the \hyperlink{brian.Connection}{\code{Connection}} specify \code{structure=UserComputedSparseConnectionMatrix}
and add the keyword \code{row\_func=...}, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f](i):
    @PYGay[if] @PYGaw[0]@PYGbe[<]i@PYGbe[<]N@PYGbe[-]@PYGaw[1]:
        @PYGay[return] (@lb[]i@PYGbe[-]@PYGaw[1],i@PYGbe[+]@PYGaw[1]@rb[], weight@PYGbe[*]ones(@PYGaw[2]))
    @PYGay[elif] i@PYGbe[>]@PYGaw[0]:
        @PYGay[return] (@lb[]i@PYGbe[-]@PYGaw[1]@rb[], weight@PYGbe[*]ones(@PYGaw[1]))
    @PYGay[else]:
        @PYGay[return] (@lb[]i@PYGbe[+]@PYGaw[1]@rb[], weight@PYGbe[*]ones(@PYGaw[1]))
C @PYGbe[=] Connection(G1, G2, structure@PYGbe[=]UserComputedSparseConnectionMatrix, row_func@PYGbe[=]f)
\end{Verbatim}

Initialisation arguments:
\begin{description}
\item[\code{dims}]
The pair \code{(N,M)} specifying the dimensions of the matrix.

\item[\code{row\_func}]
The function \code{f(i)} which for a row \code{i} returns a pair \code{(indices, values))}
consisting of a list or array \code{indices} with the indices of the
nonzero elements of the row, and an array of the same length \code{values}
giving the weight matrix for those indices. Note that you are responsible
for making sure the function returns consistent results (so
random functions should be initialised with a seed based on
the row \code{i}).

\end{description}

\textbf{Limitations}

This type of connection matrix cannot be changed during a run, and
cannot be used with methods like \code{Connection.connect\_random}.

\textbf{Efficiency considerations}

This connection matrix is for sparse connectivity, if the connectivity
is dense you might get better performance with \hyperlink{brian.UserComputedConnectionMatrix}{\code{UserComputedConnectionMatrix}}.
\end{classdesc}

These standard functions can be used to define their behaviour
as an alternative to specifying your own.


\hypertarget{brian.random_row_func}{}\begin{funcdesc}{random\_row\_func}{N, p, weight=1.0, initseed=None}
Returns a random connectivity \code{row\_func} for use with \hyperlink{brian.UserComputedConnectionMatrix}{\code{UserComputedConnectionMatrix}}

Gives equivalent output to the \code{Connection.connect\_random()} method.

Arguments:
\begin{description}
\item[\code{N}]
The number of target neurons.

\item[\code{p}]
The probability of a synapse.

\item[\code{weight}]
The connection weight (must be a single value).

\item[\code{initseed}]
The initial seed value (for reproducible results).

\end{description}
\end{funcdesc}


\hypertarget{brian.random_sparse_row_func}{}\begin{funcdesc}{random\_sparse\_row\_func}{N, p, weight=1.0, initseed=None}
Returns a random connectivity \code{row\_func} for use with \hyperlink{brian.UserComputedSparseConnectionMatrix}{\code{UserComputedSparseConnectionMatrix}}

Gives equivalent output to the \code{Connection.connect\_random()} method.

Arguments:
\begin{description}
\item[\code{N}]
The number of target neurons.

\item[\code{p}]
The probability of a synapse.

\item[\code{weight}]
The connection weight (must be a single value).

\item[\code{initseed}]
The initial seed value (for reproducible results).

\end{description}
\end{funcdesc}

\resetcurrentobjects


\section{Network}

The \hyperlink{brian.Network}{\code{Network}} object stores simulation objects and runs simulations. Usage
is described in detail below. For simple scripts, you don't even need to
use the \hyperlink{brian.Network}{\code{Network}} object itself, just directly use the `'magic'' functions
\hyperlink{brian.run}{\code{run()}} and \hyperlink{brian.reinit}{\code{reinit()}} described below.


\hypertarget{brian.Network}{}\begin{classdesc}{Network}{*args, **kwds}
Contains simulation objects and runs simulations

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
Network(@PYGbe[.]@PYGbe[.]@PYGbe[.])
\end{Verbatim}

with \code{...} any collection of objects that should be added to the \hyperlink{brian.Network}{\code{Network}}.
You can also pass lists of objects, lists of lists of objects, etc. Objects
that need to passed to the \hyperlink{brian.Network}{\code{Network}} object are:
\begin{itemize}
\item {} 
\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} and anything derived from it such as \hyperlink{brian.PoissonGroup}{\code{PoissonGroup}}.

\item {} 
\hyperlink{brian.Connection}{\code{Connection}} and anything derived from it.

\item {} 
Any monitor such as \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} or \hyperlink{brian.StateMonitor}{\code{StateMonitor}}.

\item {} 
Any network operation defined with the \hyperlink{brian.network_operation}{\code{network\_operation()}} decorator.

\end{itemize}

Models, equations, etc. do not need to be passed to the \hyperlink{brian.Network}{\code{Network}} object.

The most important method is the \code{run(duration)} method which runs the simulation
for the given length of time (see below for details about what happens when you
do this).

\textbf{Example usage:}

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] NeuronGroup(@PYGbe[.]@PYGbe[.]@PYGbe[.])
C @PYGbe[=] Connection(@PYGbe[.]@PYGbe[.]@PYGbe[.])
net @PYGbe[=] Network(G,C)
net@PYGbe[.]run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

\textbf{Methods}
\begin{description}
\item[\code{add(...)}]
Add additional objects after initialisation, works the same way
as initialisation.

\item[\code{run(duration)}]
Runs the network for the given duration. See below for details about
what happens when you do this.

\item[\code{reinit()}]
Reinitialises the network, runs each object's \code{reinit()} and each
clock's \code{reinit()} method (resetting them to 0).

\item[\code{stop()}]
Can be called from a \hyperlink{brian.network_operation}{\code{network\_operation()}} for example to stop the
network from running.

\item[\code{\_\_len\_\_()}]
Returns the number of neurons in the network.

\item[\code{\_\_call\_\_(obj)}]
Similar to \code{add}, but you can only pass one object and that
object is returned. You would only need this in obscure
circumstances where objects needed to be added to the network
but were either not stored elsewhere or were stored in a way
that made them difficult to extract, for example below the
NeuronGroup object is only added to the network if certain
conditions hold:

\begin{Verbatim}[commandchars=@\[\]]
net @PYGbe[=] Network(@PYGbe[.]@PYGbe[.]@PYGbe[.])
@PYGay[if] some_condition:
    x @PYGbe[=] net(NeuronGroup(@PYGbe[.]@PYGbe[.]@PYGbe[.]))
\end{Verbatim}

\end{description}

\textbf{What happens when you run}

For an overview, see the Concepts chapter of the main documentation.

When you run the network, the first thing that happens is that it
checks if it has been prepared and calls the \code{prepare()} method
if not. This just does various housekeeping tasks and optimisations
to make the simulation run faster. Also, an update schedule is
built at this point (see below).

Now the \code{update()} method is repeatedly called until every clock
has run for the given length of time. After each call of the
\code{update()} method, the clock is advanced by one tick, and if
multiple clocks are being used, the next clock is determined (this
is the clock whose value of \code{t} is minimal amongst all the clocks).
For example, if you had two clocks in operation, say \code{clock1} with
\code{dt=3*ms} and \code{clock2} with \code{dt=5*ms} then this will happen:
\begin{enumerate}
\item {} 
\code{update()} for \code{clock1}, tick \code{clock1} to \code{t=3*ms}, next
clock is \code{clock2} with \code{t=0*ms}.

\item {} 
\code{update()} for \code{clock2}, tick \code{clock2} to \code{t=5*ms}, next
clock is \code{clock1} with \code{t=3*ms}.

\item {} 
\code{update()} for \code{clock1}, tick \code{clock1} to \code{t=6*ms}, next
clock is \code{clock2} with \code{t=5*ms}.

\item {} 
\code{update()} for \code{clock2}, tick \code{clock2} to \code{t=10*ms}, next
clock is \code{clock1} with \code{t=6*ms}.

\item {} 
\code{update()} for \code{clock1}, tick \code{clock1} to \code{t=9*ms}, next
clock is \code{clock1} with \code{t=9*ms}.

\item {} 
\code{update()} for \code{clock1}, tick \code{clock1} to \code{t=12*ms}, next
clock is \code{clock2} with \code{t=10*ms}. etc.

\end{enumerate}

The \code{update()} method simply runs each operation in the current clock's
update schedule. See below for details on the update schedule.

\textbf{Update schedules}

An update schedule is the sequence of operations that are
called for each \code{update()} step. The standard update schedule is:
\begin{itemize}
\item {} 
Network operations with \code{when = 'start'}

\item {} 
Network operations with \code{when = 'before\_groups'}

\item {} 
Call \code{update()} method for each \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, this typically
performs an integration time step for the differential equations
defining the neuron model.

\item {} 
Network operations with \code{when = 'after\_groups'}

\item {} 
Network operations with \code{when = 'middle'}

\item {} 
Network operations with \code{when = 'before\_connections'}

\item {} 
Call \code{do\_propagate()} method for each \hyperlink{brian.Connection}{\code{Connection}}, this
typically adds a value to the target state variable of each neuron
that a neuron that has fired is connected to. See Tutorial 2: Connections for
a more detailed explanation of this.

\item {} 
Network operations with \code{when = 'after\_connections'}

\item {} 
Network operations with \code{when = 'before\_resets'}

\item {} 
Call \code{reset()} method for each \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, typically resets a
given state variable to a given reset value for each neuron that fired
in this update step.

\item {} 
Network operations with \code{when = 'after\_resets'}

\item {} 
Network operations with \code{when = 'end'}

\end{itemize}

There is one predefined alternative schedule, which you can choose by calling
the \code{update\_schedule\_groups\_resets\_connections()} method before running the
network for the first time. As the name suggests, the reset operations are
done before connections (and the appropriately named network operations are
called relative to this rearrangement). You can also define your own update
schedule with the \code{set\_update\_schedule} method (see that method's API documentation for
details). This might be useful for example if you have a sequence of network
operations which need to be run in a given order.
\end{classdesc}


\hypertarget{brian.network_operation}{}\begin{funcdesc}{network\_operation}{*args, **kwds}
Decorator to make a function into a \hyperlink{brian.NetworkOperation}{\code{NetworkOperation}}

A \hyperlink{brian.NetworkOperation}{\code{NetworkOperation}} is a callable class which is called every
time step by the \hyperlink{brian.Network}{\code{Network}} \code{run} method. Sometimes it is useful
to just define a function which is to be run every update step. This
decorator can be used to turn a function into a \hyperlink{brian.NetworkOperation}{\code{NetworkOperation}}
to be added to a \hyperlink{brian.Network}{\code{Network}} object.

\textbf{Example usages}

Operation doesn't need a clock:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[f]():
    @PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}

Automagically detect clock:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[f](clock):
    @PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}

Specify a clock:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation](specifiedclock)
@PYGay[def] @PYGaK[f](clock):
    @PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}

Specify when the network operation is run (default is \code{'end'}):

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]network_operation](when@PYGbe[=]@PYGad[']@PYGad[start]@PYGad['])
@PYGay[def] @PYGaK[f]():
    @PYGbe[.]@PYGbe[.]@PYGbe[.]
\end{Verbatim}

Then add to a network as follows:

\begin{Verbatim}[commandchars=@\[\]]
net @PYGbe[=] Network(f,@PYGbe[.]@PYGbe[.]@PYGbe[.])
\end{Verbatim}
\end{funcdesc}


\hypertarget{brian.NetworkOperation}{}\begin{classdesc}{NetworkOperation}{function, clock=None, when='end'}
Callable class for operations that should be called every update step

Typically, you should just use the \hyperlink{brian.network_operation}{\code{network\_operation()}} decorator, but if you
can't for whatever reason, use this. Note: current implementation only works for
functions, not any callable object.

\textbf{Initialisation:}

\begin{Verbatim}[commandchars=@\[\]]
NetworkOperation(function@lb[],clock@rb[])
\end{Verbatim}

If your function takes an argument, the clock will be passed
as that argument.
\end{classdesc}

The `'magic'' functions \hyperlink{brian.run}{\code{run()}} and \hyperlink{brian.reinit}{\code{reinit()}} work by searching for
objects which could be added to a network, constructing a network with all
these objects, and working with that. They are suitable for simple scripts
only. If you have problems where objects are unexpectedly not being added
to the network, the  best thing to do would probably be to just use an
explicit \hyperlink{brian.Network}{\code{Network}} object as above rather than trying to tweak your
program to make the magic functions work. However, details are available
in the \code{brian/magic.py} source code.


\hypertarget{brian.run}{}\begin{funcdesc}{run}{duration, threads=1}
Run a network created from any suitable objects that can be found

\textbf{Usage:}

\begin{Verbatim}[commandchars=@\[\]]
run(duration)
\end{Verbatim}

where \code{duration} is the length of time to run the network for.

Works by constructing a \hyperlink{brian.MagicNetwork}{\code{MagicNetwork}} object from all the suitable
objects that could be found (\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, \hyperlink{brian.Connection}{\code{Connection}}, etc.) and
then running that network. Not suitable for repeated runs or situations
in which you need precise control.
\end{funcdesc}


\hypertarget{brian.reinit}{}\begin{funcdesc}{reinit}{}
Reinitialises any suitable objects that can be found

\textbf{Usage:}

\begin{Verbatim}[commandchars=@\[\]]
reinit()
\end{Verbatim}

Works by constructing a \hyperlink{brian.MagicNetwork}{\code{MagicNetwork}} object from all the suitable
objects that could be found (\hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, \hyperlink{brian.Connection}{\code{Connection}}, etc.) and
then calling \code{reinit()} for each of them. Not suitable for repeated
runs or situations in which you need precise control.
\end{funcdesc}


\hypertarget{brian.stop}{}\begin{funcdesc}{stop}{}
Globally stops any running network, this is reset the next time a network is run
\end{funcdesc}


\hypertarget{brian.MagicNetwork}{}\begin{classdesc}{MagicNetwork}{verbose=False, level=1}
Creates a \hyperlink{brian.Network}{\code{Network}} object from any suitable objects

\textbf{Initialised as:}

\begin{Verbatim}[commandchars=@\[\]]
MagicNetwork()
\end{Verbatim}

The object returned can then be used just as a regular
\hyperlink{brian.Network}{\code{Network}} object. It works by finding any object in
the `'execution frame'' (i.e. in the same function, script
or section of module code where the \hyperlink{brian.MagicNetwork}{\code{MagicNetwork}} was
created) derived from \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, \hyperlink{brian.Connection}{\code{Connection}} or
\hyperlink{brian.NetworkOperation}{\code{NetworkOperation}}.

\textbf{Sample usage:}

\begin{Verbatim}[commandchars=@\[\]]
G @PYGbe[=] NeuronGroup(@PYGbe[.]@PYGbe[.]@PYGbe[.])
C @PYGbe[=] Connection(@PYGbe[.]@PYGbe[.]@PYGbe[.])
@PYGaC[@at[]network_operation]
@PYGay[def] @PYGaK[f]():
    @PYGbe[.]@PYGbe[.]@PYGbe[.]
net @PYGbe[=] MagicNetwork()
\end{Verbatim}

Each of the objects \code{G}, \code{C} and \code{f} are added to \code{net}.

\textbf{Advanced usage:}

\begin{Verbatim}[commandchars=@\[\]]
MagicNetwork(@lb[]verbose=False@lb[],level=1@rb[]@rb[])
\end{Verbatim}

with arguments:
\begin{description}
\item[\code{verbose}]
Set to \code{True} to print out a list of objects that were
added to the network, for debugging purposes.

\item[\code{level}]
Where to find objects. \code{level=1} means look for objects
where the \hyperlink{brian.MagicNetwork}{\code{MagicNetwork}} object was created. The \code{level}
argument says how many steps back in the stack to look.

\end{description}
\end{classdesc}

\resetcurrentobjects


\section{Monitors}

Monitors are used to record properties of your network. The two
most important are \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} which records spikes, and
\hyperlink{brian.StateMonitor}{\code{StateMonitor}} which records values of state variables. These
objects are just added to the network like a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} or
\hyperlink{brian.Connection}{\code{Connection}}.

Implementation note: monitors that record spikes are classes
derived from \hyperlink{brian.Connection}{\code{Connection}}, and overwrite the \code{propagate} method
to store spikes. If you want to write your own custom spike
monitors, you can do the same (or just use \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} with
a custom function). Monitors that record values are classes
derived from \hyperlink{brian.NetworkOperation}{\code{NetworkOperation}} and implement the \code{\_\_call\_\_}
method to store values each time the network updates. Custom
state monitors are most easily written by just writing your
own network operation using the \code{network\_operation}
decorator.


\hypertarget{brian.SpikeMonitor}{}\begin{classdesc}{SpikeMonitor}{source, record=True, delay=0, function=None}
Counts or records spikes from a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}

Initialised as one of:

\begin{Verbatim}[commandchars=@\[\]]
SpikeMonitor(source(,record=True))
SpikeMonitor(source,function=function)
\end{Verbatim}

Where:
\begin{description}
\item[\code{source}]
A \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} to record from

\item[\code{record}]
\code{True} or \code{False} to record all the spikes or just summary
statistics.

\item[\code{function}]
A function \code{f(spikes)} which is passed the array of neuron
numbers that have fired called each step, to define
custom spike monitoring.

\end{description}

Has two attributes:
\begin{description}
\item[\code{nspikes}]
The number of recorded spikes

\item[\code{spikes}]
A time ordered list of pairs \code{(i,t)} where neuron \code{i} fired
at time \code{t}.

\end{description}

For \code{M} a \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}}, you can also write:
\begin{description}
\item[\code{M{[}i{]}}]
A qarray of the spike times of neuron \code{i}.

\end{description}

Notes:

\hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} is subclassed from \hyperlink{brian.Connection}{\code{Connection}}.
To define a custom monitor, either define a subclass and
rewrite the \code{propagate} method, or pass the monitoring function
as an argument (\code{function=myfunction}, with \code{def myfunction(spikes):...})
\end{classdesc}


\hypertarget{brian.SpikeCounter}{}\begin{classdesc}{SpikeCounter}{source}
Counts spikes from a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
SpikeCounter(source)
\end{Verbatim}

With argument:
\begin{description}
\item[\code{source}]
A \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} to record from

\end{description}

Has two attributes:
\begin{description}
\item[\code{nspikes}]
The number of recorded spikes

\item[\code{count}]
An array of spike counts for each neuron

\end{description}

For a \hyperlink{brian.SpikeCounter}{\code{SpikeCounter}} \code{M} you can also write \code{M{[}i{]}} for the
number of spikes counted for neuron \code{i}.
\end{classdesc}


\hypertarget{brian.PopulationSpikeCounter}{}\begin{classdesc}{PopulationSpikeCounter}{source, delay=0}
Counts spikes from a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
PopulationSpikeCounter(source)
\end{Verbatim}

With argument:
\begin{description}
\item[\code{source}]
A \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} to record from

\end{description}

Has one attribute:
\begin{description}
\item[\code{nspikes}]
The number of recorded spikes

\end{description}
\end{classdesc}


\hypertarget{brian.StateSpikeMonitor}{}\begin{classdesc}{StateSpikeMonitor}{source, var}
Counts or records spikes and state variables at spike times from a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
StateSpikeMonitor(source, var)
\end{Verbatim}

Where:
\begin{description}
\item[\code{source}]
A \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} to record from

\item[\code{var}]
The variable name or number to record from, or a tuple of variable names or numbers
if you want to record multiple variables for each spike.

\end{description}

Has two attributes:


\hypertarget{brian.StateSpikeMonitor.nspikes}{}\begin{memberdesc}{nspikes}
The number of recorded spikes
\end{memberdesc}


\hypertarget{brian.StateSpikeMonitor.spikes}{}\begin{memberdesc}{spikes}
A time ordered list of tuples \code{(i,t,v)} where neuron \code{i} fired
at time \code{t} and the specified variable had value \code{v}. If you
specify multiple variables, each tuple will be of the form
\code{(i,t,v0,v1,v2,...)} where the \code{vi} are the values corresponding
in order to the variables you specified in the \code{var} keyword.
\end{memberdesc}

And two methods:


\hypertarget{brian.StateSpikeMonitor.times}{}\begin{methoddesc}{times}{i=None}
Returns a \code{qarray} of the spike times for the whole monitored
group, or just for neuron \code{i} if specified.
\end{methoddesc}


\hypertarget{brian.StateSpikeMonitor.values}{}\begin{methoddesc}{values}{var, i=None}
Returns a \code{qarray} of the values of variable \code{var} for the
whole monitored group, or just for neuron \code{i} if specified.
\end{methoddesc}
\end{classdesc}


\hypertarget{brian.StateMonitor}{}\begin{classdesc}{StateMonitor}{P, varname, clock=None, record=False, timestep=1, when='end'}
Records the values of a state variable from a \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}.

Initialise as:

\begin{Verbatim}[commandchars=@\[\]]
StateMonitor(P,varname(,record=False)
    (,when='end)(,timestep=1)(,clock=clock))
\end{Verbatim}

Where:
\begin{description}
\item[\code{P}]
The group to be recorded from

\item[\code{varname}]
The state variable name or number to be recorded

\item[\code{record}]
What to record. The default value is \code{False} and the monitor will
only record summary statistics for the variable. You can choose
\code{record=integer} to record every value of the neuron with that
number, \code{record=``list of integers to record every value of each of
those neurons, or ``record=True} to record every value of every
neuron (although beware that this may use a lot of memory).

\item[\code{when}]
When the recording should be made in the network update, possible
values are any of the strings: \code{'start'}, \code{'before\_groups'}, \code{'after\_groups'},
\code{'before\_connections'}, \code{'after\_connections'}, \code{'before\_resets'},
\code{'after\_resets'}, \code{'end'} (in order of when they are run).

\item[\code{timestep}]
A recording will be made each timestep clock updates (so \code{timestep}
should be an integer).

\item[\code{clock}]
A clock for the update schedule, use this if you have specified a
clock other than the default one in your network, or to update at a
lower frequency than the update cycle. Note though that if the clock
here is different from the main clock, the when parameter will not
be taken into account, as network updates are done clock by clock.
Use the \code{timestep} parameter if you need recordings to be made at a
precise point in the network update step.

\end{description}

The \hyperlink{brian.StateMonitor}{\code{StateMonitor}} object has the following properties (where names
without an underscore return \code{QuantityArray} objects with appropriate
units and names with an underscore return \code{array} objects without
units):
\begin{description}
\item[\code{times}, \code{times\_}]
The times at which recordings were made

\item[\code{mean}, \code{mean\_}]
The mean value of the state variable for every neuron in the
group (not just the ones specified in the \code{record} keyword)

\item[\code{var}, \code{var\_}]
The unbiased estimate of the variances, as in \code{mean}

\item[\code{std}, \code{std\_}]
The square root of \code{var}, as in \code{mean}

\item[\code{values}, \code{values\_}]
A 2D array of the values of all the recorded neurons, each row is a
single neuron's values.

\end{description}

In addition, if \code{M`} is a \hyperlink{brian.StateMonitor}{\code{StateMonitor}} object, you write:

\begin{Verbatim}[commandchars=@\[\]]
M@lb[]i@rb[]
\end{Verbatim}

for the recorded values of neuron \code{i} (if it was specified with the
\code{record} keyword). It returns a \code{QuantityArray} object with units. Downcast
to an array without units by writing \code{asarray(M{[}i{]})}.
\end{classdesc}


\hypertarget{brian.FileSpikeMonitor}{}\begin{classdesc}{FileSpikeMonitor}{source, filename, record=False, delay=0}
Records spikes to a file

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
FileSpikeMonitor(source, filename@lb[], record=False@rb[])
\end{Verbatim}

Does everything that a \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}} does except also records
the spikes to the named file. note that spikes are recorded
as an ASCII file of lines each of the form:
\begin{quote}

\code{i, t}
\end{quote}

Where \code{i} is the neuron that fired, and \code{t} is the time in seconds.

Has one additional method:
\begin{description}
\item[\code{close\_file()}]
Closes the file manually (will happen automatically when
the program ends).

\end{description}
\end{classdesc}


\hypertarget{brian.ISIHistogramMonitor}{}\begin{classdesc}{ISIHistogramMonitor}{source, bins, delay=0}
Records the interspike interval histograms of a group.

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
ISIHistogramMonitor(source, bins)
\end{Verbatim}
\begin{description}
\item[\code{source}]
The source group to record from.

\item[\code{bins}]
The lower bounds for each bin, so that e.g.
\code{bins = {[}0*ms, 10*ms, 20*ms{]}} would correspond to
bins with intervals 0-10ms, 10-20ms and
20+ms.

\end{description}

Has properties:
\begin{description}
\item[\code{bins}]
The \code{bins} array passed at initialisation.

\item[\code{count}]
An array of length \code{len(bins)} counting how many ISIs
were in each bin.

\end{description}

This object can be passed directly to the plotting function
\hyperlink{brian.hist_plot}{\code{hist\_plot()}}.
\end{classdesc}


\hypertarget{brian.PopulationRateMonitor}{}\begin{classdesc}{PopulationRateMonitor}{source, bin=None}
Monitors and stores the (time-varying) population rate

Initialised as:

\begin{Verbatim}[commandchars=@\[\]]
PopulationRateMonitor(source,bin)
\end{Verbatim}

Records the average activity of the group for every bin.

Properties:
\begin{description}
\item[\code{rate}, \code{rate\_}]
A \code{qarray} of the rates in Hz.

\item[\code{times}, \code{times\_}]
The times of the bins.

\item[\code{bin}]
The duration of a bin (in second).

\end{description}
\end{classdesc}

\resetcurrentobjects
\index{plotting}

\hypertarget{index-85}{}\section{Plotting}
\indexii{plotting}{pylab}
Most plotting should be done with the PyLab commands, all of
which are loaded when you import Brian. See:
\begin{quote}

\href{http://matplotlib.sourceforge.net/matplotlib.pylab.html}{http://matplotlib.sourceforge.net/matplotlib.pylab.html}
\end{quote}

for help on PyLab.

Brian currently defines just two plotting functions of its own,
\hyperlink{brian.raster_plot}{\code{raster\_plot()}} and \hyperlink{brian.hist_plot}{\code{hist\_plot()}}.
\indexii{plotting}{raster}

\hypertarget{brian.raster_plot}{}\begin{funcdesc}{raster\_plot}{*monitors, **plotoptions}
Raster plot of a \hyperlink{brian.SpikeMonitor}{\code{SpikeMonitor}}

\textbf{Usage}
\begin{description}
\item[\code{raster\_plot(monitor,options...)}]
Plots the spike times of the monitor
on the x-axis, and the neuron number on the y-axis

\item[\code{raster\_plot(monitor0,monitor1,...,options...)}]
Plots the spike times
for all the monitors given, with y-axis defined by placing a spike
from neuron n of m in monitor i at position i+n/m

\item[\code{raster\_plot(options...)}]
Guesses the monitors to plot automagically

\end{description}

\textbf{Options}

Any of PyLab options for the \code{plot} command can be given, as well as:
\begin{description}
\item[\code{showplot=False}]
set to \code{True} to run pylab's \code{show()} function

\item[\code{newfigure=True}]
set to \code{False} not to create a new figure with pylab's \code{figure()} function

\item[\code{xlabel}]
label for the x-axis

\item[\code{ylabel}]
label for the y-axis

\item[\code{title}]
title for the plot

\item[\code{showgrouplines=False}]
set to \code{True} to show a line between each monitor

\item[\code{grouplinecol}]
colour for group lines

\item[\code{spacebetweengroups}]
value between 0 and 1 to insert a space between
each group on the y-axis

\end{description}
\end{funcdesc}
\indexii{plotting}{histogram}

\hypertarget{brian.hist_plot}{}\begin{funcdesc}{hist\_plot}{histmon=None, **plotoptions}
Plot a histogram

\textbf{Usage}
\begin{description}
\item[\code{hist\_plot(histmon,options...)}]
Plot the given histogram monitor

\item[\code{hist\_plot(options...)}]
Guesses which histogram monitor to use

\end{description}

with argument:
\begin{description}
\item[\code{histmon}]
is a monitor of histogram type

\end{description}

\textbf{Notes}

Plots only the first n-1 of n bars in the histogram, because
the nth bar is for the interval (-,infinity).

\textbf{Options}

Any of PyLab options for bar can be given, as well as:
\begin{description}
\item[\code{showplot=False}]
set to \code{True} to run pylab's \code{show()} function

\item[\code{newfigure=True}]
set to \code{False} not to create a new figure with pylab's \code{figure()} function

\item[\code{xlabel}]
label for the x-axis

\item[\code{ylabel}]
label for the y-axis

\item[\code{title}]
title for the plot

\end{description}
\end{funcdesc}

\resetcurrentobjects
\index{magic}

\hypertarget{index-72}{}\section{Magic in Brian}


\hypertarget{brian.magic_return}{}\begin{funcdesc}{magic\_return}{f}
Decorator to ensure that the returned object from a function is recognised by magic functions

\textbf{Usage example:}

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[f]():
    @PYGay[return] PulsePacket(@PYGaw[50]@PYGbe[*]ms, @PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

\textbf{Explanation}

Normally, code like the following wouldn't work:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f]():
    @PYGay[return] PulsePacket(@PYGaw[50]@PYGbe[*]ms, @PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
pp @PYGbe[=] f()
M @PYGbe[=] SpikeMonitor(pp)
run(@PYGaw[100]@PYGbe[*]ms)
raster_plot()
show()
\end{Verbatim}

The reason is that the magic function \hyperlink{brian.run}{\code{run()}} only recognises objects created
in the same execution frame that it is run from. The \hyperlink{brian.magic_return}{\code{magic\_return()}} decorator
corrects this, it registers the return value of a function with the magic
module. The following code will work as expected:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[f]():
    @PYGay[return] PulsePacket(@PYGaw[50]@PYGbe[*]ms, @PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
pp @PYGbe[=] f()
M @PYGbe[=] SpikeMonitor(pp)
run(@PYGaw[100]@PYGbe[*]ms)
raster_plot()
show()
\end{Verbatim}

\textbf{Technical details}

The \hyperlink{brian.magic_return}{\code{magic\_return()}} function uses \hyperlink{brian.magic_register}{\code{magic\_register()}} with the default \code{level=1}
on just the object returned by a function. See details for \hyperlink{brian.magic_register}{\code{magic\_register()}}.
\end{funcdesc}


\hypertarget{brian.magic_register}{}\begin{funcdesc}{magic\_register}{*args, **kwds}
Declare that a magically tracked object should be put in a particular frame

\textbf{Standard usage}

If \code{A} is a tracked class (derived from \code{InstanceTracker}), then the following wouldn't
work:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f]():
    x @PYGbe[=] A(@PYGad[']@PYGad[x]@PYGad['])
    @PYGay[return] x
objs @PYGbe[=] f()
@PYGay[print] get_instances(A,@PYGaw[0])@lb[]@PYGaw[0]@rb[]
\end{Verbatim}

Instead you write:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f]():
    x @PYGbe[=] A(@PYGad[']@PYGad[x]@PYGad['])
    magic_register(x)
    @PYGay[return] x    
objs @PYGbe[=] f()
@PYGay[print] get_instances(A,@PYGaw[0])@lb[]@PYGaw[0]@rb[]
\end{Verbatim}

\textbf{Definition}

Call as:

\begin{Verbatim}[commandchars=@\[\]]
magic_register(...@lb[],level=1@rb[])
\end{Verbatim}

The \code{...} can be any sequence of tracked objects or containers of tracked objects,
and each tracked object will have its instance id (the execution frame in which it was
created) set to that of its parent (or to its parent at the given level). This is
equivalent to calling:

\begin{Verbatim}[commandchars=@\[\]]
x@PYGbe[.]set_instance_id(level@PYGbe[=]level)
\end{Verbatim}

For each object \code{x} passed to \hyperlink{brian.magic_register}{\code{magic\_register()}}.
\end{funcdesc}


\begin{seealso}
\begin{description}
\item[\hyperlink{projects-with-multiple-files}{\emph{Projects with multiple files or functions}}]
Describes difficulties and solutions for using magic functions
on projects with multiple files or functions.

\end{description}

\end{seealso}

\resetcurrentobjects
\index{tests}\index{unit tests}

\hypertarget{index-94}{}\section{Tests}


\hypertarget{brian.run_all_tests}{}\begin{funcdesc}{run\_all\_tests}{}
Run all of Brian's test functions
\end{funcdesc}

TODO: Reference documentation that still needs written:
\begin{itemize}
\item {} 
Connection matrix types (dense, sparse, etc.)

\item {} 
STDP

\item {} 
STP

\item {} 
numpywrappers (and generally, the units stuff is incomplete)

\end{itemize}

\resetcurrentobjects


\chapter{Typical Tasks}

TODO: typical things you want to achieve in running your simulation,
and how to go about doing them.

\resetcurrentobjects
\index{multiple files}\indexii{multiple files}{magic functions}

\hypertarget{projects-with-multiple-files}{}\section{Projects with multiple files or functions}

Brian works with the minimal hassle if the whole of your code is in a
single Python module (\code{.py} file). This is fine when learning Brian
or for quick projects, but for larger, more realistic projects with
the source code separated into multiple files, there are some small
issues you need to be aware of. These issues essentially revolve
around the use of the `'magic'' functions \hyperlink{brian.run}{\code{run()}}, etc. The way
these functions work is to look for objects of the required type that
have been instantiated (created) in the same `'execution frame'' as
the \hyperlink{brian.run}{\code{run()}} function. In a small script, that is normally just
any objects that have been defined in that script. However, if you
define objects in a different module, or in a function, then the
magic functions won't be able to find them.

There are three main approaches then to splitting code over multiple
files (or functions).
\indexii{multiple files}{network}

\hypertarget{index-101}{}\subsection{Use the \texttt{Network} object explicitly}

The magic \hyperlink{brian.run}{\code{run()}} function works by creating a \hyperlink{brian.Network}{\code{Network}}
object automatically, and then running that network. Instead of doing
this automatically, you can create your own \hyperlink{brian.Network}{\code{Network}} object.
Rather than writing something like:

\begin{Verbatim}[commandchars=@\[\]]
group1 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
group2 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
C @PYGbe[=] Connection(group1,group2)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

You do this:

\begin{Verbatim}[commandchars=@\[\]]
group1 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
group2 @PYGbe[=] @PYGbe[.]@PYGbe[.]@PYGbe[.]
C @PYGbe[=] Connection(group1, group2)
@PYGbe[.]@PYGbe[.]@PYGbe[.]
net @PYGbe[=] Network(group1, group2, C)
net@PYGbe[.]run(@PYGaw[1]@PYGbe[*]second)
\end{Verbatim}

In other words, you explicitly say which objects are in your network.
Note that any \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}}, \hyperlink{brian.Connection}{\code{Connection}}, \code{Monitor} or
function decorated with \hyperlink{brian.network_operation}{\code{network\_operation()}} should be included in the
\hyperlink{brian.Network}{\code{Network}}. See the documentation for \hyperlink{brian.Network}{\code{Network}} for more details.

This is the preferred solution for almost all cases. You may want to use either
of the following two solutions if you think your code may be used by someone
else, or if you want to make it into an extension to Brian.
\indexii{extending brian}{magic functions}\indexii{extending brian}{magic\_return}\indexii{extending brian}{magic\_register}\indexii{multiple files}{magic\_return}\indexii{multiple files}{magic\_register}

\subsection{Use the \texttt{magic\_return()} decorator or \texttt{magic\_register()} function}

The \hyperlink{brian.magic_return}{\code{magic\_return()}} decorator is used as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[f]():
        @PYGbe[.]@PYGbe[.]@PYGbe[.]
        @PYGay[return] obj
\end{Verbatim}

Any object returned by a function decorated by \hyperlink{brian.magic_return}{\code{magic\_return()}} will be
considered to have been instantiated in the execution frame that called the
function. In other words, the magic functions will find that object even
though it was really instantiated in a different execution frame.

In more complicated scenarios, you may want to use the \hyperlink{brian.magic_register}{\code{magic\_register()}}
function. For example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[def] @PYGaK[f]():
        @PYGbe[.]@PYGbe[.]@PYGbe[.]
        magic_register(obj1, obj2)
        @PYGay[return] (obj1, obj2)
\end{Verbatim}

This does the same thing as \hyperlink{brian.magic_return}{\code{magic\_return()}} but can be used with
multiple objects. Also, you can specify a \code{level} (see documentation on
\hyperlink{brian.magic_register}{\code{magic\_register()}} for more details).
\indexii{extending brian}{derived classes}\indexii{multiple files}{derived classes}

\subsection{Use derived classes}

Rather than writing a function which returns an object, you could instead
write a derived class of the object type. So, suppose you wanted to have an
object that emitted N equally spaced spikes, with an interval dt between
them, you could use the \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}} class as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaC[@at[]magic_return]
@PYGay[def] @PYGaK[equally_spaced_spike_group](N, dt):
        spikes @PYGbe[=] @lb[](@PYGaw[0],i@PYGbe[*]dt) @PYGay[for] i @PYGan[in] @PYGaX[range](N)@rb[]
        @PYGay[return] SpikeGeneratorGroup(spikes)
\end{Verbatim}

Or alternatively, you could derive a class from \hyperlink{brian.SpikeGeneratorGroup}{\code{SpikeGeneratorGroup}}
as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[class] @PYGaN[EquallySpacedSpikeGroup](SpikeGeneratorGroup):
        @PYGay[def] @PYGaK[__init__](@PYGaA[self], N, t):
                spikes @PYGbe[=] @lb[](@PYGaw[0],i@PYGbe[*]dt) @PYGay[for] i @PYGan[in] @PYGaX[range](N)@rb[]
                SpikeGeneratorGroup@PYGbe[.]__init__(@PYGaA[self], spikes)
\end{Verbatim}

You would use these objects in the following ways:

\begin{Verbatim}[commandchars=@\[\]]
obj1 @PYGbe[=] equally_spaced_spike_group(@PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
obj2 @PYGbe[=] EquallySpacedSpikeGroup(@PYGaw[100], @PYGaw[10]@PYGbe[*]ms)
\end{Verbatim}

For simple examples like the one above, there's no particular benefit to
using derived classes, but using derived classes allows you to add
methods to your derived class for example, which might be useful. For
more experienced Python programmers, or those who are thinking about
making their code into an extension for Brian, this is probably the
preferred approach.
\indexii{extending brian}{contained objects protocol}
Finally, it may be useful to note that there is a protocol for one object
to `contain' other objects. That is, suppose you want to have an object
that can be treated as a simple \hyperlink{brian.NeuronGroup}{\code{NeuronGroup}} by the person using it,
but actually instantiates several objects (perhaps internal \hyperlink{brian.Connection}{\code{Connection}}
objects). These objects need to be added to the \hyperlink{brian.Network}{\code{Network}} object
in order for them to be run with the simulation, but the user shouldn't need
to have to know about them. To this end, for any object added to a
\hyperlink{brian.Network}{\code{Network}}, if it has an attribute \code{contained\_objects}, then any
objects in that container will also be added to the network.
\renewcommand{\indexname}{Module Index}\printmodindex\renewcommand{\indexname}{Index}

\printindex
\end{document}
